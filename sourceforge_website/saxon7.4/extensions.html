<html>

<head>
  <title>Saxon Extensions</title>
  <link rel="stylesheet" type="text/css" href="saxon-style.css">
</head>



<body>

<div align=right><a href="index.html">Saxon home page</a></div>

<h1>Saxon Extensions</h1>


<p>This page describes the extension functions and extension elements supplied with the
Saxon product.</p>

<p>If you want to implement your own extensions,
 see <a href="extensibility.html">extensibility.html</a>.</p>

<p>These extension functions and elements have been provided because there are things that are difficult
to achieve, or inefficient, using standard XSLT facilities alone. As always, it is best to stick to the
standard if you possibly can: and most things <i>are</i> possible, even if it's not obvious at first
sight.</p>

<table width="100%">
<tr><td bgcolor="#ffff00" align="center">
<b>Before using a Saxon extension, check whether there is an equivalent <a href="#EXSLT">EXSLT</a>
extension available. EXSLT extensions are more likely to be portable across XSLT processors.
</b></td></tr></table>

<p>&nbsp;</p>

<table width="100%">
  <tr>
    <td  colspan="3" class="head"><b>Contents</b></td>
  </tr>

  <tr>
    <td VALIGN="top" class="body" width="33%">
    <a href="#extension attributes"><b>Extension attributes</b></a><br>
	<a href="#allow-avt">saxon:allow-avt</a><br>
    <a href="#assignable">saxon:assignable</a><br>
    <a href="#explain">saxon:explain</a><br>
    <a href="#memo-function">saxon:memo-function</a><br>
    <a href="#output">additional xsl:output attributes</a>
    </td>

    <td VALIGN="top" class="body"  width="33%">
    <a href="#extension functions"><b>Extension functions</b></a><br>
    <!--<a href="#closure">saxon:closure()</a><br>-->
    <a href="#distinct">saxon:distinct()</a><br>
    <a href="#eval">saxon:eval()</a><br>    
    <a href="#evaluate">saxon:evaluate()</a><br>
    <a href="#expression">saxon:expression()</a><br>
    <a href="#getpseudoattribute">saxon:getPseudoAttribute()</a><br>
    <a href="#getuserdata">saxon:getUserData()</a><br>
    <a href="#hassamenodes">saxon:hasSameNodes()</a><br>  
    <a href="#highest">saxon:highest()</a><br>
    <a href="#ifnull">saxon:ifNull()</a><br>
    <a href="#leading">saxon:leading()</a><br>    
    <a href="#linenumber">saxon:lineNumber()</a><br>  
    <a href="#lowest">saxon:lowest()</a><br>
    <a href="#max">saxon:max()</a><br>
    <a href="#min">saxon:min()</a><br>
    <a href="#parse">saxon:parse()</a><br>
    <a href="#path">saxon:path()</a><br>
    <a href="#serialize">saxon:serialize()</a><br>
    <a href="#setuserdata">saxon:setUserData()</a><br>
    <a href="#string-to-unicode">saxon:string-to-unicode()</a><br>
    <a href="#sum">saxon:sum()</a><br>
    <a href="#systemid">saxon:systemId()</a><br>
    <a href="#tokenize">saxon:tokenize()</a><br>
    <a href="#unicode-to-string">saxon:unicode-to-string()</a><br>    
    </td>
    
    <td VALIGN="top" class="body" >
    <a href="#extension instructions"><b>Extension instructions</b></a><br>
    <a href="#saxon:assign">saxon:assign</a><br>
    <a href="#saxon:collation">saxon:collation</a><br>
    <a href="#saxon:doctype">saxon:doctype</a><br>
    <a href="#saxon:entity-ref">saxon:entity-ref</a><br>
    <a href="#saxon:preview">saxon:preview</a><br>
    <a href="#saxon:script">saxon:script</a><br>
    <a href="#saxon:while">saxon:while</a><br>
    </td>
  </tr>
</table>

<p>Saxon also provides a set of extension elements providing access to SQL databases.
These are described <a href="sql-extension.html">here</a>.</p>

<H3><a name="EXSLT">EXSLT</a></H3>

<p><a href="http://www.exslt.org/">EXSLT</a> is
 an initiative to define a standardized set of extension functions 
and extension elements that can be used across different XSLT processors.</p>

<p>Saxon now supports the EXSLT modules Common, Math, Sets, DatesAndTimes, and Functions. The full list
of EXSLT extension functions implemented is:</p>

<ul>
<li>common: node-set(), object-type()</li>
<li>math: abs(), acos(), asin(), atan(), atan2(),
constant(), cos(), exp(), highest(), log(), lowest(), max(), min(), power(), random(),
 sin(), sqrt(), tan(). </li>
<li>set: difference(), intersection(), distinct(), leading(), trailing(), has-same-node()</li>
<li>dates-and-times:
 date-time(), date(), time(), year(), leap-year(), month-in-year(),
month-name(), month-abbreviation(), week-in-year(), week-in-month(), day-in-year(),
day-in-month(), day-of-week-in-month(), day-in-week(), day-abbreviation(), 
hour-in-day(), minute-in-hour(), second-in-minute().</li>
</ul>


<p>These have considerable overlap with extension function and elements that have previously been
provided in the Saxon namespace. In most cases the Saxon versions of the functions remain available,
for the time being, but the EXSLT versions are preferred.</p>

<p>There are some known restrictions:</p>

<ul>
<li>In the set:leading() and set:trailing() functions, Saxon does not implement the rule 
"If the first node in the second node set is not contained in the first node set, 
then an empty node set is returned." This rule prevents a pipelined implementation. Saxon returns
all nodes that precede/follow the first/last node of the second node-set in document order, whether
or not the two node-sets intersect.</li>
</ul>

<a name="extension attributes"><h2>Extension attributes</h2></a>

<p>An extension attribute is an extra attribute on an XSL-defined element. Following the rules
of XSLT, such attributes must be in a non-default namespace. For Saxon extension elements,
the namespace must be the Saxon namespace URI "http://saxon.sf.net/"</p>

<p>For example, the saxon:assignable attribute can be set as follows:

<pre><code>
&lt;xsl:variable name="counter" saxon:assignable="yes" 
    xmlns:saxon="http://saxon.sf.net/"&gt;
</code></pre>

<p>The extension attributes supplied with the Saxon product are as follows:</p>

<table>

<a name="allow-avt"></a>
<tr><td valign="top" width="40%"><code>saxon:allow-avt</code></td>
<td>This attribute may be set on the <code>xsl:call-template</code> element.
If set to the value "yes", it causes the <code>name</code> attribute of <code>xsl:call-template</code> to be
interpreted as an attribute value template. This allows the selection of the called template
to be decided at run-time. Typical usage is:<br>
 <b>&lt;xsl:call-template name="{$tname}" saxon:allow-avt="yes"&gt;</b></td></tr>

<a name="assignable"></a>
<tr><td valign="top" width="40%"><code>saxon:assignable</code></td>
<td>This attribute may be set on the <code>xsl:variable</code> element. The permitted values
are "yes" and "no". If the variable is the subject of a
<a href="#saxon:assign">saxon:assign</a> instruction, it must be set to the value "yes".
Setting this value to "yes" also ensures that the variable is actually evaluated, which is
useful if the <code>select</code> expression calls extension functions with side-effects;
without this, a variable that is never reference may never be evaluated.</td>

<a name="explain"></a>
<tr><td valign="top" width="40%"><code>saxon:explain</code></td>
<td><p>This attribute may be set on any instruction in the stylesheet, including a literal
result element. The permitted values
are "yes" and "no". If the value is "yes", then at compile time Saxon outputs (to the standard error
output) an analysis of all XPath expressions appearing on attributes of that instruction. The
analysis includes the static type of the expression, and a representation of the expression tree
that results from Saxon's parsing and static optimization phases of processing. The tree is
represented by indentation. For example, writing:</p>

<p><code>&lt;xsl:value-of select="count(*/@test)" saxon:explain="yes" xmlns:saxon="http://saxon.sf.net/"/&gt;</code></p>

<p>produces the output:</p>

<p><code><pre>Attribute select of element xsl:value-of at line 18:
Static type: xs:integer
Optimized expression tree:
                    function count
                      path
                        child::*
                        @550</pre></code></p>
                        
<p>(Here 550 is the internal code allocated to <code>test</code> in the name pool).</p></td>


<a name="memo-function"></a>
<tr><td valign="top" width="40%"><code>saxon:memo-function</code></td>
<td>This attribute may be set on the <code>xsl:function</code> element. The permitted values
are "yes" and "no". Specifying "yes" indicates that Saxon should remember the
results of calling the function in a cache, and if the function is called again
with the same arguments, the result is retrieved from the cache rather than being
recalculated. Don't use this if the function has side-effects (for example, if
it calls <code>saxon:assign</code>, or an extension function with side-effects).
Don't use it if the function accesses context information such as the context node
or <code>position()</code> or <code>last()</code>. And be careful if the function constructs and returns a
temporary tree: the effect will be that the function returns the same tree each
time, rather than a copy of the tree (this difference will only show up if you
compare the identity of nodes in the two trees).</td>

</table>

<a name="output"><h3>Additional attributes for xsl:output</h3></a>

<p>A number of additional attributes, or attribute values, are allowed on the xsl:output
element, beyond those defined in the XSLT 2.0 specification.</p>


<h4>The method attribute</h4>

<p>The <code>method</code> attribute of <code>xsl:output</code> 
 can take the standard values "xml",
"html", "xhtml", or "text", or a <i>QName</i>.</p>

<p>If a QName is specified, the local name may be:</p>

<ul><!--
<li>the value "fop", which directs output to Apache's
FOP processor (which must be installed separately from www.apache.org)</li>-->


<li>the fully-qualified
class name of a class that implements either the 
SAX2 <code>org.xml.sax.ContentHandler</code> interface, or the
<code>net.sf.saxon.event.Receiver</code> interface. If such a value is specified,
output is directed to a newly-created instance of the user-supplied class.
You can pass additional information to this class by means of extra user-defined attributes
on the <code>xsl:output</code> element.</li>
</ul>

<p> The prefix of the <i>QName</i> must correspond to a valid
namespace URI. It is recommended to use the Saxon URI "http://saxon.sf.net/",
but this is not enforced.</p>

<!--<p>Two additional attributes are available on the <code>xsl:output</code> 
elements, for use when <code>method="saxon:fop"</code>. (Note, these are not fully
tested).</p>

<ul>
<li><code>fop:renderer</code> specifies the name of a FOP Renderer class, for example
<code>fop:renderer="org.apache.fop.render.pdf.PDFRenderer"</code>.</li>
<li><code>fop:configuration</code> specifies the name of a FOP user configuration file, for
example <code>fop:configuration="c:\config\fop.xml"</code></li>
</ul>

<p>Here <code>fop:</code> is the prefix of a namespace whose URI must be
 <code>http://saxon.sf.net/fop</code></p>-->


<h4>The saxon:indent-spaces attribute</h4>

<p>When the output is XML or HTML with indent="yes", the saxon:indent-spaces attribute may
be used to control the amount of indentation. The value must be an integer.</p>

<h4>The saxon:character-representation attribute</h4>

<p>This attribute allows greater control
over how non-ASCII characters will be represented on output.</p>

<p>With method="xml", two values are supported: "decimal" and "hex". These control whether
numeric character references are output in decimal or hexadecimal when the character
is not available in the selected encoding. </p>

<p>With HTML, the value
may hold two strings, separated by a semicolon. The first string defines how non-ASCII
characters within the character encoding will be represented, the values being "native",
"entity", "decimal", or "hex". The second string defines how characters outside the
encoding will be represented, the values being "entity", "decimal", or "hex". Here "native"
means output the character as itself; "entity" means use a defined entity reference (such
as "&amp;eacute;") if known; "decimal" and "hex" refer to numeric character references.
For example "entity;decimal" (the default) means that with encoding="iso-8859-1",
characters in the range 160-255 will be represented using standard HTML entity
references, while Unicode characters above 255 will be represented as decimal character
references.</p>

<h4>The saxon:byte-order-mark attribute</h4>

<p>This attribute may take the values "yes" or "no": the default is "no". If set to "yes",
a byte order mark (Unicode xFEFF) is output at the start of the output file. This option is
available with all output methods and all encodings, though it is most useful when producing
XML encoded in UTF-8. Under the rules of XML 1.0 Second Edition, XML parsers are required
to accept a byte order mark at the start of the file; however, some parsers written before
the Second Edition was published may reject it. <i>In particular, the Crimson parser included
as the default XML parser in JDK 1.4 rejects byte order marks.</i></p>

<h4>The saxon:next-in-chain attribute</h4>

<p>The <code>saxon:next-in-chain</code> attribute is used to direct the output to another stylesheet. The
value is the URL of a stylesheet that should be used to process the output stream. In this case
the output stream must always be pure XML, and attributes that control the format of the output
(e.g. method, cdata-section-elements, etc) will have no effect. The output of the second stylesheet
will be directed to the destination that would have been used for the first stylesheet if
no <code>saxon:next-in-chain</code> attribute were not present.</p>

<h4>The saxon:require-well-formed attribute</h4>

<p>The attribute <code>saxon:require-well-formed</code> is available, with
values "yes" or "no". The default is "no". If the value is set to "yes", and a user-written
<code>ContentHandler</code> is supplied to receive the results of the transformation, then Saxon will report an
error rather than sending a non-well-formed stream of SAX events to the <code>ContentHandler</code>.
This attribute is useful when the output of the stylesheet is sent to a component (for example an XSL-FO
rendering engine) that is not designed to accept non-well-formed XML result trees.</p>

<h4>User defined attributes</h4>

<p>Any number of
user-defined attributes may be defined on <code>xsl:output</code>. These 
attributes must have names in a non-null namespace, which must not be either the XSLT
or the Saxon namespace. These attributes are interpreted as attribute value templates.
The value of the attribute is inserted into the Properties object made available to 
the Emitter handling the output; they will be ignored by the standard output methods,
but can supply arbitrary information to a user-defined output method. The name of the
property will be the expanded name of the attribute in JAXP format, for example
"{http://my-namespace/uri}local-name", and the value will be the value as given,
after evaluation as an attribute value template.</p>



<hr>

<a name="extension functions"><h2>Extension functions</h2></a>

<p>A Saxon extension function is invoked using a name such as <code>saxon:localname()</code>.</p>

<p>The <code>saxon</code> prefix (or whatever prefix you choose to use) must be associated with the
Saxon namespace URI <code>http://saxon.sf.net/</code>. </p>

<p>For example, to invoke the <code>saxon:evaluate()</code> function, write:</p>

<p><code><pre>
&lt;xsl:variable name="expression"
      select="concat('child::', $param, '[', $index, ']')"/>
..
&lt;xsl:copy-of select="saxon:evaluate($expression)"
     xmlns:saxon="http://saxon.sf.net/"/>
</pre></code></p>


<p>The extension functions supplied with the Saxon product are as follows:</p>

<table cellspacing="15">
<!--
<tr><td valign="top" width="35%"><a name="closure"></a><b>closure(node-set, expression)</b></td>
<td><b>Not available at this release.</b> This returns a node-set obtained as the transitive closure of applying
the given expression to each node in the supplied node-set. For example, saxon:closure(.,
saxon:expression('*')) returns all the descendant elements of the context node, and 
saxon:closure(., saxon:expression(id(@idref))) returns all the elements that can be reached
by following the @idref attribute treating it as the ID of another element. The function
does not detect cycles: if cycles are present in the data, it will recurse indefinitely 
until it runs out of stack space. To allow expressions such as "*[@father=current()/@name]",
each time the expression is evaluated the current node is set to be the same as the
context node.</td></tr>
-->

<tr><td valign="top"><a name="distinct"></a><b>distinct(node-set-1, [stored-expression])</b></td>
<td><p>This returns a node-set obtained by eliminating nodes in node-set-1 that have duplicate
values for the supplied stored expression, evaluated as a string. A stored expression may be obtained as the result of calling
the <a href="#expression">saxon:expression()</a> function. If no stored expression is supplied, the default is
expression('.'), that is, the string-value of the node. If several nodes produce the same string value,
the one that is first in document order will be retained.</p>

<p>The stored expression is evaluated for each node in node-set-1 in turn, with that node as the context
node, with the context position equal to the position of that node in node-set-1, and with the context size
equal to the size of node-set-1.</p>

<p>Example: &lt;xsl:for-each select="saxon:distinct(surname, saxon:expression('substring(.,1,1)')"&gt; will
process the first surname starting with each letter of the alphabet in turn.</p>

<p><i>Note: for the single-argument version, the EXSLT distinct() function should be
used in preference, for portability reasons.</i></p></td></tr>

<tr><td valign="top"><a name="eval"></a><b>eval(stored-expression)</b></td>
<td><p>This returns the result of evaluating the supplied stored expression.
A stored expression may be obtained as the result of calling
the <a href="#expression">saxon:expression()</a> function.</p>

<p>The stored expression is evaluated in the current context, that is, the context node is the current
node, and the context position and context size are the same as the result of calling position() or last()
respectively.</p>

<p>The second and subsequent arguments to <code>saxon:eval</code> supply values for the variables
<code>$p1</code>, <code>$p2</code>, etc within the stored expression. For details see
<a href="#expression">saxon:expression</a>.</p></td></tr>


<tr><td valign="top"><a name="evaluate"></a><b>evaluate(string)</b></td>
<td><p>The supplied string must contain an XPath expression. The result of the function is the result of
evaluating the XPath expression. This is useful where an expression needs to be constructed
at run-time or passed to the stylesheet as a parameter, for example where the sort key is determined
dynamically.</p>

<p>The function <code>saxon:evaluate(string)</code> is shorthand for <code>saxon:eval(saxon:expression(string))</code>.
For the rules governing what may and may not appear in the expression, see <a href="#expression">saxon:expression</a>.
The expression may contain references to variables 
<code>$p1</code>, <code>$p2</code>, etc., and the values of these variables may be supplied in the
second, third, and subsequent arguments to the <code>saxon:evaluate()</code> call.</td></tr>




<tr><td valign="top"><a name="expression"></a><b>expression(string)</b></td>
<td><p>The supplied string must contain an XPath expression. The result of the function is a <i>stored
expression</i>, which may be supplied as an argument to other extension functions such as
<a href="#eval">saxon:eval()</a>, <a href="#sum">saxon:sum()</a> and <a href="#sum">saxon:distinct()</a>. The result of
the expression will usually depend on the current node. The context for the expression includes the namespaces in scope at this point in the
stylesheet. The expression may contain references to the nine variables <code>$p1</code>, <code>$p2</code>, ...
 <code>$p9</code> only. It may contain calls on Java extension functions, including Saxon and EXSLT-defined
 functions (other than those which are restricted to use within stylesheets, for example the saxon:evaluate()
 function itself). But it does not allow access to stylesheet variables, stylesheet functions, or 
 functions defined in the XSLT specification such as <code>key()</code> or <code>format-number()</code>.
If the expression contains namespace prefixes, these are interpreted
in terms of the namespace declarations in scope at the point where the 
<code>saxon:expression()</code> function is
called, not those in scope where the stored expression is evaluated.</p>

<p>The stored expression (if it is to be evaluated using <code>saxon:eval()</code>) may contain
references to variables named <code>$p1</code>, <code>$p2</code>, ... <code>$p9</code>. The values of
these variables can be supplied when the expression is evaluated using <code>saxon:eval</code>. The
second argument of <code>saxon:eval</code> supplies the value of <code>$p1</code>, the third
argument supplies the value of <code>$p2</code>, and so on.</p>

<p>For example, following <code>&lt;xsl:variable name="add" select="saxon:expression('$p1 + $p2')"/&gt;</code>,
the instruction <code>&lt;xsl:value-of select="saxon:eval($add, 6, 7)"/&gt;</code> will output <code>13</code>.</p></td></tr>


<tr><td valign="top" width="40%"><a name="getpseudoattribute"></a><b>get-pseudo-attribute(string)</b></td>
<td>This function parses the contents of a processing instruction whose content follows the
conventional attribute="value" structure (as defined for the &lt;?xsl-stylesheet?&gt; processing
instruction). The context node should be a processing instruction; the function returns the value
of the pseudo-attribute named in the first argument if it is present, or an empty string otherwise.</td></tr>

<tr><td valign="top" width="40%"><a name="getuserdata"></a><b>get-user-data(string)</b></td>
<td>This returns user data associated with the context node in the source document. The user data
must be set up previously using the <a href="#setuserdata">saxon:setUserData()</a> function.</td></tr>

<tr><td valign="top"><a name="hassamenodes"></a><b>has-same-nodes(node-set-1, node-set-2)</b></td>
<td>This returns a boolean that is true if and only if node-set-1 and node-set-2 contain the same
set of nodes. Note this is quite different from the "=" operator, which tests whether there is a
pair of nodes with the same string-value.</td></tr>


<tr><td valign="top"><a name="highest"></a><b>highest(node-set-1 [, stored-expression])</b></td>
<td><p>This returns (as a node-set) the node from node-set-1 that has the highest value of
the supplied stored expression, evaluated as a number. If the stored expression is
omitted, the expression "number(.)" is evaluated: that is, the string value of the node, converted
to a number. A stored expression may be obtained as the result of calling
the <a href="#expression">saxon:expression()</a> function.</p>

<p>The stored expression is evaluated for each node in node-set-1 in turn, with that node as the context
node, with the context position equal to the position of that node in node-set-1, and with the context size
equal to the size of node-set-1. Any NaN values are ignored. If the node-set is empty, the result
is an empty node-set. If several nodes have the highest value, the result node-set contains the
one that is first in document order. <i>This differs from the EXSLT highest() function, which returns
all the nodes that have the maximum value.</i><p/>

<p>Example: saxon:highest(sale, saxon:expression('@price * @qty')) will evaluate price times
 quantity for each child &lt;sale&gt; element, and return the node for which this has the highest
 value.</td></tr>



<tr><td valign="top"><a name="ifnull"></a><b>if-null(java-object)</b></td>
<td>The first argument must be a Java object wrapper returned from an external Java function.
The function returns true if the wrapped Java object is null.</td>
</tr>


<tr><td valign="top"><a name="leading"></a><b>leading(node-set-1, stored-expression)</b></td>
<td><p>This returns a node-set containing all those nodes from node-set-1 up to and excluding the
first one (in document order) for which the stored-expression evaluates to false.
A stored expression may be obtained as the result of calling
the <a href="#expression">saxon:expression()</a> function.</p>

<p>The stored expression is evaluated for each node in node-set-1 in turn, with that node as the context
node, with the context position equal to the position of that node in node-set-1 (taken in document
order), and with the context size equal to the size of node-set-1.<p/>

<p>Example: <b>saxon:leading(following-sibling::*, saxon:expression('self::para'))</b> will return 
the &lt;para&gt; elements following the current node, stopping at the first element that is not a
&lt/;para&gt;</p>

<p><i>Note: this function is quite different from the EXSLT leading() function, though both fulfil
a similar purpose.</i></td></tr>



<tr><td valign="top"><a name="linenumber"></a><b>line-number()</b></td>
<td>This returns the line number of the context node in the source document within the entity
that contains it. There are no arguments. If line numbers are not maintained for the current
document, the function returns -1. (To ensure that line numbers are maintained, use the -l
option on the command line)</td>
</tr>


<tr><td valign="top"><a name="lowest"></a><b>lowest(node-set-1 [, stored-expression])</b></td>
<td><p>This returns (as a node-set) the node from node-set-1 that has the lowest value of
the supplied stored expression, evaluated as a number. If the stored expression is
omitted, the expression "number(.)" is evaluated: that is, the string value of the node, converted
to a number. A stored expression may be obtained as the result of calling
the <a href="#expression">saxon:expression()</a> function.</p>

<p>The stored expression is evaluated for each node in node-set-1 in turn, with that node as the context
node, with the context position equal to the position of that node in node-set-1, and with the context size
equal to the size of node-set-1. Any NaN values are ignored. If the node-set is empty, the result
is an empty node-set. If several nodes have the lowest value, the result node-set contains the
one that is first in document order. <i>This differs from the EXSLT lowest() function, which returns
all the nodes that have the minimum value.</i><p/>

<p>Example: saxon:lowest(sale, saxon:expression('@price * @qty')) will evaluate price times
 quantity for each child &lt;sale&gt; element, and return the node for which this has the lowest
 value.</td></tr>



<tr><td valign="top"><a name="max"></a><b>max(node-set-1 , stored-expression)</b></td>
<td><p>This returns the maximimum value of a numeric expression resulting from evaluating the supplied stored expression for each
node in node-set-1 in turn, as a number. 
 A stored expression may be obtained as the result of calling
the <a href="#expression">saxon:expression()</a> function.</p>

<p>The stored expression is evaluated for each node in node-set-1 in turn, with that node as the context
node, with the context position equal to the position of that node in node-set-1, and with the context size
equal to the size of node-set-1. Any NaN values are ignored. If the node-set is empty, the result
is negative infinity.<p/>

<p><i>For the single-argument version of this function, use the XPath 2.0 max() function instead,
for portability.</i></p>

<p>Example: saxon:max(sale, saxon:expression('@price * @qty')) will evaluate price times
 quantity for each child &lt;sale&gt; element, and return the maximum amount.</td></tr>


<tr><td valign="top"><a name="min"></a><b>min(node-set-1 , stored-expression)</b></td>
<td><p>This returns the minimum value of a numeric expression resulting from evaluating the supplied stored expression for each
node in node-set-1 in turn, as a number. 
A stored expression may be obtained as the result of calling
the <a href="#expression">saxon:expression()</a> function.</p>

<p>The stored expression is evaluated for each node in node-set-1 in turn, with that node as the context
node, with the context position equal to the position of that node in node-set-1, and with the context size
equal to the size of node-set-1. Any NaN values are ignored. If the node-set is empty, the result
is positive infinity.<p/>

<p><i>For the single-argument version of this function, use the XPath 2.0 min() function instead,
for portability.</i></p>

<p>Example: saxon:min(sale, saxon:expression('@price * @qty')) will evaluate price times
 quantity for each child &lt;sale&gt; element, and return the minimum amount.</td></tr>


<tr><td valign="top" width="40%"><a name="parse"></a><b>parse(string)</b></td>
<td><p>This function takes a single argument, a string containing the source text of a well-formed
XML document. It returns the document node (root node) that results from parsing this text. It throws
an error if the text is not well-formed XML. Applications should not rely on the identity of the
returned document node (at present, if the function is called twice with the same arguments, it
returns a new document node each time, but this may change in future).</p>

<p>This function is useful where one XML document is embedded inside another using CDATA,
or as an alternative way of passing an XML document as a parameter to a stylesheet.</td></tr>


<tr><td valign="top" width="40%"><a name="path"></a><b>path()</b></td>
<td>This takes no arguments. It returns a string whose value is an XPath expression identifying
 the context node in the
source tree. This can be useful for diagnostics, or to create an XPointer value, or when generating
another stylesheet to process the same document. The resulting string can be used as input to the
evaluate() function, provided that any namespace prefixes it uses are declared.</td></tr>


<tr><td valign="top" width="40%"><a name="serialize"></a><b>serialize(node, format)</b></td>
<td><p>This function takes two arguments: the first is a node (generally a document or element node)
to be serialized. The second is the name of an &lt;xsl:output&gt; element in the stylesheet. 
The second argument must be known at compile time (it will typically be supplied as a string literal.)
The function serializes the specified document, or the subtree rooted at the specified element, according
to the parameters specified in the named &lt;xsl:output&gt; element, and returns the serialized 
document as a string.</p>

<p>This function is useful where the XSLT stylesheet wants to manipulate the serialized output,
for example by embedding it as CDATA inside another XML document, or prefixing it with a DOCTYPE
declaration, or inserting it into a non-XML output file.</p></td></tr>


<tr><td valign="top" width="40%"><a name="setuserdata"></a><b>set-user-data(string, value)</b></td>
<td><p>This function sets user data associated with the context node in the source document. The data
may be retrieved later (during the same stylesheet execution only) using the
<a href="#getuserdata">saxon:get-user-data()</a> function. The string serves as a name for this
property, allowing multiple pieces of user data to be associated with the same node. The value
may be any XPath value. This function returns an empty string as its nominal result.
<b>Note:</b> set-user-data() is particularly useful to save data read during preview mode processing
(see <a href="#saxon:preview">saxon:preview</a>) for later use during normal processing. However, take
care (a) not to store the data with a node that will be deleted after the preview, and (b) not to
store a node-set containing nodes that will be deleted after the preview. It is safest
to store simple values such as strings and numbers: use the string() or number() function if necessary
to do the conversion.</p>

<p>Like <code>saxon:assign</code>, this function breaks the XSLT no-side-effects rule. There is always a risk
that the Saxon optimizer will execute expressions more than once, or not at all, or in a different
order from that expected. If you use <code>saxon:set-user-data</code> within an <code>xsl:variable</code>
element, you can force evaluation of the variable by setting <code>saxon:assignable="yes"</code>.</p></td></tr>



<tr><td valign="top"><a name="sum"></a><b>sum(node-set-1, stored-expression)</b></td>
<td><p>This returns the total resulting from evaluating the supplied stored expression for each
node in node-set-1 in turn, as a number. If the result is NaN for any node, the total will be NaN.
A stored expression may be obtained as the result of calling
the <a href="#expression">saxon:expression()</a> function.</p>

<p>The stored expression is evaluated for each node in node-set-1 in turn, with that node as the context
node, with the context position equal to the position of that node in node-set-1, and with the context size
equal to the size of node-set-1.</p>

<p>Example: saxon:sum(sale, saxon:expression('@price * @qty')) will evaluate price times
 quantity for each child &lt;sale&gt; element, and return the total amount.</td></tr>



<tr><td valign="top"><a name="systemid"></a><b>systemId()</b></td>
<td>This returns the system identifier (URI) of the entity in the
source document that contains the context node. There are no arguments.</td>
</tr>


<tr><td valign="top"><a name="tokenize"></a><b>tokenize(string-1, string-2?)</b></td>
<td>The first argument is converted to a string and is treated as a list of separated tokens.
If the second argument is present, any character in string-2 is taken as a delimiter character,
and any sequence of delimiter characters is taken as a token separator. If the second argument
is omitted, any sequence of whitespace is taken as a token separator: or to put it another way,
the default for string-2 is '&amp;#x09;&amp;#x0A;&amp;#x0D;&amp;#x20;'.<br> 
A new sequence is constructed containing one string for each token; if the string is empty or
 contains a separator only then the result will be empty. 
 For example tokenize("a cup of tea") generates a sequence of four strings:
( "a", "cup", "of", "tea"). </td></tr>


<!--<tr><td valign="top"><a name="unicode-to-string"></a><b>unicode-to-string(integer*)</b></td>
<td><p>This takes a sequence of integers representing the characters of a string, and returns
the resulting string.
Each integer is the Unicode numeric code-point value for one of the characters in the string.
Note that a Unicode surrogate pair is represented by a single integer in the sequence. 
Characters below 0x20, other than 0x9, 0xA, and 0xD, are not permitted.</p>

<p>Example: saxon:unicode-to-string((80, 81, 82)) returns 'PQR'. Note the need for double parentheses:
one pair for the function call, another to delimit the sequence-valued argument.</td></tr>-->



</table>


</p>



<p>The source code of these methods, which in most cases is extremely simple,
 can be used as an example for writing
other user extension functions. It is found in class 
<code>net.sf.saxon.functions.Extensions</code>.</p>

<hr>
<a name="Extension instructions"><h2>Extension instructions</h2></a>

<p>A Saxon extension instruction is invoked using a name such as <code>&lt;saxon:localname&gt;</code>.</p>

<p>The <code>saxon</code> prefix (or whatever prefix you choose to use) must be associated with the
Saxon namespace URI <code>http://saxon.sf.net/</code>. The prefix must also be designated as an
extension element prefix by including it in the
<code>extension-element-prefixes</code> attribute on the <code>xsl:stylesheet</code> element, or the
<code>xsl:extension-element-prefixes</code> attribute on any enclosing literal result element or
extension element.</p></p>

<p>However, top-level elements such as <code>saxon:collation</code> and
<code>saxon:preview</code> can be used without
designating the prefix as an extension element prefix.</p>


<hr>

<h3><a name="saxon:assign">saxon:assign</a></h3>

<p>The <code>saxon:assign</code> element is used to change the value of a local or global variable that
has previously been declared using <code>xsl:variable</code> (or <code>xsl:param</code>).
 The variable or parameter
must be marked as assignable by including the extra attribute
 <code>saxon:assignable="yes"</code></p>

<p>As with <code>xsl:variable</code>, the name of the variable is given in the mandatory <b>name</b> attribute,
and the new value may be given either by an expression in the <code>select</code> attribute, or by expanding
the content of the <code>xsl:assign</code> element.</p>

<p>If the <code>xsl:variable</code> element has a <code>type</code> attribute, then the value is converted
to the required type of the variable in the usual way.</p>

<p>Example:</p>

<table border="1" width="100%" class="code">
  <tr>
    <td width="100%" bgcolor="#00FFFF"><pre><code>
&lt;xsl:variable name="i" select="0" saxon:assignable="yes"/&gt;
&lt;saxon:while test="$i &amp;lt; 10"&gt;
    The value of i is &lt;xsl:value-of select="$i"/&gt;
    &lt;saxon:assign name="i" select="$i+1"/&gt;
&lt;/saxon:while>
    </code></pre></td>
  </tr>
</table>

<p><b>Note:</b> Using <code>saxon:assign</code> is cheating. XSLT is designed as 
a language that is free of side-effects, which is why variables are not assignable.
Once assignment to variables is allowed, certain optimizations become impossible.
At present this doesn't affect Saxon, which generally executes the stylesheet
sequentially. However, there are some circumstances in which the order of execution
may not be quite what you expect, in which case <code>saxon:assign</code> may show
anomalous behavior. In principle the <code>saxon:assignable</code> attribute is designed
to stop Saxon doing optimizations that cause such anomalies, but you can't always rely
on this.</p>

<hr>

<h3><a name="saxon:collation">saxon:collation</a></h3>

<p>The <code>saxon:collation</code> element is a top-level element used to define 
collating sequences that may be used in sort keys and in the compare()
function and in <code>xsl:sort</code>. The collation name is a URI (though actually
any string can be used), and
is defined in the mandatory <code>name</code> attribute. The other attributes are:</p>

<ul><li><b>class</b>: the fully qualified name of a Java class that implements the 
<code>java.util.Comparator</code> interface. (Note that when collations are supported
in functions such as contains() and starts-with(), this class will have to be a
<code>java.text.RuleBasedCollator</code>.)</li>

<li><b>lang</b>: follows the rules of the <code>xml:lang</code> attribute, for example specify
"en-US" for US English. This is used to find the collation appropriate to a Java locale.</li>

<li><b>strength</b>: sets the strength of the collator. Values are "primary", "secondary",
"tertiary", and "identical". See the JDK 1.2 documentation for details.</li>

<li><b>decomposition</b>: Determines how the collator handles Unicode composed characters. 
Values are "none", "standard", and "full". See the JDK 1.2 documentation for details.</li>

<li><b>rules</b>: Sets the rules to be used by a <code>RuleBasedCollator</code>. 
See the JDK 1.2 documentation for details.</li>

<li><b>default</b>: Value is "yes" or "no". The value "yes" indicates that this collation
is to be used as the default collation. If more than one collation is specified as the default, the last one wins.
If no default collation is specified, Unicode codepoint collation is used.</li>
</ul>

<p>Sorting and comparison according to Unicode codepoints can be achieved by setting up a collator as 
<code>&lt;saxon:collation name="unicode" class="net.sf.saxon.sort.CodepointCollator"/&gt;</code></p>

<p><i>Note that a stylesheet containing a <code>saxon:collation</code> declaration cannot be
compiled at this release, because the underlying Java classes are not serializable.</i></p>

<hr />

<h3><a name="saxon:doctype">saxon:doctype</a></h3>

<p>The <code class="bold">saxon:doctype</code> instruction is used to insert a document type declaration into the
current output file. It must be instantiated before the first element in the output file is written.</p>

<p>The <code>saxon:doctype</code> instruction takes no attributes. The content of the element is a template-body
that is instantiated to create an XML document that represents the DTD to be generated; this XML
document is then serialized using a special output method that produces DTD syntax rather than
XML syntax.</p>

<p>If this element is present the doctype-system and doctype-public attributes of xsl:output are
ignored</p>

<p>The generated XML document uses the following elements, where the namespace prefix "dtd" is
used for the namespace URI "http://saxon.sf.net/dtd":</p>

<table>

<tr><td valign="top" width="30%"/>dtd:doctype</td>
<td>Represents the document type declaration. This is always the top-level element. The element
may contain dtd:element, dtd:attlist, dtd:entity, and dtd:notation elements. It may have the following
attributes:<br />
<b>name</b> (mandatory) The name of the document type<br />
<b>system</b> The system ID<br />
<b>public</b> The public ID
</td></tr>

<tr><td valign="top" width="30%"/>dtd:element</td>
<td>Represents an element type declaration. This is always a child of dtd:doctype. The element
is always empty. It may have the following attributes:<br />
<b>name</b> (mandatory) The name of the element type<br />
<b>content</b> (mandatory) The content model, exactly as it appears in a DTD, for example
content="(#PCDATA)" or content="( a | b | c)*"<br />
</td></tr>

<tr><td valign="top" width="30%"/>dtd:attlist</td>
<td>Represents an attribute list declaration. This is always a child of dtd:doctype. The element
will generally have one or more dtd:attribute children. It may have the following attributes:<br />
<b>element</b> (mandatory) The name of the element type<br />
</td></tr>

<tr><td valign="top" width="30%"/>dtd:attribute</td>
<td>Represents an attribute declaration within an attribute list.
 This is always a child of dtd:attlist. The element
will always be empty. It may have the following attributes:<br />
<b>name</b> (mandatory) The name of the attribute<br />
<b>type</b> (mandatory) The type of the attribute, exactly as it appears in a DTD, for example
type="ID" or type="( red | green | blue)"<br />
<b>value</b> (mandatory) The default value of the attribute, exactly as it appears in a DTD, for example
value="#REQUIRED" or value="#FIXED 'blue'"<br />
</td></tr>

<tr><td valign="top" width="30%"/>dtd:entity</td>
<td>Represents an entity declaration.
 This is always a child of dtd:doctype. The element may be empty, or it may have content. The
 content is a template body, which is instantiated to define the value of an internal parsed
 entity. Note that this value includes the delimiting quotes. The xsl:entity element
  may have the following attributes:<br />
<b>name</b> (mandatory) The name of the entity<br />
<b>system</b> The system identifier<br />
<b>public</b> The public identifier<br />
<b>parameter</b> Set to "yes" for a parameter entity<br />
<b>notation</b> The name of a notation, for an unparsed entity<br />
</td></tr>

<tr><td valign="top" width="30%"/>dtd:notation</td>
<td>Represents a notation declaration.
 This is always a child of dtd:doctype. The element will always be empty. It
  may have the following attributes:<br />
<b>name</b> (mandatory) The name of the notation<br />
<b>system</b> The system identifier<br />
<b>public</b> The public identifier<br />
</td></tr>

</table>

<p>Note that Saxon will perform only minimal validation on the DTD being generated; it will
output the components requested but will not check that this generates well-formed XML, let
alone that the output document instance is valid according to this DTD.</p>


<p>Example:</p>



<table border="1" width="100%" class="code">
  <tr>
    <td width="100%" bgcolor="#00FFFF"><pre><code>
&lt;xsl:template match="/"&gt;
  &lt;saxon:doctype xsl:extension-element-prefixes="saxon">
  &lt;dtd:doctype name="booklist"
        xmlns:dtd="http://saxon.sf.net/dtd" xsl:exclude-result-prefixes="dtd">
    &lt;dtd:element name="booklist" content="(book)*"/>
    &lt;dtd:element name="book" content="EMPTY"/>
    &lt;dtd:attlist element="book">
      &lt;dtd:attribute name="isbn" type="ID" value="#REQUIRED"/>
      &lt;dtd:attribute name="title" type="CDATA" value="#IMPLIED"/>
    &lt;/dtd:attlist>
    &lt;dtd:entity name="blurb">'A &lt;i>cool&lt;/i> book with &amp;gt; 200 pictures!'&lt;/dtd:entity>
    &lt;dtd:entity name="cover" system="cover.gif" notation="GIF"/>
    &lt;dtd:notation name="GIF" system="http://gif.org/"/>
  &lt;/dtd:doctype>
  &lt;/saxon:doctype>
  &lt;xsl:apply-templates/>
&lt;/xsl:template></code></pre></td>
  </tr>
</table>

<p>Although not shown in this example, there is nothing to stop the DTD being generated as the
output of a transformation, using instructions such as <code>xsl:value-of</code> and <code>xsl:call-template</code>.
It is also possible to use <code>xsl:text</code> with <code>disable-output-escaping="yes"</code> to output DTD constructs not
covered by this syntax, for example conditional sections and references to parameter entities.</p>






<hr>

<h3><a name="saxon:entity-ref">saxon:entity-ref</a></h3>


<p>The saxon:entity-ref element is useful to generate entities such as &amp;nbsp; in HTML output.
 To do this, write:</p>

<p>
<table border="1" width="100%" class="code">
  <tr>
    <td width="100%" bgcolor="#00FFFF"><pre><code>
        &lt;saxon:entity-ref name="nbsp"/&gt;
</code></pre></td>
  </tr>
</table>
</p>

<p><b>Note:</b> the preferred way to produce a non-breaking space character in the output is
simply to write <code>&amp;#160;</code> or <code>&amp;#xa0;</code> in the stylesheet. By
default, with HTML output, this will be serialized as <code>&amp;nbsp;</code>, though the
way it is serialized doesn't actually matter as far as the HTML browser is concerned.</p>



<hr>



<h3><a name="saxon:preview">saxon:preview</a></h3>


<p>The <code>saxon:preview</code> element is a top-level element used to identify elements in the
source document that will
be processed in <i>preview</i> mode. The purpose of preview mode is to enable XSLT processing
of very large documents that are too big to fit in memory: the idea is that subtrees of the
document can be processed and then discarded as soon as they are encountered.</p>

<p>There are two mandatory attributes: <code>mode</code> identifies the mode in which the relevant
templates will be applied, and <code>elements</code> is a space-separated list of element names that
will be processed in preview mode.</p>

<p>While the source XML document is being read, if an element end tag is encountered for
an element that is in the list of preview elements, the relevant template is found (using the normal
matching rules, with mode equal to the specified preview mode). This template is then executed.
After the template has completed execution, the child nodes of the preview element (but not the element
itself, nor its attributes) are deleted from the tree to save memory.</p>

<p>During the matching of a preview element and during the execution of the preview template,
 only part of the source document is visible. This part includes
the ancestors of the preview element, the descendants of the preview element, and
all nodes that precede the preview element in document order,
except for nodes that are descendants of another preview element.</p>

<p>Global variables are not available to a preview template. The supplied values of
global parameters are available, but not the default values of unsupplied parameters.</p>

<p>A preview template may write to
a secondary output destination using saxon:output, or it may set global variables using saxon:assign.
It can save information using the extension function <a href="#setuserdata">setUserData()</a>, which
can be accessed later using <a href="#getuserdata">getUserData()</a>. This is useful to save information
that would otherwise disappear when the subtree rooted at the preview element is deleted from the tree.
 The preview template may also write directly to the principal output destination. 
However, the output format for the principal output destination will
be the default XML serialization, it cannot be controlled using &lt;xsl:output&gt;.
Note also that in this case each instantiation of the preview template
will produce a subtree immediately below the root of the output tree. Normally this means the output
document will have multiple element nodes as children of the root. This is not well-formed XML, but you
can easily construct a well-formed XML document by referencing this file as an external entity.</p>

<p>One simple use for <code>saxon:preview</code> is simply to delete unwanted parts of the tree to reduce
the amount of memory needed. In this case, just provide a preview template that does nothing.</p>

<p>Preview templates are called while the tree is being built. When the tree has been completely
built, it will contain the preview elements themselves, but any nodes that were descendants of the
preview elements will have been deleted. At this stage the stylesheet is applied to the root of the
tree, in "default" mode, in the normal way. If you don't want any further processing to take place
at this stage, write a root template that does nothing: <code>&lt;xsl:template match="/"/&gt;</code>.</p>

<p>&lt;saxon:preview&gt; is not supported when a transformation is run using the JAXP 1.1 
TransformerHandler interface. It works when using the Saxon command line, or when invoking
a transformation using the <code>transform()</code> method.</p>



<hr>

<h3><a name="saxon:script">saxon:script</a></h3>


<p>The <code>saxon:script</code> element is a top-level element. 
It is used to define an implementation
for an extension function that will be used by Saxon. With
other processors, a different implementation of the same function can be selected, 
using mechanisms defined by that processor (for example, <code>xalan:script</code>).</p>

<p>The attributes for <code>saxon:script</code> are the same as the attributes
of the <code>xsl:script</code> element defined in the (now withdrawn) XSLT 1.1
working draft.</p>


<p>The <code>language</code> attribute is mandatory, and must take the value "java". 
The values "javascript", "ecmascript", or a QName are also permitted, but in this
case Saxon ignores the <code>saxon:script</code> element.</p>

<p>The <code>implements-prefix</code> attribute is mandatory, its value must be a namespace
prefix that maps to the same namespace URI as the prefix used in the extension function
call.</p>

<p>The <code>src</code> attribute is mandatory for language="java", its value must take the
form "java:fully.qualified.class.Name", for example "java:java.util.Date". It defines
the class containing the implementation of extension functions that use this prefix.</p>

<p>The <code>archive</code> attribute is optional, its value is a space-separated list of URLs
of folders or JAR files that will be searched to find the named class. If the attribute
is omitted, the class is sought on the classpath.</p>



<hr>



<h3><a name="saxon:while">saxon:while</a></h3>


<p>The <code>saxon:while</code> element is used to iterate while some condition is true.</p>

<p>The condition is given as a boolean expression in the mandatory test attribute. Because
this expression must change its value if the loop is to terminate, the condition will generally
reference a variable that is updated somewhere in the loop using an <code>saxon:assign</code> element.
Alternatively, it may test a condition that is changed by means of a call on an extension function
that has side-effects. </p>

<p>Example:</p>

<table border="1" width="100%" class="code">
  <tr>
    <td width="100%" bgcolor="#00FFFF"><pre><code>
&lt;xsl:variable name="i" expr="0"/&gt;
&lt;saxon:while test="$i &amp;lt; 10"&gt;
    The value of i is &lt;xsl:value-of select="$i"/&gt;
    &lt;saxon:assign name="i" expr="$i+1"/&gt;
&lt;/saxon:while>
    </code></pre></td>
  </tr>
</table>




<hr>
<p align="center"><a HREF="mailto:michael.h.kay@ntlworld.com">Michael H. Kay</a> <br>
14 February 2003</p>
</body>
</html>

