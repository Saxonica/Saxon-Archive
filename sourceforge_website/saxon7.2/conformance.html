<html>

<head>

<title>Standards Conformance</title>

<body leftmargin="150" bgcolor="#ddeeff"><font face="Arial, Helvetica, sans-serif">
<div align=right><a href="index.html">Saxon home page</a></div>

<p><b><font FACE="Arial, Helvetica, sans-serif" color="#FF0080" size="7">
Standards Conformance</font></b></p>

<h2>XSLT 1.0 and XPath 1.0 conformance</h2>

<p><i>Saxon XSLT implements the
XSLT 1.0 and XPath 1.0 Recommendations from the World Wide Web Consortium, found at
 <a href="http://www.w3.org/TR/xslt">
http://www.w3.org/TR/xslt</a> and
 <a href="http://www.w3.org/TR/xpath">
http://www.w3.org/TR/xpath</a>, which are 
referred to here collectively as "XSLT"</i></p>

<p>Saxon is 100% conformant to the mandatory requirements of these recommendations,
except in some cases where incompatibilities have been introduced in the
XSLT 2.0 and XPath 2.0 working drafts.</p>

<h2>XSLT 2.0 conformance</h2>

<p>Saxon 7.1 
implements many facilities defined in the draft XSLT 2.0 specification. This specification
is not yet complete, and the facilities I have chosen to implement are those that appear
to be the most stable. </p>

<p>The XSLT 2.0 features supported are as follows:</p>

<ul>
<li><p>Saxon will automatically treat a result tree fragment as a node-set when required.</p></li>

<li><p>Saxon supports the <code>xsl:principal-result-document</code> and <code>xsl:result-document</code> elements defined
 in the draft XSLT 2.0 specification, together with named <code>xsl:output</code> declarations.</p></li>
 
<li><p>Saxon supports the use of <b>xml:base</b> to define the Base URI of a node, as defined in
the XSLT 1.1 specifications, except in the case of the base URI of a processing instruction contained
in an external entity. (This feature is supported regardless of the setting of
 <code>[xsl:]version</code>)</p></li>

<li><p>The <code>separator</code> attribute on <code>xsl:value-of</code> 
and <code>xsl:copy-of</code> is implemented.</p></li>

<li><p>The <code>xsl:for-each-group</code> instruction is implemented, together with the
<code>current-group()</code> function.</p></li>

<li><p>Named sort keys (using the <code>xsl:sort-key</code> declaration) are implemented, together
with the <code>sort()</code> function that uses them.</p></li>

<li><p>The <code>collation</code> attribute in <code>xsl:sort</code> is implemented, supported
by a new <code>saxon:collation</code> declaration to manage collation names.</p></li>

<li><p>The <code>xsl:function</code> declaration is implemented.</p></li>

<li><p>Instructions such as <code>xsl:for-each</code> and <code>xsl:copy-of</code> 
can handle arbitrary sequences.</p></li>

<li><p>The <code>method="xhtml"</code> attribute on the <code>xsl:output</code> declaration
 is implemented.</p></li>

<li><p>The <code>xsl:analyze-string</code> instruction is available for regular expression
processing.</p></li>

<li><p>Variables and parameters may take an optional <code>type</code> attribute, defining the data
type of the variable.</p></li>

<li><p>A template rule can apply to several modes.</p></li>

<li><p>The value of an enclosed expression in an attribute value template may be a sequence; the
items in the sequence are output using space as a separator (this is not backwards compatible with
XSLT 1.0</p></li>

<li><p>The <code>disable-output-escaping</code> attribute of <code>xsl:attribute</code> is implemented</p></li>

<li><p>The <code>unparsed-text()</code> function is implemented.</p></li> 
</ul>

<h2>XPath 2.0 conformance</h2>

<p>Saxon 7.1 
implements many facilities defined in the draft XPath 2.0 specification. </p>

<p>The XPath 2.0 features supported are as follows:</p>

<ul>
<li><p>Saxon supports the following simple data types: string, boolean, decimal, duration, integer, float,
double, date, dateTime, time, with their literal forms and constructors. All built-in subtypes of
integer are also implemented (but note, unsignedLong does not support values greater than the maximum
value of a Long). All built-in types derived by restriction from xs:string are implemented (but not
the list types IDREFS, NMTOKENS, and ENTITIES).</p></li>

<li><p>Sequences (of nodes or simple values) are supported. The sequence constructor
<code>(a, b, c)</code> is implemented. Range expressions (<code>a to b</code>) are implemented.</p></li>

<li><p>The "for", "if, "some", and "every" expressions are implemented.</p></li>

<li><p>The operators <code>except</code>, <code>intersect</code>, <code>union</code> are implemented.</p></li>

<li><p>Any expression may now appear on the right-hand side of the "/" operator (a run-time error
is reported if it doesn't evaluate to a sequence of nodes).</p></code>

<li><p>The operators <code>is</code>, <code>isnot</code>, <code>&lt;&lt;</code>, <code>&gt;gt;</code>
are implemented.</p></li>

<li><p>The operators <code>eq</code>, <code>ne</code>, <code>lt</code>, <code>gt</code>, <code>le</code>, and <code>ge</code>
are implemented.</p></li>

<li><p>The <code>idiv</code> operator for integer division is implemented.</p></li>

<li><p>The <code>+</code> and <code>-</code> operators may be used to add or subtract
two durations of the same type. The <code>*</code> and <code>div</code> operators may
be used to multiply or divide a duration by a number. (Subtraction of two dates to yield a duration,
and addition of a date to a duration, are not yet implemented).</p></li>

<li><p>In addition to functions defined in XPath 1.0 and XSLT 1.0, the following functions are
available: avg(), base-uri(), compare(), context-item(),
current-date(), current-dateTime(), current-group(), current-time(),
dayTimeDuration-from-seconds(),
deep-equal(), distinct-nodes(), duration(),
empty(), exists(), find(), index-of(), insert(), lower-case(), 
matches(), max(), min(), node-kind(), remove(), replace(), root(),
sequence-deep-equal(), sequence-node-equal(),
string-pad(), subsequence(), time(), tokenize(), unparsed-text() [both arguments must be supplied],
upper-case(), yearMonthDuration-from-months()</p></li> 

<li><p>The component extraction functions, get-X-from-Y, for types date, dateTime, time,
and duration are also available. In the case of durations, they are named get-x-from-duration(), not
get-x-from-yearMonthDuration() or get-x-from-dayTimeDuration().</p>

<p>Note that in the dateTime and time data types, the timezone is retained as part of the value. Equality
and ordering is done by normalizing the time to UTC, but conversion to a string, and extraction of
components, reflects the timezone as originally specified.<p>

<p>Constructor functions are available in both the schema-defined namespaces 
"http://www.w3.org/2001/XMLSchema" (conventional prefix xs) and "http://www.w3.org/2001/XMLSchema-datatypes"
(conventional prefix xsd). They are available for all the built-in data types that have been implemented.
The semantics are the same as a cast, that is, <code>xs:dateTime($x)</code> means exactly the same as
 <code>cast as xs:dateTime($x)</code>.</p>
 
<p>Ordering is implemented as a total order over all durations, based on the average length of a month
(one year = 365.242199 days).</p> 
 
</ul>

<p>Note, in replace(), if the pattern matches a zero-length string, each character in the source text
is replaced by two instances of the replacement text. This is the Java behavior.</p>


<h2>Conformance with other specifications</h2>

<p>Saxon is dependant on the user-selected XML parser to ensure conformance with the XML 1.0
Recommendation and the XML Namespaces Recommendation.</p>

<p>Saxon implements the &lt;?xml-stylesheet?&gt; processing instruction as described in the 
W3C Recommendation <i>Associating StyleSheets with XML Documents</i>.
The <b>href</b> pseudo-attribute must be a URI identifying an XML document containing a stylesheet,
or a URI with a fragment identifier identifying an embedded stylesheet. The fragment must be the value
of an ID attribute declared as such in the DTD.</p>

<p>Saxon works with any SAX2-conformant XML parser that is configured to enable namespace 
processing. There is one limitation: on the startElement() call from the XMLReader to the
ContentHandler, the QName (that is, the third argument) must be present. According to the SAX2
specification, namespace-aware parsers are not obliged to supply this argument. However, all
commonly-used parsers appear to do so.</p>


<hr>

<h3>Limitations</h3>

<p>Many aspects of XSLT 2.0 and XPath 2.0 are not yet implemented. These include:</p>

<ul>


<li><p>XML Schema support, and constructs involving data types (for example, <code>instance of</code,
<code>cast as</code>, and the <code>type</code> attribute of <code>xsl:variable</code>)</p></li>

<li><p>Derived simple types (e.g. <code>xsd:short</code>), with the exception of
<code>xsd:integer</code></p></li>

<li><p>Primitive types other than those listed above, for example base64, binHex, anyURI, etc.</p></li>

<li><p>Functions and operators other than those listed above.</p></li>

<li><p>Handling of an empty sequence () as an argument to operators and functions.</p></li>

</ul>

<p>There are many areas where the semantics implemented by Saxon still reflect the XPath 1.0 rules,
for example the rules for conversion of numbers to strings. In some cases the XPath 2.0 rules in
these areas are not yet stable (that is, there are open issues documented in the current working
draft).</p>

<p>Other examples of facilities not yet implemented include: backwards compatibility
mode; the <code>xsl:import-schema</code> declaration.</p>

<h3>Documentation</h3>

<p>The XSLT specification says that the documentation for an implementation should specify
which URI schemes
are supported. Saxon supports the URI scheme implemented by the Java java.net.URL class, with
the optional addition of a fragment identifier, as described below. 
Additionally,
Saxon allows the user to nominate a URIResolver class which can be used to implement any URI scheme
the user wants.</p>

<p>The XSLT specification says that the documentation for an implementation should specify for which
media types fragment identifiers are supported. The standard URI resolver supports access to 
XML documents 
only. A simple fragment identifier is allowed, consisting of the value of an ID attribute in the
document. The effect is to return the subdocument rooted at the element with this identifier if there
is one, or an empty document otherwise. For example, the URI mydoc.xml#aaa locates the XML document
mydoc.xml, and if it contains an element &lt;eeee id="aaa"&gt;, where id is an attribute of type ID, then
the document retrieved is an XML document with this &lt;eeee&gt; element as its outermost (document) 
element.</p>

<p>The values of the vendor-specific system properties are:</p>

<table>
<tr><td width="120">xsl:version</td><td>1.8</td></tr>
<tr><td>xsl:vendor</td><td>SAXON n.n.n from Michael Kay</td></tr>
<tr><td>xsl:vendor-url</td><td>http://saxon.sf.net/</td></tr>
<tr><td>xsl:product</td><td>SAXON</td></tr>
<tr><td>xsl:product-version</td><td>n.n.n</td></tr>
</table>

<p>All these values are subject to change in future releases. Users wishing to test whether the
processor is Saxon are advised to test whether the xsl:product system property has the value
"SAXON".</p>

<p><i>The reason for returning 1.8 from <code>xsl:version</code> is that the product
is not yet fully conformant with XSLT 2.0</i></p>

<h3>Extensions</h3>

<p>Saxon implements a number of extensions to standard XSLT, following the rules for extension
functions and extension elements where appropriate. The extensions are documented in
<a href="extensions.html">extensions.html</a>. They are all implemented in accordance with
the provisions in the standard for extensibility.</p>

<h2>Character encodings supported</h2>

<p>The following is the list of encodings recognized by the built-in AElfred
parser (case-insensitive):</p>

<pre>
ISO-8859-1, 8859_1, ISO8859_1
US-ASCII, ASCII 
UTF-8, UTF8
ISO-10646-UCS-2, UTF-16, UTF-16BE, UTF-16LE
</pre>

<p>The encodings available on output are the intersection of:</p>

<pre>
ascii, us-ascii, utf-8, utf8, utf-16, utf16, iso-8859-1, iso-8859-2
koi8-r, cp852, cp1250, windows-1250, cp1251, windows-1251
(again case-insensitive)
</pre>

<p>with whatever your Java VM supports.</p>

<p>If you select an encoding that the Java VM recognizes, but which is not in the 
above list, then the output will be written in the requested encoding, but all non-ASCII
characters will be written as character references.</p>

<h2>XML 1.0 Conformance</h2>

<p>Saxon can be used with any SAX-conformant XML parser. The extent of XML conformance
depends entirely on the chosen parser.</p>

<p>The default parser is a version of &AElig;lfred. There is one known non-conformance in
the version of the &AElig;lfred parser provided with the Saxon product: it does not enforce the
constraint that the contents of a general entity must be well-formed. Note, however, that this
parser does not perform XML validation.</p>

<h2>DOM Conformance</h2>

<p>Saxon accepts input (both source document and stylesheet) from any standards-compliant DOM
implementation.</p>

<p>Saxon allows the result tree to be attached to any Document or Element node of an existing
DOM. Any DOM implementation can be used, provided it is mutable.</p>

<p>Saxon's internal tree structure (which is visible through the Java API, including the case
where Java extensions functions are called from XPath expressions) conforms with the minimal
requirements of the DOM level 2 core Java language binding. This DOM interface is read-only,
so all attempts to call updating methods throw an appropriate DOM exception. No optional
features are implemented. The DOM interfaces to Saxon's tree structure do not reveal namespace
nodes as attributes. This means it is not possible to get information about namespace
declarations except by calls such as getPrefix() and getNamespaceURI() on Element and Attr nodes).</p>

<p>If an extension function returns a DOM Node or NodeList, this must consist only of Nodes
in a tree constructed using Saxon. Since Saxon's trees cannot be updated using DOM methods, this
means that the nodes returned must either be nodes from the original source tree, or nodes from
a tree constructed using Saxon's proprietary API. It is <b>not</b> possible to construct
the tree using DOM methods such as createElement() and createAttribute().</p>

<h2>JAXP 1.1 Conformance</h2>

<p>Saxon implements the JAXP 1.1 API (including TrAX), as defined in
<a href="http://java.sun.com/aboutJava/communityprocess/review/jsr063/index.html">JSR-63</a>.
Saxon implements the interfaces in the javax.xml.transform package in full, including support for
SAX, DOM, and Stream input, and SAX, DOM, and Stream output.</p>

<p>There are restrictions in using transform() on a DOMSource when the node to be transformed
is a node other than the root (i.e. the DOM Document node). These apply only if the
supplied DOM is a third-party DOM, not if it is a Saxon-constructed tree.
Specifically, if the start node
is not the root then it must be an element; and it must not have an ancestor or preceding-sibling
node, or an ancestor with a preceding-sibling node, that is an entity reference node or CDATA
section node. In addition, the element must be part of a tree that is rooted at a Document node.</p>

<p>Saxon also implements the javax.xml.parsers API. The SAX interfaces are implemented in full.
The DOM interfaces are limited by the capabilities of the Saxon DOM, specifically the fact that
it is read-only. Nevertheless, the DocumentBuilder may be used to construct a Saxon tree, or to
obtain an empty Document node which can be supplied in a DOMResult to hold the result of a
transformation.</p>

<a name="errorrecovery"><h2>Error recovery policy</h2></a>

<p>Where the XSLT specification requires that an error be signaled, Saxon produces an error
message and terminates stylesheet execution. In the case of errors detected at compile
time, it attempts to report as many errors as possible before terminating; in the case
of run-time errors, it terminates after the first error.</p>

<p>Where the XSLT specification states that the processor may recover from an error, Saxon takes
one of three actions as described in the table below. Either it signals the error and terminates
execution, or it recovers silently from the error in the manner permitted by the specification,
or it places the action under user control. In the latter case there are three options: report the
error and terminate, recover silently, or (the default) recover after writing a warning
 to the system error output stream. These actions can be modified by supplying a user-defined
 ErrorListener.</p>

<p>Handling of individual recoverable errors is described in the table below.</p>

<table>
<tr><td><b>Error</b></td><td><b>Action</b></td></tr>

<tr>
<td valign="top">There is more than one template rule that matches a node, with the
same import precedence and priority</td>
<td valign="top">User option</td>
</tr>

<tr>
<td valign="top">There is more that one xsl:namespace-alias statement for a given prefix,
with the same import precedence</td>
<td valign="top">Recover silently</td>
</tr>

<tr>
<td valign="top">An element name defined using xsl:element is invalid</td>
<td valign="top">User option</td>
</tr>

<tr>
<td valign="top">An attribute name defined using xsl:attribute is invalid</td>
<td valign="top">User option</td>
</tr>

<tr>
<td valign="top">There are several attribute sets with the same import precedence that
define the same named attribute</td>
<td valign="top">Recover silently</td>
</tr>

<tr>
<td valign="top">A processing-instruction name defined using xsl:processing-instruction is invalid</td>
<td valign="top">User option</td>
</tr>

<tr>
<td valign="top">A node other than a text node is written to the result tree while instantiating
xsl:attribute, xsl:comment, or xsl:processing-instruction</td>
<td valign="top">User option</td>
</tr>

<tr>
<td valign="top">Invalid characters are written to the content of a comment or processing instruction</td>
<td valign="top">User option</td>
</tr>

<tr>
<td valign="top">An attribute node or namespace node is written directly to the root of a result
tree fragment, or to any other node that is not an element node.</td>
<td valign="top">User option</td>
</tr>

<tr>
<td valign="top">The document() function identifies a resource that cannot be retrieved</td>
<td valign="top">User option</td>
</tr>

<tr>
<td valign="top">There are several xsl:output elements specifying the same attribute with the same
import precedence</td>
<td valign="top">Recover silently</td>
</tr>

<tr>
<td valign="top">disable-output-escaping is used for a text node while instantiating
xsl:attribute, xsl:comment, or xsl:processing-instruction</td>
<td valign="top">Recover silently</td>
</tr>

<tr>
<td valign="top">disable-output-escaping is used for a text node within a result tree fragment
that is subsequently converted to a string or number</td>
<td valign="top">Recover silently</td>
</tr>

<tr>
<td valign="top">disable-output-escaping is used for a text node containing a character that cannot
be output using the target encoding</td>
<td valign="top">Recover silently</td>
</tr>

</table>

<hr>
<p align="center"><a HREF="mailto:michael.h.kay@ntlworld.com">Michael H. Kay</a> <br>
27 August 2002</p>
</body>
</html>
