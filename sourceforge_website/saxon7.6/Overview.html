
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html lang="EN"><head>
      <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>XSL Transformations (XSLT) Version 2.0</title><style type="text/css">
code           { font-family: monospace; }

div.constraint,
div.issue,
div.note,
div.notice     { margin-left: 2em; }

li p           { margin-top: 0.3em;
                 margin-bottom: 0.3em; }

div.exampleInner pre { margin-left: 1em;
                       margin-top: 0em; margin-bottom: 0em}
div.exampleOuter {border: 4px double gray;
                  margin: 0em; padding: 0em}
div.exampleInner { background-color: #d5dee3;
                   border-top-width: 4px;
                   border-top-style: double;
                   border-top-color: #d3d3d3;
                   border-bottom-width: 4px;
                   border-bottom-style: double;
                   border-bottom-color: #d3d3d3;
                   padding: 4px; margin: 0em }
div.exampleWrapper { margin: 4px }
div.exampleHeader { font-weight: bold;
                    margin: 4px}

p.element-syntax { border: solid thin; background-color: #ffccff }
div.proto { border: solid thin; background-color: #ffccff }
div.example { border: solid thin; background-color: turquoise; padding: 1em }
</style><link rel="stylesheet" type="text/css" href="http://www.w3.org/StyleSheets/TR/W3C-WD.css"></head><body><div class="head"><p><a href="http://www.w3.org/"><img src="http://www.w3.org/Icons/w3c_home" alt="W3C" height="48" width="72"></a></p>
<h1><a name="title" id="title"></a>XSL Transformations (XSLT) Version 2.0</h1>
<h2><a name="w3c-doctype" id="w3c-doctype"></a>W3C Working Draft 15 November 2002</h2><dl><dt>This version:</dt><dd><a href="http://www.w3.org/TR/2002/WD-xslt20-20021115/">http://www.w3.org/TR/2002/WD-xslt20-20021115/</a></dd><dt>Latest version:</dt><dd>
			<a href="http://www.w3.org/TR/xslt20/">http://www.w3.org/TR/xslt20/</a><br>
		</dd><dt>Previous versions:</dt><dd>
			<a href="http://www.w3.org/TR/2002/WD-xslt20-20020816/">http://www.w3.org/TR/2002/WD-xslt20-20020816/</a><br>
			<a href="http://www.w3.org/TR/2002/WD-xslt20-20020430/">http://www.w3.org/TR/2002/WD-xslt20-20020430/</a><br>
			<a href="http://www.w3.org/TR/2001/WD-xslt20-20011220/">http://www.w3.org/TR/2001/WD-xslt20-20011220/</a><br>
		</dd><dt>Editor:</dt><dd>Michael Kay, Software AG <a href="mailto:Michael.Kay@softwareag.com">&lt;Michael.Kay@softwareag.com&gt;</a></dd></dl><p>This document is also available in these non-normative formats: <a href="http://www.w3.org/TR/2002/WD-xslt20-20021115/Overview.html">HTML without revision markings</a> and&nbsp;<a href="http://www.w3.org/TR/2002/WD-xslt20-20021115/Overview-diff.html">HTML with revision markings</a>.</p><p class="copyright"><a href="http://www.w3.org/Consortium/Legal/ipr-notice-20000612#Copyright">Copyright</a>&nbsp;&copy;&nbsp;2002&nbsp;<a href="http://www.w3.org/"><abbr title="World Wide Web Consortium">W3C</abbr></a><sup>&reg;</sup> (<a href="http://www.lcs.mit.edu/"><abbr title="Massachusetts Institute of Technology">MIT</abbr></a>, <a href="http://www.inria.fr/"><abbr lang="fr" title="Institut National de Recherche en Informatique et Automatique">INRIA</abbr></a>, <a href="http://www.keio.ac.jp/">Keio</a>), All Rights Reserved. W3C <a href="http://www.w3.org/Consortium/Legal/ipr-notice-20000612#Legal_Disclaimer">liability</a>, <a href="http://www.w3.org/Consortium/Legal/ipr-notice-20000612#W3C_Trademarks">trademark</a>, <a href="http://www.w3.org/Consortium/Legal/copyright-documents-19990405">document use</a>, and <a href="http://www.w3.org/Consortium/Legal/copyright-software-19980720">software licensing</a> rules apply.</p></div><hr><div>
<h2><a name="abstract" id="abstract"></a>Abstract</h2><p>This specification defines the syntax and semantics of XSLT 2.0, which
is a language for transforming XML documents into other XML
documents.</p><p>XSLT 2.0 is designed to be used in conjunction with XPath 2.0,
which is defined in <a href="#XPATH20">[XPath 2.0]</a>.</p></div><div>
<h2><a name="status" id="status"></a>Status of this Document</h2><p>This document is a working draft of XSLT 2.0. It
is published in order to provide the XSLT user community with a progress report on the
evolving language specification and the outstanding issues that remain to be decided.
The document is published in two versions:
<a href="http://www.w3.org/TR/xslt20/Overview-diff.html">one that highlights changes</a> 
 since the previous published Working Draft, and 
<a href="http://www.w3.org/TR/xslt20/Overview.html">one without change highlighting</a>.  
A summary of the changes is included at <a href="#changes-in-this-draft"><b>K.2.4 Changes since the August 2002 draft</b></a>. The most
significant change is the removal of the concept of <em>principal result tree</em>: all
result trees now have the same status, though there is still an initial result tree created
implicitly if the stylesheet does not create one using <a href="#element-result-document"><code>xsl:result-document</code></a>.</p><p>This remains a draft document and may
be updated, replaced, or obsoleted by other documents at any time.  It
is inappropriate to use W3C Working Drafts as reference material or to
cite them as other than "work in progress". While prototype
implementations are encouraged, users and vendors are advised that this
working draft cannot be regarded as a stable specification.</p><p>XSLT 2.0 is a revised version of the XSLT 1.0 Recommendation
<a href="#XSLT10">[XSLT 1.0]</a> published on 16 November 1999. The changes made in this document are
intended to meet the requirements for  XSLT 2.0 described 
in 
				<a href="#XSLT20REQ">[XSLT 2.0 Requirements]</a> and to 
incorporate fixes for <a href="http://www.w3.org/1999/11/REC-xslt-19991116-errata/">errors</a>
that have been detected in XSLT 1.0. A summary of the changes since XSLT 1.0
is included in <a href="#changes"><b>K Changes from XSLT 1.0</b></a>.</p><p>XSLT 2.0 is designed to be used together with XPath 2.0, which has
been developed by the W3C XSL Working Group in collaboration with the XML Query
Working Group. The current specification of XPath 2.0 can be found in
<a href="#XPATH20">[XPath 2.0]</a>.</p><p>Comments on this specification may be sent to
 <a href="mailto:public-qt-comments@w3.org">public-qt-comments@w3.org</a>;
  <a href="http://lists.w3.org/Archives/Public/public-qt-comments/">archives</a>
of the comments are available. Archives of comments
on earlier versions of the specification can be found at
<a href="http://lists.w3.org/Archives/Public/xsl-editors/">http://lists.w3.org/Archives/Public/xsl-editors/</a>.
 Public discussion of XSL, including
XSL Transformations, takes place on the <a href="http://www.mulberrytech.com/xsl/xsl-list/index.html">XSL-List</a>
mailing list.</p><p>The English version of this specification is the only normative
version. However, for translations of this document, see <a href="http://www.w3.org/Style/XSL/translations.html">http://www.w3.org/Style/XSL/translations.html</a>.</p><p>A list of current W3C Recommendations and other technical documents
can be found at <a href="http://www.w3.org/TR/">http://www.w3.org/TR/</a>.</p><p>This specification has been produced as part of the <a href="http://www.w3.org/Style/Activity">W3C Style activity</a>.</p><p>Patent disclosures relevant
 to this specification may be found on the XSL Working Group's patent disclosure page at
<a href="http://www.w3.org/Style/XSL/Disclosures.html">http://www.w3.org/Style/XSL/Disclosures.html</a>.</p></div><div class="toc">
<h2><a name="contents" id="contents"></a>Table of Contents</h2><p class="toc">1 <a href="#introduction">Introduction</a><br>&nbsp;&nbsp;&nbsp;&nbsp;1.1 <a href="#d5e150">What is XSLT?</a><br>&nbsp;&nbsp;&nbsp;&nbsp;1.2 <a href="#d5e215">What's new in XSLT 2.0?</a><br>2 <a href="#concepts">Concepts</a><br>&nbsp;&nbsp;&nbsp;&nbsp;2.1 <a href="#d5e227">Terminology</a><br>&nbsp;&nbsp;&nbsp;&nbsp;2.2 <a href="#notation">Notation</a><br>&nbsp;&nbsp;&nbsp;&nbsp;2.3 <a href="#initiating">Initiating a Transformation</a><br>&nbsp;&nbsp;&nbsp;&nbsp;2.4 <a href="#d5e709">Executing a Transformation</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.4.1 <a href="#push-processing">Push Processing Instructions</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.4.2 <a href="#d5e835">Pull Processing Instructions</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.4.3 <a href="#result-tree-construction">Result Tree Construction</a><br>&nbsp;&nbsp;&nbsp;&nbsp;2.5 <a href="#focus">Maintaining Position: the Focus</a><br>&nbsp;&nbsp;&nbsp;&nbsp;2.6 <a href="#d5e1253">Parsing and Serialization</a><br>&nbsp;&nbsp;&nbsp;&nbsp;2.7 <a href="#extensibility">Extensibility</a><br>&nbsp;&nbsp;&nbsp;&nbsp;2.8 <a href="#d5e1319">Stylesheets and Schemas</a><br>&nbsp;&nbsp;&nbsp;&nbsp;2.9 <a href="#errors">Error Handling</a><br>3 <a href="#stylesheet-structure">Stylesheet Structure</a><br>&nbsp;&nbsp;&nbsp;&nbsp;3.1 <a href="#xslt-namespace">XSLT Namespace</a><br>&nbsp;&nbsp;&nbsp;&nbsp;3.2 <a href="#d5e1902">XSLT Media Type</a><br>&nbsp;&nbsp;&nbsp;&nbsp;3.3 <a href="#standard-attributes">Standard Attributes</a><br>&nbsp;&nbsp;&nbsp;&nbsp;3.4 <a href="#stylesheet-element">Stylesheet Element</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.4.1 <a href="#user-defined-top-level">User-defined Data Elements</a><br>&nbsp;&nbsp;&nbsp;&nbsp;3.5 <a href="#simplified-stylesheet">Simplified Stylesheet Modules</a><br>&nbsp;&nbsp;&nbsp;&nbsp;3.6 <a href="#backwards">Backwards-Compatible Processing</a><br>&nbsp;&nbsp;&nbsp;&nbsp;3.7 <a href="#forwards">Forwards-Compatible Processing</a><br>&nbsp;&nbsp;&nbsp;&nbsp;3.8 <a href="#d5e2757">Combining Stylesheet Modules</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.8.1 <a href="#include">Stylesheet Inclusion</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.8.2 <a href="#import">Stylesheet Import</a><br>&nbsp;&nbsp;&nbsp;&nbsp;3.9 <a href="#embedded">Embedded Stylesheet Modules</a><br>&nbsp;&nbsp;&nbsp;&nbsp;3.10 <a href="#import-schema">Importing Schema Components</a><br>4 <a href="#data-model">Data Model</a><br>&nbsp;&nbsp;&nbsp;&nbsp;4.1 <a href="#rootless-nodes">Parentless Nodes</a><br>&nbsp;&nbsp;&nbsp;&nbsp;4.2 <a href="#unparsed-entities">Unparsed Entities</a><br>&nbsp;&nbsp;&nbsp;&nbsp;4.3 <a href="#strip">Whitespace Stripping</a><br>&nbsp;&nbsp;&nbsp;&nbsp;4.4 <a href="#namespace-fixup">Namespace Fixup</a><br>&nbsp;&nbsp;&nbsp;&nbsp;4.5 <a href="#d-o-e-in-data-model">Disable Output Escaping</a><br>5 <a href="#constructs">Syntactic Constructs</a><br>&nbsp;&nbsp;&nbsp;&nbsp;5.1 <a href="#qname">Qualified Names</a><br>&nbsp;&nbsp;&nbsp;&nbsp;5.2 <a href="#expressions">Expressions</a><br>&nbsp;&nbsp;&nbsp;&nbsp;5.3 <a href="#patterns">Patterns</a><br>&nbsp;&nbsp;&nbsp;&nbsp;5.4 <a href="#unprefixed-qnames">Unprefixed Names in Expressions and Patterns</a><br>&nbsp;&nbsp;&nbsp;&nbsp;5.5 <a href="#attribute-value-templates">Attribute Value Templates</a><br>&nbsp;&nbsp;&nbsp;&nbsp;5.6 <a href="#content-constructors">Content Constructors</a><br>6 <a href="#rules">Template Rules</a><br>&nbsp;&nbsp;&nbsp;&nbsp;6.1 <a href="#d5e5729">Defining Template Rules</a><br>&nbsp;&nbsp;&nbsp;&nbsp;6.2 <a href="#d5e5820">Applying Template Rules</a><br>&nbsp;&nbsp;&nbsp;&nbsp;6.3 <a href="#conflict">Conflict Resolution for Template Rules</a><br>&nbsp;&nbsp;&nbsp;&nbsp;6.4 <a href="#modes">Modes</a><br>&nbsp;&nbsp;&nbsp;&nbsp;6.5 <a href="#built-in-rule">Built-in Template Rules</a><br>&nbsp;&nbsp;&nbsp;&nbsp;6.6 <a href="#apply-imports">Overriding Template Rules</a><br>7 <a href="#for-each">Repetition</a><br>8 <a href="#conditionals">Conditional Processing</a><br>&nbsp;&nbsp;&nbsp;&nbsp;8.1 <a href="#d5e6729">Conditional Processing with xsl:if
				</a><br>&nbsp;&nbsp;&nbsp;&nbsp;8.2 <a href="#d5e6792">Conditional Processing with xsl:choose
				</a><br>9 <a href="#variables-and-parameters">Variables and Parameters</a><br>&nbsp;&nbsp;&nbsp;&nbsp;9.1 <a href="#variables">Variables</a><br>&nbsp;&nbsp;&nbsp;&nbsp;9.2 <a href="#d5e7105">Parameters</a><br>&nbsp;&nbsp;&nbsp;&nbsp;9.3 <a href="#variable-values">Values of Variables and Parameters</a><br>&nbsp;&nbsp;&nbsp;&nbsp;9.4 <a href="#temporary-trees">Temporary Trees</a><br>&nbsp;&nbsp;&nbsp;&nbsp;9.5 <a href="#global-variables">Global Variables and Parameters</a><br>&nbsp;&nbsp;&nbsp;&nbsp;9.6 <a href="#local-variables">Local Variables and Parameters</a><br>&nbsp;&nbsp;&nbsp;&nbsp;9.7 <a href="#d5e7759">Scope of Variables</a><br>&nbsp;&nbsp;&nbsp;&nbsp;9.8 <a href="#circularity">Circular Definitions</a><br>10 <a href="#callable-components">Callable Components</a><br>&nbsp;&nbsp;&nbsp;&nbsp;10.1 <a href="#named-templates">Named Templates</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10.1.1 <a href="#with-param">Passing Parameters to Templates</a><br>&nbsp;&nbsp;&nbsp;&nbsp;10.2 <a href="#attribute-sets">Named Attribute Sets</a><br>&nbsp;&nbsp;&nbsp;&nbsp;10.3 <a href="#stylesheet-functions">Stylesheet Functions</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10.3.1 <a href="#d5e8663">Defining a Stylesheet Function</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10.3.2 <a href="#d5e8948">Returning the Result</a><br>11 <a href="#creating-new-nodes">Creating New Nodes</a><br>&nbsp;&nbsp;&nbsp;&nbsp;11.1 <a href="#literal-result-element">Literal Result Elements</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;11.1.1 <a href="#d5e9128">Setting the Type Annotation for Literal Result Elements</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;11.1.2 <a href="#d5e9200">Attribute Nodes for Literal Result Elements</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;11.1.3 <a href="#lre-namespaces">Namespace Nodes for Literal Result Elements</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;11.1.4 <a href="#namespace-aliasing">Namespace Aliasing</a><br>&nbsp;&nbsp;&nbsp;&nbsp;11.2 <a href="#d5e9537">Creating Element Nodes using xsl:element
				</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;11.2.1 <a href="#d5e9721">Setting the Type Annotation for a Constructed Element Node</a><br>&nbsp;&nbsp;&nbsp;&nbsp;11.3 <a href="#creating-attributes">Creating Attribute Nodes using xsl:attribute
				</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;11.3.1 <a href="#d5e10037">Setting the Type Annotation for a Constructed Attribute Node</a><br>&nbsp;&nbsp;&nbsp;&nbsp;11.4 <a href="#d5e10096">Creating Text Nodes</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;11.4.1 <a href="#d5e10099">Literal Text Nodes</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;11.4.2 <a href="#d5e10125">Creating Text Nodes using xsl:text
					</a><br>&nbsp;&nbsp;&nbsp;&nbsp;11.5 <a href="#d5e10200">Creating Processing Instructions</a><br>&nbsp;&nbsp;&nbsp;&nbsp;11.6 <a href="#creating-namespace-nodes">Creating Namespace Nodes</a><br>&nbsp;&nbsp;&nbsp;&nbsp;11.7 <a href="#d5e10462">Creating Comments</a><br>&nbsp;&nbsp;&nbsp;&nbsp;11.8 <a href="#copying">Copying Nodes from a Source Tree to a Result Tree</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;11.8.1 <a href="#shallow-copy">Shallow Copy</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;11.8.2 <a href="#copy-of">Deep Copy</a><br>&nbsp;&nbsp;&nbsp;&nbsp;11.9 <a href="#value-of">Generating Text with xsl:value-of
				</a><br>12 <a href="#number">Numbering</a><br>&nbsp;&nbsp;&nbsp;&nbsp;12.1 <a href="#d5e11136">Formatting a Supplied Number</a><br>&nbsp;&nbsp;&nbsp;&nbsp;12.2 <a href="#d5e11213">Numbering based on Position in a Document
				</a><br>&nbsp;&nbsp;&nbsp;&nbsp;12.3 <a href="#convert">Number to String Conversion Attributes</a><br>13 <a href="#sorting">Sorting</a><br>&nbsp;&nbsp;&nbsp;&nbsp;13.1 <a href="#collating-sequences">Collating Sequences</a><br>&nbsp;&nbsp;&nbsp;&nbsp;13.2 <a href="#d5e11928">The xsl:sort Element</a><br>&nbsp;&nbsp;&nbsp;&nbsp;13.3 <a href="#d5e12548">Using Unnamed Sort Specifications</a><br>&nbsp;&nbsp;&nbsp;&nbsp;13.4 <a href="#named-sort-key">Using Named Sort Specifications</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;13.4.1 <a href="#d5e12587">Declaring a Named Sort Specification</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;13.4.2 <a href="#d5e12656">Sorting Using a Named Sort Specification</a><br>14 <a href="#grouping">Grouping</a><br>&nbsp;&nbsp;&nbsp;&nbsp;14.1 <a href="#current-group">The Current Group</a><br>&nbsp;&nbsp;&nbsp;&nbsp;14.2 <a href="#d5e12772">The xsl:for-each-group Element</a><br>&nbsp;&nbsp;&nbsp;&nbsp;14.3 <a href="#d5e13310">Examples of Grouping</a><br>15 <a href="#regular-expressions">Regular Expressions</a><br>&nbsp;&nbsp;&nbsp;&nbsp;15.1 <a href="#d5e13662">Examples of Regular Expression Matching</a><br>16 <a href="#add-func">Additional Functions</a><br>&nbsp;&nbsp;&nbsp;&nbsp;16.1 <a href="#document">Multiple Source Documents</a><br>&nbsp;&nbsp;&nbsp;&nbsp;16.2 <a href="#unparsed-text">Reading Text Files</a><br>&nbsp;&nbsp;&nbsp;&nbsp;16.3 <a href="#key">Keys</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16.3.1 <a href="#d5e13929">The xsl:key Declaration</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16.3.2 <a href="#keys">The key Function</a><br>&nbsp;&nbsp;&nbsp;&nbsp;16.4 <a href="#format-number">Number Formatting</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16.4.1 <a href="#d5e14618">Defining a Decimal Format</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16.4.2 <a href="#d5e14870">Processing the Picture String</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16.4.3 <a href="#d5e14953">Analysing the Picture String</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16.4.4 <a href="#d5e15538">Formatting the Number</a><br>&nbsp;&nbsp;&nbsp;&nbsp;16.5 <a href="#misc-func">Miscellaneous Additional Functions</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16.5.1 <a href="#current-function">current</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16.5.2 <a href="#unparsed-entity-uri">unparsed-entity-uri</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16.5.3 <a href="#unparsed-entity-public-id">unparsed-entity-public-id</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16.5.4 <a href="#generate-id">generate-id</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16.5.5 <a href="#system-property">system-property</a><br>17 <a href="#message">Messages</a><br>18 <a href="#extension">Extensibility and Fallback</a><br>&nbsp;&nbsp;&nbsp;&nbsp;18.1 <a href="#extension-functions">Extension Functions</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;18.1.1 <a href="#d5e16287">Testing Availability of Functions</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;18.1.2 <a href="#d5e16406">Calling Extension Functions</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;18.1.3 <a href="#external-objects">External Objects</a><br>&nbsp;&nbsp;&nbsp;&nbsp;18.2 <a href="#extension-instruction">Extension Instructions</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;18.2.1 <a href="#d5e16524">Designating an Extension Namespace</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;18.2.2 <a href="#d5e16555">Testing Availability of Instructions</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;18.2.3 <a href="#fallback">Fallback</a><br>19 <a href="#result-trees">Result Trees</a><br>&nbsp;&nbsp;&nbsp;&nbsp;19.1 <a href="#secondary-result-trees">
					Secondary Result Trees</a><br>20 <a href="#serialization">Serialization</a><br>&nbsp;&nbsp;&nbsp;&nbsp;20.1 <a href="#xml-output">XML Output Method</a><br>&nbsp;&nbsp;&nbsp;&nbsp;20.2 <a href="#xhtml-output">XHTML Output Method</a><br>&nbsp;&nbsp;&nbsp;&nbsp;20.3 <a href="#d5e18332">HTML Output Method</a><br>&nbsp;&nbsp;&nbsp;&nbsp;20.4 <a href="#d5e18701">Text Output Method</a><br>&nbsp;&nbsp;&nbsp;&nbsp;20.5 <a href="#disable-output-escaping">Disabling Output Escaping</a><br>21 <a href="#conformance">Conformance</a><br></p>
<h3><a name="appendices" id="appendices"></a>Appendices</h3><p class="toc">A <a href="#references">References</a><br>&nbsp;&nbsp;&nbsp;&nbsp;A.1 <a href="#d5e18986">Normative References</a><br>&nbsp;&nbsp;&nbsp;&nbsp;A.2 <a href="#d5e19079">Other References</a><br>B <a href="#glossary">Glossary</a> (Non-Normative)<br>C <a href="#element-syntax-summary">Element Syntax Summary</a> (Non-Normative)<br>D <a href="#error-summary">Summary of Error Conditions</a> (Non-Normative)<br>E <a href="#implementation-defined-features">Checklist of Implementation-Defined Features</a> (Non-Normative)<br>F <a href="#schema-for-xslt">Schema for XSLT Stylesheets</a> (Non-Normative)<br>G <a href="#lexical-representation">Representation of Lexical XML Constructs</a> (Non-Normative)<br>H <a href="#d5e19410">Acknowledgements</a> (Non-Normative)<br>I <a href="#d5e19607">Checklist of Requirements</a> (Non-Normative)<br>J <a href="#issues-list">Summary of Issues</a> (Non-Normative)<br>&nbsp;&nbsp;&nbsp;&nbsp;J.1 <a href="#d5e20297">Open Issues</a><br>&nbsp;&nbsp;&nbsp;&nbsp;J.2 <a href="#d5e20301">Decided Issues</a><br>&nbsp;&nbsp;&nbsp;&nbsp;J.3 <a href="#d5e20307">Closed Issues</a><br>K <a href="#changes">Changes from XSLT 1.0</a> (Non-Normative)<br>&nbsp;&nbsp;&nbsp;&nbsp;K.1 <a href="#incompatibilities">Incompatible Changes</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;K.1.1 <a href="#d5e20323">XSLT 2.0 Backwards Compatibility</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;K.1.2 <a href="#d5e20410">XPath 2.0 Backwards Compatibility</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;K.1.3 <a href="#d5e20421">Compatibility in the Presence of a Schema</a><br>&nbsp;&nbsp;&nbsp;&nbsp;K.2 <a href="#d5e20436">Changes since XSLT 1.0</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;K.2.1 <a href="#d5e20450">Pervasive changes</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;K.2.2 <a href="#d5e20508">Major Features</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;K.2.3 <a href="#d5e20602">Minor Changes</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;K.2.4 <a href="#changes-in-this-draft">Changes since the August 2002 draft</a><br></p></div><hr><div class="body"><div class="div1">
<h2><a name="introduction" id="introduction"></a>1 Introduction</h2><div class="div2">
<h3><a name="d5e150" id="d5e150"></a>1.1 What is XSLT?</h3><p>This specification defines the syntax and semantics of the XSLT 2.0
language.  <a name="dt-stylesheet" id="dt-stylesheet" title="stylesheet"></a>A 
transformation in the XSLT language is expressed 
in the form of a <b>stylesheet</b>, whose syntax is 
well-formed XML <a href="#XML">[XML]</a> conforming to the
Namespaces in XML Recommendation <a href="#XMLNAMES">[XML Names]</a>.
A stylesheet generally includes elements that are defined by XSLT
 as well as elements that are not defined by XSLT.  XSLT-defined elements are
 distinguished by use of the  namespace <code>http://www.w3.org/1999/XSL/Transform</code> 
(see <a href="#xslt-namespace"><b>3.1 XSLT Namespace</b></a>),
 which is referred to in this specification as the <a title="XSLT namespace" href="#dt-xslt-namespace">XSLT
namespace</a>. Thus this specification is a definition of
the syntax and semantics of the XSLT namespace.</p><p>The term <em>stylesheet</em> reflects
the fact that one of the important roles of XSLT is to add styling information
to an XML source document, by transforming it into a document consisting of XSL 
formatting objects (see <a href="#XSLFO">[XSL Formatting Objects]</a>),
or into another presentation-oriented format such as HTML, XHTML, or SVG.
However, XSLT is used for a wide range of XML-to-XML transformation tasks,
not exclusively for formatting and presentation applications.</p><p>A transformation expressed in XSLT describes rules for transforming
one or more source trees into 
one or more result trees.  The transformation is achieved by
a set of <a title="template rule" href="#dt-template-rule">template rules</a>. 
A template rule associates a <a title="pattern" href="#dt-pattern">pattern</a>, which
matches nodes in the source document, with a <a title="content constructor" href="#dt-content-constructor">content constructor</a>,
which can be evaluated to produce part of a result tree.
The structure of the result trees can be completely different
from the structure of the source trees.
 In constructing a result
tree, nodes from the source trees can be filtered and reordered, and
arbitrary structure can be added. This mechanism allows a stylesheet 
to be applicable to a wide class of
documents that have similar source tree structures.</p><p>
					<a name="dt-principal-stylesheet-module" id="dt-principal-stylesheet-module" title="principal stylesheet module"></a>A 
stylesheet may consist of several stylesheet modules,
contained in different XML documents. 
For a given transformation, one of these functions as the
<b>principal stylesheet module</b>. The complete stylesheet is
assembled by finding the stylesheet modules referenced 
directly or indirectly from the
principal stylesheet module using <a href="#element-include"><code>xsl:include</code></a> and
<a href="#element-import"><code>xsl:import</code></a> elements: see <a href="#include"><b>3.8.1 Stylesheet Inclusion</b></a> and
<a href="#import"><b>3.8.2 Stylesheet Import</b></a>
					.</p></div><div class="div2">
<h3><a name="d5e215" id="d5e215"></a>1.2 What's new in XSLT 2.0?</h3><p>XSLT 1.0 was published in November 1999, and version 2.0 represents a significant increase
in the capability of the language. A detailed list of changes is included in <a href="#changes"><b>K Changes from XSLT 1.0</b></a>.
XSLT 2.0 has been developed in parallel with XPath 2.0 (see <a href="#XPATH20">[XPath 2.0]</a>), so the changes
to XPath must be considered alongside the changes to XSLT.</p></div></div><div class="div1">
<h2><a name="concepts" id="concepts"></a>2 Concepts</h2><div class="div2">
<h3><a name="d5e227" id="d5e227"></a>2.1 Terminology</h3><p>For a full glossary of terms, see <a href="#glossary"><b>B Glossary</b></a>.</p><p>
					<a name="dt-processor" id="dt-processor" title="processor"></a>The software responsible
 for transforming source trees into
a result trees is referred to as the <b>processor</b>. This is sometimes expanded
to <em>XSLT processor</em> to avoid any confusion with
other processors, for example an XML processor.
					<a name="dt-implementation" id="dt-implementation" title="implementation"></a>A specific product that performs the functions of
 an <a title="processor" href="#dt-processor">XSLT processor</a> is referred to as
 an <b>implementation</b>
					.</p><blockquote><table width="90%"><tr><td width="10%" align="left" valign="top"><b>Note:</b></td><td align="left" valign="top"><p>The precise meanings of the terms <b>source tree</b> and
 <b>result tree</b>, as used in this
specification, depend on the context. In the context of the stylesheet
as a whole, the source trees are the trees provided as the initial input to the transformation,
together with any trees supplied as stylesheet parameters and any trees accessed using
the <u>fn:document</u> or <u>fn:collection</u> functions; while the result
trees are the trees created by an explicit <a href="#element-result-document"><code>xsl:result-document</code></a> instruction
as well as the implicit result tree created in the absence of an <a href="#element-result-document"><code>xsl:result-document</code></a> instruction.
In the context of an individual instruction in the stylesheet, the term <b>source tree</b>
also includes any <a title="" href="#dt-temporary-tree">temporary tree</a> that the instruction
is using for input, and the term <b>result tree</b>
includes any <a title="" href="#dt-temporary-tree">temporary tree</a> that the instruction
is using for output.</p></td></tr></table></blockquote><p>In this specification the words <b>must</b>, <b>must not</b>,
<b>should</b>, <b>should not</b>, <b>may</b>,
<b>required</b>, and <b>recommended</b> 
 are to be interpreted as described in <a href="#RFC2119">[RFC2119]</a>.</p><p>
					<a name="dt-implementation-defined" id="dt-implementation-defined" title="implementation-defined"></a>In this
specification, the term <b>implementation-defined</b> refers to a feature where the
implementation is allowed some flexibility, and where the choices made by the
implementation should be described in the vendor's documentation.
				</p><p>
					<a name="dt-implementation-dependent" id="dt-implementation-dependent" title="implementation-dependent"></a>The 
term <b>implementation-dependent</b> refers to a feature where the
behavior may vary from one implementation to another, and where the vendor is not expected to
provide a full specification of the behavior. (This might apply, for example, to
limits on the size of source documents that can be transformed.)</p><p>In all cases where this specification leaves the behavior implementation-defined
or implementation-dependent, the implementation has the option of providing mechanisms that allow
the user to influence the behavior.</p><p>Paragraphs labelled as <b>Note</b>s or described as <b>examples</b> are
non-normative.</p></div><div class="div2">
<h3><a name="notation" id="notation"></a>2.2 Notation</h3><p>In this document the specification of each XSLT-defined element type is preceded by
a summary of its syntax in the form of a model for elements of that
element type.  A full list of all these specifications can be found in
 <a href="#element-syntax-summary"><b>C Element Syntax Summary</b></a>.
The meaning of syntax summary notation is as follows:</p><ul><li><p>An attribute is required if and only if its name is in
bold.</p></li><li><p>The string that occurs in the place of an attribute value
specifies the allowed values of the attribute.  If this is surrounded
by curly braces, then the attribute value is treated as an
 <a title="attribute value template" href="#dt-attribute-value-template">attribute value template</a>,
and the string occurring within curly braces specifies the allowed
values of the result of evaluating the attribute value template.
Alternative allowed values are separated by <code>|</code>.  A quoted
string indicates a value equal to that specific string. An unquoted,
italicized name specifies a particular type of value.</p></li><li><p>Unless the element is required to be empty, the model element
contains a comment specifying the allowed content.  The allowed
content is specified in a similar way to an element type declaration
in XML; <em>content constructor</em> means that any mixture of text nodes,
<a title="literal result element" href="#dt-literal-result-element">literal result elements</a>, 
<a title="extension instruction" href="#dt-extension-instruction">extension instructions</a>, and XSLT elements from
the <a title="instruction" href="#dt-instruction">instruction</a> category is allowed;
<em>other-declarations</em> means that any mixture of XSLT
elements from the <a title="declaration" href="#dt-declaration">declaration</a> category, 
other than <a href="#element-import"><code>xsl:import</code></a>, is
allowed, together with <a title="user-defined data element" href="#dt-data-element">user-defined data elements</a>.</p></li><li><p>The element is prefaced by comments indicating if it belongs
to the <code>instruction</code> category or
<code>declaration</code> category or both.  The category of an
element only affects whether it is allowed in the content of elements
that allow a <a title="content constructor" href="#dt-content-constructor">content constructor</a> or
<em>other-declarations</em>.</p></li></ul><div class="example"><p>The following example illustrates the notation.</p><p class="element-syntax"><a name="element-example-element"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:example-element<br>&nbsp;&nbsp;<b>select</b> = <var>sequence-expression</var><br>&nbsp;&nbsp;debug = { "yes" | "no" }&gt;<br>&nbsp;&nbsp;&lt;!-- Content: ((<a href="#element-variable">xsl:variable</a> | <a href="#element-param">xsl:param</a>)*, <a href="#element-result">xsl:result</a>) --&gt;<br>&lt;/xsl:example-element&gt;</code></p><p>This example defines a (non-existent) element <code>xsl:example-element</code>. The element is classified as
an instruction. It takes a mandatory <code>select</code> attribute, whose value is an XPath <a title="expression" href="#dt-expression">expression</a>, and
an optional <code>debug</code> attribute, whose value must be either <code>yes</code> or <code>no</code>; the curly 
braces indicate that the value can be defined as an <a title="attribute value template" href="#dt-attribute-value-template">attribute value
template</a>, allowing a value such as <code>debug="{$debug}"</code>, where the <a title="variable" href="#dt-variable">variable</a> <code>debug</code>
is evaluated to yield <code>"yes"</code> or <code>"no"</code> at run-time.</p><p>The content of an <code>xsl:example-element</code> instruction is defined to be a sequence of zero or more
<a href="#element-variable"><code>xsl:variable</code></a> and <a href="#element-param"><code>xsl:param</code></a> elements, followed by an <a href="#element-result"><code>xsl:result</code></a>
element.</p></div><p>
					<a name="d5e477"><small>[ERR001] </small></a>A <a title="static error" href="#dt-static-error">static error</a> is signaled
 if an XSLT-defined element is used in a context
  where it is not permitted, if a required attribute is omitted,
  or if the content of the element does not correspond to the
  content that is allowed for the element.
					<a name="d5e483"><small>[ERR002] </small></a>It is a <a title="static error" href="#dt-static-error">static error</a>
if an attribute (other than an attribute written using curly braces in 
a position where an
 <a title="attribute value template" href="#dt-attribute-value-template">attribute value template</a> is permitted) contains a value 
that is not one of the permitted values for that attribute.
					<a name="d5e492"><small>[ERR003] </small></a>It is a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a>
if the <a title="effective value" href="#dt-effective-value">effective value</a> of an attribute written
 using curly braces, in 
a position where an <a title="attribute value template" href="#dt-attribute-value-template">attribute value template</a> is
 permitted, is a value 
that is not one of the permitted values for that attribute.
				</p><p>Special rules apply if the construct appears in part of
the stylesheet that is processed with
 <a title="forwards-compatible behavior" href="#dt-forwards-compatible-behavior">forwards-compatible behavior</a>: see <a href="#forwards"><b>3.7 Forwards-Compatible Processing</b></a>.</p><blockquote><table width="100%"><tr><td width="10%" align="left" valign="top"><b>Ed. Note:</b></td><td align="left" valign="top">This working draft includes an XML Schema for XSLT stylesheet modules: 
see <a href="#schema-for-xslt"><b>F Schema for XSLT Stylesheets</b></a>. However, it has been decided to retain the syntax summaries in their
present form as these are thought to be easier to read.</td></tr></table></blockquote><p>XSLT defines a set of standard functions which are additional to those defined
				in <a href="#FANDO">[Functions and Operators]</a>. The signatures of these functions are described using the
				same notation as used in <a href="#FANDO">[Functions and Operators]</a>.</p></div><div class="div2">
<h3><a name="initiating" id="initiating"></a>2.3 Initiating a Transformation</h3><p>This document does not specify any application programming interfaces or other
interfaces for initiating a transformation. This section, however, describes the information that must be
supplied when a transformation is initiated.</p>
					<p>Implementations may allow a transformation to run as two or more phases, for example parsing, compilation and
execution. Such a distinction is outside the scope of this specification, which treats transformation as a single
process controlled using a set of <a title="stylesheet module" href="#dt-stylesheet-module">stylesheet modules</a>, supplied in the form of
XML documents.</p>
					<p>The following information is supplied to execute a transformation:</p>
					<ul><li><p>An identification of the <a title="stylesheet module" href="#dt-stylesheet-module">stylesheet module</a> that is
 to act as the <a title="principal stylesheet module" href="#dt-principal-stylesheet-module">principal stylesheet module</a> for the transformation.
 The complete stylesheet is assembled by expanding the <a href="#element-import"><code>xsl:import</code></a> and <a href="#element-include"><code>xsl:include</code></a>
 declarations in the principal stylesheet module, as described in <a href="#include"><b>3.8.1 Stylesheet Inclusion</b></a> and <a href="#import"><b>3.8.2 Stylesheet Import</b></a>
							</p></li><li><p>A set (possibly empty) of values for <a title="stylesheet parameter" href="#dt-stylesheet-parameter">stylesheet parameters</a>
							 (see <a href="#global-variables"><b>9.5 Global Variables and Parameters</b></a>). These
values are available for use within <a title="expression" href="#dt-expression">expressions</a> in the stylesheet.</p></li><li><p>
								<a name="dt-initial-input-sequence" id="dt-initial-input-sequence" title="initial input sequence"></a>A set of nodes
 (possibly empty) that forms the <b>initial input sequence</b>. These nodes (which will often 
be document nodes, but may in principle be any kind of node, from the same or different documents) are
available at any time during the transformation as the result of the <u>fn:input</u>
function described in <a href="#FANDO">[Functions and Operators]</a>.
							</p></li><li><p>
								<a name="dt-initial-context-node" id="dt-initial-context-node" title="initial context node"></a>A node that acts as
 the <b>initial context node</b> for the transformation. This node is accessible within the
stylesheet as the initial value of the XPath <a title="expression" href="#dt-expression">expressions</a> <code>.</code> and <code>self::node()</code>,
as described in <a href="#focus"><b>2.5 Maintaining Position: the Focus</b></a>
								. If no initial context node is supplied explicitly, then
the stylesheet is invoked with an initial context node in the form of a document node with no children.</p><blockquote><table width="90%"><tr><td width="10%" align="left" valign="top"><b>Note:</b></td><td align="left" valign="top"><p>It is not necessary for the <a title="initial context node" href="#dt-initial-context-node">initial context node</a>
 to be a member of the <a title="initial input sequence" href="#dt-initial-input-sequence">initial input sequence</a>, but in a simple
transformation of a single document, it is convenient to set both the initial input sequence and the initial context node
to the document node of the source document to be transformed.</p></td></tr></table></blockquote></li><li><p>Optionally, the name of a <a title="named template" href="#dt-named-template">named template</a> which is to
be executed as the entry point to the transformation. This template must exist within the stylesheet. If no
named template is supplied, then the transformation starts
with the template rule that best matches the initial context node, according to the rules defined in
 <a href="#conflict"><b>6.3 Conflict Resolution for Template Rules</b></a>.</p><div><blockquote><p><b><a href="#issue-named-template-entry-points">Issue 146 (named-template-entry-points)</a>: </b>The current specification says that any named template can be used as an entry
    point to the transformation. This requires the compiled form of a stylesheet to retain the
    names and the body of all templates, including those that are never referenced. This is bad
    news when a stylesheet imports a large library of general-purpose templates.</p></blockquote></div></li><li><p>
								<a name="dt-base-output-uri" id="dt-base-output-uri" title="base output URI"></a>A <b>base output URI</b>,
that is, a URI to be used as the base URI when resolving a relative URI allocated to a result tree. 
If the transformation generates multiple result
trees, then typically each one will be allocated a URI relative to this base URI.
							</p></li></ul>
					
					<p>
						<a name="d5e635"><small>[ERR004] </small></a>It is a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> if the invocation of the
stylesheet specifies a template name that does not match the
<a title="expanded-QName" href="#dt-expanded-qname">expanded-QName</a> of a named template defined in the stylesheet.
					</p>
					<div><blockquote><p><b><a href="#issue-global-variables-in-call-mode">Issue 113 (global-variables-in-call-mode)</a>: </b>It's not obvious what the context should be for evaluating global variables when a
       transformation is initiated by calling a named template. The solution adopted for the moment
       is to say that there must be an initial context node; this will be supplied as an empty document
       node if no other initial context node is forthcoming.</p></blockquote></div>
					<p>Parameters passed to the transformation by the client application are matched against 
<a title="stylesheet parameter" href="#dt-stylesheet-parameter">stylesheet parameters</a> (see <a href="#global-variables"><b>9.5 Global Variables and Parameters</b></a>), 
not against the <a title="template parameter" href="#dt-template-parameter">template parameters</a> declared within
the first template to be executed. All <a title="template parameter" href="#dt-template-parameter">template parameters</a>
 within the first template to be executed will take their default values. 
 <a name="d5e661"><small>[ERR005] </small></a>It is a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a>
 if the first template executed by the transformation defines <a title="template parameter" href="#dt-template-parameter">template parameter</a>
 that specifies <code>required="yes"</code>. The processor must signal the error.</p>
				<p>A stylesheet can process further source documents in
addition to those supplied when the transformation is invoked.
 These additional documents can be loaded using the functions
<u>fn:document</u> or <u>fn:collection</u> described in <a href="#FANDO">[Functions and Operators]</a>, or
they can be supplied as <a title="stylesheet parameter" href="#dt-stylesheet-parameter">stylesheet parameters</a>
 (see <a href="#global-variables"><b>9.5 Global Variables and Parameters</b></a>),
 or as the result of an <a title="extension function" href="#dt-extension-function">extension function</a>
 (see <a href="#extension-functions"><b>18.1 Extension Functions</b></a>
				</p></div><div class="div2">
<h3><a name="d5e709" id="d5e709"></a>2.4 Executing a Transformation</h3><p>The XSLT instructions used to control a transformation can be divided into
two groups: <em>push processing</em> instructions, which use template rules to define
the processing associated with different nodes in a source tree, and <em>pull processing</em>
instructions, which allow the selection and processing of source tree nodes to be described
together. These two groups of instructions are described in the following sections.</p><div class="div3">
<h4><a name="push-processing" id="push-processing"></a>2.4.1 Push Processing Instructions</h4><p>
						<a name="dt-template-rule" id="dt-template-rule" title="template rule"></a>A stylesheet generally contains
 a set of <b>template rules</b>. A template rule has
two parts: a <a title="pattern" href="#dt-pattern">pattern</a> which is matched against nodes in a source tree
and a <a title="content constructor" href="#dt-content-constructor">content constructor</a> which is 
evaluated to create new nodes that are written to a result
tree.
					</p><p>A <a title="template rule" href="#dt-template-rule">template rule</a> that is selected
to process a particular node in the source tree will generally write one or more nodes to the
result tree, and will frequently use the <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction to select
other nodes in the source tree (often, but not invariably, the original node's children) for processing. 
Each of these selected nodes is processed by searching the stylesheet for a matching
 <a title="template rule" href="#dt-template-rule">template rule</a>. Sometimes all the selected nodes will
 be processed by the same template rule, but in general different nodes will be processed by different
 template rules. Either way, the chosen template rules are evaluated and the process repeats itself,
 typically resulting in a recursive traversal of the source tree.</p><p>Because the <a title="template rule" href="#dt-template-rule">template rule</a> that is written to process
one node in the tree has no knowledge of which rules will be chosen to process the nodes that it selects,
push processing allows a stylesheet to be applicable to a wide class of
documents that have similar source tree structures.</p><p>Frequently, the first action of the stylesheet is to find the template rule
that matches the document node of a source tree. 
This template rule may create the document node of a new result 
tree explicitly by using the <a href="#element-result-document"><code>xsl:result-document</code></a> instruction; 
if it does not do so, the system implicitly
creates the document node of a new result tree.
The content
constructor of this template rule then creates the children of the new document node.
By the time evaluation of this content constructor is complete, these children
will typically each act as the parent of further result nodes, so a complete
tree is constructed.</p><p>In the process of finding a <a title="template rule" href="#dt-template-rule">template rule</a> to
process a particular node, more
than one template rule may have a pattern that matches the
node. However, only one template rule will be applied. The
method for deciding which template rule to apply is described
in <a href="#conflict"><b>6.3 Conflict Resolution for Template Rules</b></a>. If there is no template rule that matches the node, a built-in template rule 
is used (see <a href="#built-in-rule"><b>6.5 Built-in Template Rules</b></a>).</p><div class="example"><p>For example, suppose the source tree contains the structure below:</p><div class="exampleInner"><pre>&lt;doc&gt;
  &lt;item&gt;1&lt;/item&gt;
  &lt;item&gt;2&lt;/item&gt;
  &lt;item&gt;3&lt;/item&gt;
&lt;/doc&gt;</pre></div><p>If the context node is the <code>doc</code> element, and the <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> 
instruction is evaluated with the attribute <code>select="*"</code>, then the input sequence will 
contain the three <code>item</code> elements. Suppose the template rule that matches an <code>item</code>
element has the following form:</p><div class="exampleInner"><pre>&lt;xsl:template match="item"&gt;
&lt;li&gt;&lt;xsl:value-of select="."/&gt;&lt;/li&gt;
&lt;/xsl:template&gt;</pre></div><p>This template rule will be evaluated once for each <code>item</code> element in the input sequence, and
in each case it will return a new <code>li</code> element, which in turn will contain a single text node. The 
result of the <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction will therefore be a sequence of three
<code>li</code> elements. The following XML fragment will be generated:</p><div class="exampleInner"><pre>  &lt;li&gt;1&lt;/li&gt;
  &lt;li&gt;2&lt;/li&gt;
  &lt;li&gt;3&lt;/li&gt;</pre></div><p>This fragment will be added to the result tree at the point where the <code>doc</code> 
element was being processed.</p></div><p>Very often, the template rule that matches one element in the source tree will 
contain an <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction selecting the children of that element
as the input sequence for processing. In this situation, each child node will be processed to create
a subtree, and these subtrees will be added as children of the element produced by the parent template rule.
The structure of the result tree will then correspond directly to the structure of the source tree.</p><div class="example"><p>For example, suppose that the <code>doc</code> element in the previous example is processed using the 
template rule below:</p><div class="exampleInner"><pre>&lt;xsl:template match="doc"&gt;
&lt;ol&gt;&lt;xsl:apply-templates select="*"/&gt;&lt;/ol&gt;
&lt;/xsl:template&gt;</pre></div><p>Then the result of processing the <code>doc</code> element will be the following result tree:</p><div class="exampleInner"><pre>&lt;ol&gt;
  &lt;li&gt;1&lt;/li&gt;
  &lt;li&gt;2&lt;/li&gt;
  &lt;li&gt;3&lt;/li&gt;
&lt;/ol&gt;</pre></div></div></div><div class="div3">
<h4><a name="d5e835" id="d5e835"></a>2.4.2 Pull Processing Instructions</h4><p>A single <a title="template rule" href="#dt-template-rule">template rule</a> by itself
 has considerable power. It can create
structures of arbitrary complexity; it can pull string values out of
arbitrary locations in the source tree; and it can generate structures
that are repeated according to the occurrence of nodes in the
source tree.</p><p>A stylesheet that uses the pull processing technique
is written to navigate explicitly around the source tree, accessing data
from wherever it appears in order to construct nodes in the result tree. A number
of XSLT instructions are provided to assist pull processing: notably <a href="#element-for-each"><code>xsl:for-each</code></a>,
<a href="#element-choose"><code>xsl:choose</code></a>, <a href="#element-if"><code>xsl:if</code></a>, and <a href="#element-call-template"><code>xsl:call-template</code></a>.</p><p>For simple transformations where the structure of the
result tree is independent of the structure of the source tree, a
stylesheet can often consist of only a single literal result element,
containing a content constructor which
functions as a template for building the complete result tree.  Transformations
on XML documents that represent data with a regular and
predictable structure (for example, data extracted from a relational database)
are often of this kind. XSLT allows a simplified syntax for
such stylesheets (see <a href="#simplified-stylesheet"><b>3.5 Simplified Stylesheet Modules</b></a>).</p></div><div class="div3">
<h4><a name="result-tree-construction" id="result-tree-construction"></a>2.4.3 Result Tree Construction</h4><p>Whether the stylesheet is written to use push processing or
pull processing, nodes in the result tree are always generated using content constructors.</p><p>A <a title="content constructor" href="#dt-content-constructor">content constructor</a> is 
a sequence of instructions, which appear as
sibling nodes in the stylesheet, and which are 
evaluated with respect to a particular node in the source tree,
to create part of the result tree. A content constructor can contain elements
(called <a title="literal result element" href="#dt-literal-result-element">literal result elements</a>) and text nodes
that specify part of the result structure directly.  A content constructor can also
contain elements from the <a title="XSLT namespace" href="#dt-xslt-namespace">XSLT namespace</a>
that are <a title="instruction" href="#dt-instruction">instructions</a> for creating parts of the
 result tree.</p><p>
						<a name="dt-current-destination-node" id="dt-current-destination-node" title="current destination node"></a>At
any time during the processing of a stylesheet there may be a <b>current destination node</b>.
This is always either a document node or an element node. When a new node is constructed by an
instruction in the stylesheet, the current destination node becomes its parent. At the
time stylesheet execution starts, there is no current destination node. If an instruction that
constructs a node is executed at a time when there is no current destination node, then a new
result tree is first created containing a document node only. The URI of the new result tree
will be the <a title="base output URI" href="#dt-base-output-uri">base output URI</a>. The document node of the
new result tree becomes the current destination node.</p><p>When a content constructor is evaluated, each instruction in the content constructor is
evaluated to produce a sequence of zero or more nodes; the result of
the content constructor as a whole is a sequence of nodes formed by concatenating the
results of each of the instructions, <a title="literal result element" href="#dt-literal-result-element">literal result elements</a>, 
and text nodes that it contains,
in the order that they appear in the content constructor. The resulting 
nodes (if they are elements, text nodes, comments, or processing-instructions) are attached as children to 
the <a title="current destination node" href="#dt-current-destination-node">current destination node</a>.
The order of these children in the result tree corresponds to the stylesheet order of the instructions
that created them. During this process, adjacent
text nodes will be merged into a single text node. 
In the case of attribute or namespace nodes, the new nodes become attributes or namespaces of the current
destination node.

						</p><p>Some XSLT instructions
 (including <a href="#element-variable"><code>xsl:variable</code></a> and <a href="#element-result-document"><code>xsl:result-document</code></a>) create a new document node,
 which becomes the <a title="current destination node" href="#dt-current-destination-node">current destination node</a>
 for the nodes created by the content constructor that they contain.
					</p><p>
						<a name="dt-instruction" id="dt-instruction" title="instruction"></a>The elements occurring within a content
constructor are classified as being either <a title="literal result element" href="#dt-literal-result-element">literal result elements</a>
or instructions. If the element is in the XSLT namespace,
or in a namespace designated as an <a title="extension namespace" href="#dt-extension-namespace">extension
namespace</a>, then it is an <b>instruction</b>. Otherwise, it is a literal
result element.
					</p><p>Instructions that select nodes from a source document, or that
derive information from these nodes for inclusion in the result document, always access
the source tree by means of an <a title="expression" href="#dt-expression">expression</a> in the XPath
language, described in <a href="#XPATH20">[XPath 2.0]</a>. A stylesheet written to use XSLT 2.0 will
contain expressions whose syntax and semantics are defined by XPath 2.0 (but see also
<a href="#backwards"><b>3.6 Backwards-Compatible Processing</b></a> and <a href="#forwards"><b>3.7 Forwards-Compatible Processing</b></a>).</p></div></div><div class="div2">
<h3><a name="focus" id="focus"></a>2.5 Maintaining Position: the Focus</h3><p>
					<a name="dt-focus" id="dt-focus" title="focus"></a>When a
 <a title="content constructor" href="#dt-content-constructor">content constructor</a> is
 evaluated, the <a title="processor" href="#dt-processor">processor</a> keeps track of which 
 nodes are being processed 
 by means of a set of implicit variables referred to collectively as the
  <b>focus</b>.
 More specifically, the focus consists of the following three values:</p><ul><li><p>
							<a name="dt-context-item" id="dt-context-item" title="context item"></a>The <b>context item</b> is the item currently
 being processed. An item (see <a href="#DATAMODEL">[Data Model]</a>) is either an atomic value (such as an
 integer, date, or string), or a node. 
								The context item is initially set to the
  <a title="initial context node" href="#dt-initial-context-node">initial context node</a>
  supplied when the transformation is invoked (see <a href="#initiating"><b>2.3 Initiating a Transformation</b></a>).
 It changes
 whenever instructions such as <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> and <a href="#element-for-each"><code>xsl:for-each</code></a>
 are used to process a sequence of items; each item in such a sequence becomes the context item
 while that item is being processed. The context item is returned by the XPath 
 <a title="expression" href="#dt-expression">expression</a> <code>.</code> (dot).</p></li><li><p>
							<a name="dt-context-position" id="dt-context-position" title="context position"></a>The <b>context position</b> is the position of
the context item within the sequence of items currently being processed. It changes whenever the
context item changes. When an instruction such as <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> or
 <a href="#element-for-each"><code>xsl:for-each</code></a> is used to process
a sequence of items, the first item in the sequence is processed with a context position of 1, the
second item with a context position of 2, and so on. The context position is returned
by the XPath <a title="expression" href="#dt-expression">expression</a> <code>fn:position()</code>.</p></li><li><p>
							<a name="dt-context-size" id="dt-context-size" title="context size"></a>The <b>context size</b> is the number of items in
the sequence of items currently being processed. It changes
 whenever instructions such as <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> and <a href="#element-for-each"><code>xsl:for-each</code></a>
 are used to process a sequence of items; during the processing of each one of those items, the
 context size is set to the count of the number of items in the sequence (or equivalently, the position
 of the last item in the sequence). The context size is returned
by the XPath <a title="expression" href="#dt-expression">expression</a> <code>fn:last()</code>.</p></li><li></li></ul><p>
					<a name="dt-context-node" id="dt-context-node" title="context node"></a>If the <a title="context item" href="#dt-context-item">context item</a>
 is a node (as distinct
from an atomic value such as an integer), then it is also referred to as the <b>context node</b>.
The context node is not an independent variable, it changes whenever the context item changes. When
the context item is an atomic value, there is no context node: its value is an empty sequence.
The context node is returned by the XPath <a title="expression" href="#dt-expression">expression</a> <code>self::node()</code>, and it is used
as the starting node for all relative path expressions.</p><p>The <a href="#function-current"><b>current</b></a> function can be used within any XPath <a title="expression" href="#dt-expression">expression</a>
to select the item that was supplied as the context item to the XPath expression by the XSLT processor;
unlike <code>.</code> this is unaffected by changes to the context item that occur within
the XPath expression. The <a href="#function-current"><b>current</b></a> function is described in
 <a href="#current-function"><b>16.5.1 current</b></a>.</p><p>On completion of an instruction which changes the <a title="focus" href="#dt-focus">focus</a>
 (such as <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> or
 <a href="#element-for-each"><code>xsl:for-each</code></a>), the focus reverts to its previous value.</p><p>When a <a title="stylesheet function" href="#dt-stylesheet-function">stylesheet function</a> is called,
the focus within the body of the function is initially undefined. <a name="d5e1129"><small>[ERR006] </small></a>When the focus is
undefined, evaluation of any <a title="expression" href="#dt-expression">expression</a> that references the context item, context position, or context size results
in a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a>. The processor must signal the
error.
					
				</p><p>The description above gives an outline of the way the
 <a title="focus" href="#dt-focus">focus</a> works. Detailed rules for the effect
of each instruction are given separately with the description of that instruction. In the absence
of specific rules, an instruction uses the same focus as its parent instruction.</p><p>Sometimes the focus is based on a single node. 
<a name="dt-singleton-focus" id="dt-singleton-focus" title="singleton focus"></a>A <b>singleton focus</b> 
based on a node <var>N</var>
has the <a title="context item" href="#dt-context-item">context item</a> (and therefore the 
<a title="context node" href="#dt-context-node">context node</a>) set to <var>N</var>, and the <a title="context position" href="#dt-context-position">context position</a>
and <a title="context size" href="#dt-context-size">context size</a> both set to 1 (one).
				</p><p>In addition to the values that make up the <a title="focus" href="#dt-focus">focus</a>,
an XSLT processor maintains a number of other internal variables that reflect aspects of the evaluation
context. These variables are fully described in the sections of the specification that maintain and use these
variables. They are:</p><ul><li><p>The <a title="current destination node" href="#dt-current-destination-node">current destination node</a>,
 which is the document or element node to which newly constructed nodes will be added as child nodes,
 attribute nodes, or namespace nodes: see <a href="#result-tree-construction"><b>2.4.3 Result Tree Construction</b></a>
						</p></li><li><p>The <a title="current template rule" href="#dt-current-template-rule">current template</a>, which is the
 <a title="template rule" href="#dt-template-rule">template rule</a>
most recently invoked by an <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> or <a href="#element-apply-imports"><code>xsl:apply-imports</code></a> 
instruction: see <a href="#apply-imports"><b>6.6 Overriding Template Rules</b></a>
						</p></li><li><p>The <a title="current mode" href="#dt-current-mode">current mode</a>, which is the <a title="mode" href="#dt-mode">mode</a>
in which the current <a title="template rule" href="#dt-template-rule">template rule</a> was invoked: 
see <a href="#modes"><b>6.4 Modes</b></a>
						</p></li><li><p>The <a title="current group" href="#dt-current-group">current group</a>, which is the set of nodes currently
being processed by an <a href="#element-for-each-group"><code>xsl:for-each-group</code></a> instruction: see <a href="#current-group"><b>14.1 The Current Group</b></a>
						</p></li><li><p>The current set of captured substrings, which is maintained when a string
is matched against a regular expression using the <a href="#element-analyze-string"><code>xsl:analyze-string</code></a> instruction,
and which is accessible using the <a href="#function-regex-group"><b>regex-group</b></a> function: 
see <a href="#regular-expressions"><b>15 Regular Expressions</b></a>
						</p></li></ul><p>As with the focus, these variables are not accessible within a stylesheet function
unless they have been initialized within that function.</p></div><div class="div2">
<h3><a name="d5e1253" id="d5e1253"></a>2.6 Parsing and Serialization</h3><p>An XSLT stylesheet describes a process that
constructs a set of result trees from a set of source trees.</p><p>The stylesheet does not describe how a source tree is constructed. Frequently
an <a title="implementation" href="#dt-implementation">implementation</a> will operate in conjunction
 with an XML parser (or more strictly, in the
terminology of <a href="#XML">[XML]</a>, an <em>XML processor</em>), to build the source
tree from an input XML document. An implementation may also provide an application programming
interface allowing the tree to be constructed directly, or allowing it to be supplied in the form of a
DOM Document object (see <a href="#DOM2">[DOM2]</a>). This is outside the scope of this specification.
Users should be aware, however, that since the input to the transformation is a tree conforming
to the XPath data model as described in <a href="#DATAMODEL">[Data Model]</a>, constructs that might exist in the
original XML document, or in the DOM, but which are not within the scope of the data model,
cannot be processed by the stylesheet and cannot be guaranteed to
remain unchanged in the transformation output. Such constructs include CDATA section boundaries,
the use of entity references, and the DOCTYPE declaration and internal DTD subset.</p><p>
					<a name="dt-serialization" id="dt-serialization" title="serialization"></a>A frequent requirement is to
output a result tree as an XML document (or in other formats such as HTML). 
This process is referred to as
 <b>serialization</b>. 
 Like parsing, serialization is not part of the transformation
 process, and it is not required that an XSLT processor should be able to perform
 serialization. However, for pragmatic reasons, this specification describes a declaration
 (the <a href="#element-output"><code>xsl:output</code></a> element, see <a href="#serialization"><b>20 Serialization</b></a>) which allows a
 stylesheet to specify the desired properties of a serialized output file. Implementations
 that do not serialize result trees are allowed to ignore this declaration.</p><p>Because it is a common requirement to perform a transformation on a document while
 retaining lexical characteristics such as CDATA section boundaries,
 entity references, and the like, a non-normative appendix to this specification 
 (see <a href="#lexical-representation"><b>G Representation of Lexical XML Constructs</b></a>) describes a way in which
 these constructs can be represented within the data model by means of elements in a special namespace.
 If such a representation is chosen, the tree is transformed in the same way as any other tree.
 The process of constructing such a tree is something that happens before XSLT transformation 
 starts, and the process of interpreting such a tree and reconstituting the lexical representation
 is part of the serialization process. Neither of these processes is properly within the scope of XSLT
 transformation, and therefore, this specification places no requirement on an XSLT
 processor to support this representation of lexical properties.</p></div><div class="div2">
<h3><a name="extensibility" id="extensibility"></a>2.7 Extensibility</h3><p>XSLT provides two hooks for extending the language,
one hook for extending the set of
 <a title="instruction" href="#dt-instruction">instruction</a> elements used in
<a title="content constructor" href="#dt-content-constructor">content constructors</a> and 
one hook for extending the set of functions used in
XPath <a title="expression" href="#dt-expression">expressions</a>. These hooks are both based on XML namespaces:
see <a href="#extension"><b>18 Extensibility and Fallback</b></a> for further details. 
Extension instructions and
extension functions defined according to these rules may be provided by
the implementor of the XSLT processor, and the implementor may also provide
facilities to allow users to create further extension instructions and
extension functions. 
This specification defines how extension instructions and extension functions
are invoked, but the facilities for creating new extension instructions and extension
functions are <a title="implementation-defined" href="#dt-implementation-defined">implementation-defined</a>.</p></div><div class="div2">
<h3><a name="d5e1319" id="d5e1319"></a>2.8 Stylesheets and Schemas</h3><p>An XSLT stylesheet can make use of information from XML Schemas, as defined in
<a href="#XMLSCHEMA">[XML Schema]</a>. An XSLT transformation can take place in the absence of a
schema (and, indeed, in the absence of a DTD), but where the source document has
undergone schema validity assessment, the XSLT processor has access to the type
information associated with individual nodes, not merely to the raw text.</p><blockquote><table width="100%"><tr><td width="10%" align="left" valign="top"><b>Ed. Note:</b></td><td align="left" valign="top">The XSL Working Group intends to define a conformance level for
XSLT processors in which schema processing, and handling of user-defined types, is
not a requirement. The precise rules for such a processor (for example, the question of whether
it should ignore type-related constructs in the stylesheet or should signal them as an error) 
have yet to be defined.</td></tr></table></blockquote><p>There are places within a stylesheet, 
				and within XPath <a title="expression" href="#dt-expression">expressions</a> and patterns with
a stylesheet, where the names of schema-defined elements, attributes, and named types
 may appear. For example, it is
possible to declare the types expected for the parameters of a function. The element,
attribute, and type names that
appear in such contexts must either be built-in schema types (for example <code>xs:string</code> or
<code>xs:integer</code>), or they must be user-defined types that are made accessible to the
XSLT processor by means of an <a href="#element-import-schema"><code>xsl:import-schema</code></a> declaration: 
see <a href="#import-schema"><b>3.10 Importing Schema Components</b></a>.</p><p>It is only necessary to import a schema explicitly
if its type definitions are mentioned statically in the stylesheet; it is not
necessary to import a schema merely because the stylesheet is used to process a
source document that has been assessed against that schema. It is possible to make use of
the information resulting from schema assessment (for example, the fact that a particular
attribute holds a date) even if no schema has been imported by the stylesheet.</p><p>Further, importing
a schema does not of itself say anything about the type of the source document that the
stylesheet is expected to process. The imported type definitions can be used for temporary nodes
or for nodes on the result tree just as much as for nodes  in source documents.
It is possible to make assertions about the types of input document by means of tests within the stylesheet. 
For example:</p><div class="example"><div class="exampleInner"><pre>&lt;xsl:template match="/"&gt;
&lt;xsl:if test="not(* instance of my:invoice)"&gt;
  &lt;xsl:message terminate="yes"&gt;Source document is not an invoice&lt;/xsl:message&gt;
&lt;/xsl:if&gt;
. . .
&lt;/xsl:template&gt;</pre></div><p>This example will cause the transformation to fail with an error message if the
source document has not been successfully validated and annotated with type <code>my:invoice</code>.</p></div><div><blockquote><p><b><a href="#issue-assert-source-document-type">Issue 106 (assert-source-document-type)</a>: </b>How should a stylesheet assert the schema type of the source documents that
      it is designed to process?</p></blockquote></div><p>A stylesheet can also control the types of nodes that it constructs in a final
result tree, or in temporary trees. In the case of temporary trees, this enables the tree to be processed
in the same way as a source document that has undergone schema assessment. In the case of a final
result tree, it enables the result tree to be passed to further processes (including further XSLT transformations)
with its type information intact.</p><p>Where a stylesheet author chooses to make assertions about the types of nodes or of 
				<a title="variable" href="#dt-variable">variables</a> and <a title="parameter" href="#dt-parameter">parameters</a>,
it is possible for an XSLT processor to perform static analysis of the stylesheet (that is, analysis in the absence of any
source document). Such analysis may reveal errors that would otherwise not be discovered until the 
transformation is actually executed. An XSLT processor is not required to perform such static type-checking,
and if it does perform such checking, any errors reported are advisory only: the user must be given the option
to use the stylesheet even if static analysis has revealed type errors.</p><p>Type annotations can be created in nodes of a result tree, or of a temporary tree,
in a number of ways. Firstly, it is possible to request validation of the complete tree. Validation may
be either strict or lax, and is performed according to the rules defined in <a href="#XMLSCHEMA">[XML Schema]</a>:
if validation fails, the transformation fails, but if it succeeds, the element and attribute nodes of the
tree will be annotated with the names of the schema-defined types to which these nodes conform,
and the typed value of the nodes will be accessible using the <u>fn:data</u> function. Secondly,
it is possible to add annotations to individual element and attribute nodes as they are constructed. This
is done using the <code>type-annotation</code> attribute of the <a href="#element-element"><code>xsl:element</code></a> and <a href="#element-attribute"><code>xsl:attribute</code></a>
instructions, or the <code>xsl:type-annotation</code> attribute of a <a title="literal result element" href="#dt-literal-result-element">literal
result element</a>. This is permitted only for elements that have simple content. In addition,
type annotations may be copied from a source tree to a result tree when using the <a href="#element-copy-of"><code>xsl:copy-of</code></a>
instruction. Type annotations attached to individual nodes in this way will only be retained in the 
completed tree if the tree construction element (for example, <a href="#element-variable"><code>xsl:variable</code></a> or
<a href="#element-result-document"><code>xsl:result-document</code></a>) specifies <code>type-information="preserve"</code>.</p></div><div class="div2">
<h3><a name="errors" id="errors"></a>2.9 Error Handling</h3><p>
					<a name="dt-static-error" id="dt-static-error" title="static error"></a>An error that is detected by examining
 a stylesheet before execution starts (that is, before the source document
 and values of stylesheet parameters
 are available) is referred to as a <b>static error</b>.
 Errors classified in this specification as static errors must be signaled by all
 implementations: that is, the <a title="processor" href="#dt-processor">processor</a> must indicate that the error is
 present, and it must not use the stylesheet to produce a result tree. 
 A static error must be signaled
 even if it occurs in a part of the stylesheet that is never evaluated.</p><p>There is an exception to this rule when the stylesheet specifies
<a title="forwards-compatible behavior" href="#dt-forwards-compatible-behavior">forwards-compatible behavior</a>
 (see <a href="#forwards"><b>3.7 Forwards-Compatible Processing</b></a>).</p><p>Generally, errors in the structure of the stylesheet, or in the syntax
				 of XPath <a title="expression" href="#dt-expression">expressions</a>
contained in the stylesheet, are classified as
<a title="static error" href="#dt-static-error">static errors</a>.
Where this specification states that an element in the stylesheet must or must not appear in
 a certain position, or that it must or must not have a particular attribute, 
 or that an attribute must or must not
 have a value satisfying specified conditions,
  then any contravention of this rule is a static error unless otherwise specified.  </p><p>
					<a name="dt-dynamic-error" id="dt-dynamic-error" title="dynamic error"></a>An error that is not detected until
 a source document is being transformed is referred to as a
  <b>dynamic error</b>. In many cases, this specification allows
 dynamic errors to be signaled (by reporting
 the error condition and terminating execution), but also defines a recovery action that can 
 be taken. It is <a title="implementation-defined" href="#dt-implementation-defined">implementation-defined</a>
 whether the error is signaled or the recovery action is taken.
 If the implementation does choose to take recovery action, it must
 take the recovery action defined in this specification.</p><p>When the implementation makes the choice
between signaling a dynamic error or recovering, it is not restricted in how it makes
the choice; for example, it may provide options that can be set by the user.
When an implementation chooses to recover from a dynamic error, it is also allowed to
take other action, such as logging a warning message.</p><p>Because different implementations may optimize execution of the stylesheet in
different ways, the detection of dynamic errors is to some degree
<a title="implementation-dependent" href="#dt-implementation-dependent">implementation-dependent</a>. In 
cases where an implementation is able to produce the result tree without evaluating a 
particular construct, the implementation is never required to
evaluate that construct solely in order to determine whether doing so causes a dynamic error.
 For example, if a <a title="variable" href="#dt-variable">variable</a> is declared but never referenced,
 an implementation can choose whether or not to evaluate the variable declaration, which means that
 if evaluating the variable declaration causes a dynamic error, some implementations will signal
 this error and others will not.</p><p>There are some cases where this specification requires that a construct must
 not be evaluated: for example, the content of an <a href="#element-if"><code>xsl:if</code></a> instruction
 must not be evaluated if the test condition is false. This means that an implementation
 must not report any dynamic errors that would arise if the construct were evaluated.</p><p>An implementation may signal a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a>
 before any source document is available, but only if it can determine that the error would
 be signaled for every possible source document and every possible set of parameter values.
 For example, some <a title="" href="#circularity">circularity</a> errors fall into this
 category: see <a href="#circularity"><b>9.8 Circular Definitions</b></a>.</p><p>
					<a name="dt-type-error" id="dt-type-error" title="type errors"></a>Certain errors are classified as <b>type errors</b>.
 A type error occurs when the value supplied as input to an operation is of the wrong type
 for that operation, for example when an integer is supplied to an operation that expects
 a node. If a type error occurs in an instruction that is actually evaluated, then it must
 be reported as a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a>. An implementation
 may also, optionally, report a type error as a <a title="static error" href="#dt-static-error">static error</a>,
 even if it occurs in part of the stylesheet that is never evaluated, provided it can establish
 that execution of a particular construct would never succeed.</p><p>It is <a title="implementation-defined" href="#dt-implementation-defined">implementation-defined</a>
  whether type errors are reported statically.</p><div class="example"><p>For example, the following
  construct contains a type error, because <code>42</code> is not allowed as an operand of the
  <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction. An implementation may optionally report this as a 
  static error, even though the offending instruction will never be evaluated, and the type error would
  therefore never be reported as a dynamic error.</p><div class="exampleInner"><pre>
&lt;xsl:if test="fn:false()"&gt;
  &lt;xsl:apply-templates select="42"/&gt;
&lt;/xsl:if&gt;
</pre></div></div><p>If more than one error arises, an implementation is not required to signal any errors
 other than the first one that it detects. It is 
 <a title="implementation-dependent" href="#dt-implementation-dependent">implementation-dependent</a>
 which of the several errors is signaled. This applies both to static errors and to
 dynamic errors. An implementation is allowed to signal more than one error, but if any 
 errors have been signaled, it must not finish as if
 the transformation were successful.</p><p>When a transformation signals one or more dynamic errors, the final state of
 any persistent resources updated by the transformation is 
 <a title="implementation-dependent" href="#dt-implementation-dependent">implementation-dependent</a>. Implementations
 are not required to restore such resources to their initial state. In particular, where a transformation
 produces multiple result documents, it is possible that one or more result documents may be
 written successfully before the transformation terminates, but the application cannot rely on
 this behavior.</p><p>Everything said above about error handling applies equally to errors in evaluating XSLT
 instructions, and errors in evaluating XPath <a title="expression" href="#dt-expression">expressions</a>. 
 Static errors and dynamic errors
 may occur in both cases.</p><p>
					<a name="dt-serialization-error" id="dt-serialization-error" title="serialization error"></a>If a transformation has successfully produced
 a result tree, it is still possible that errors may occur in serializing the result tree.
 For example, it may be impossible to serialize the result tree using the encoding selected by the user.
 Such an error is referred to as a <b>serialization error</b>.
  As with other aspects of serialization,
  the handling of serialization errors is
  <a title="implementation-defined" href="#dt-implementation-defined">implementation-defined</a>:
  see <a href="#serialization"><b>20 Serialization</b></a>.</p></div></div><div class="div1">
<h2><a name="stylesheet-structure" id="stylesheet-structure"></a>3 Stylesheet Structure</h2><p>
				<a name="dt-stylesheet-module" id="dt-stylesheet-module" title="stylesheet module"></a>A 
<a title="stylesheet" href="#dt-stylesheet">stylesheet</a>
consists of one or more <b>stylesheet module</b>s, each one forming
all or part of a well-formed XML document.
				
			</p><p>A stylesheet module is either a standard stylesheet module
or a simplified stylesheet module:</p><ul><li><p>
						<a name="dt-standard-stylesheet-module" id="dt-standard-stylesheet-module" title="standard stylesheet module"></a>A
<b>standard stylesheet module</b> is an XML document, or part of an XML document,
having an <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> or <a href="#element-transform"><code>xsl:transform</code></a> element
as its outermost element (see <a href="#stylesheet-element"><b>3.4 Stylesheet Element</b></a>).
					</p></li><li><p>
						<a name="dt-simplified-stylesheet-module" id="dt-simplified-stylesheet-module" title="simplified stylesheet module"></a>A
<b>simplified stylesheet module</b> is an XML document, or part
of an XML document, whose outermost element is a <a title="literal result element" href="#dt-literal-result-element">literal result element</a>
to be copied to the result tree. This element is not itself in the XSLT namespace, but it
 must have an <code>xsl:version</code> attribute, 
 which implies that the XSLT namespace must be declared.
For further details see <a href="#simplified-stylesheet"><b>3.5 Simplified Stylesheet Modules</b></a>.
						
					</p></li></ul><p>Both forms of stylesheet module (standard and simplified) can exist either as an entire
XML document, or embedded as part of another XML document, typically a source document that is to be processed
using the stylesheet. <a name="dt-embedded-stylesheet-module" id="dt-embedded-stylesheet-module" title="embedded stylesheet module"></a>An 
<b>embedded stylesheet module</b> is a stylesheet module that is
embedded within another XML document, typically the source document
 that is being transformed.
				 (see <a href="#embedded"><b>3.9 Embedded Stylesheet Modules</b></a>).</p><div class="div2">
<h3><a name="xslt-namespace" id="xslt-namespace"></a>3.1 XSLT Namespace</h3><p>
					<a name="dt-xslt-namespace" id="dt-xslt-namespace" title="XSLT namespace"></a>The <b>XSLT namespace</b>
 has the URI <code>http://www.w3.org/1999/XSL/Transform</code>. It is used to identify
 elements, attributes, and other names that have a special meaning defined in
 this specification.
				</p><blockquote><table width="90%"><tr><td width="10%" align="left" valign="top"><b>Note:</b></td><td align="left" valign="top"><p>The <code>1999</code> in the URI indicates the year in which
the URI was allocated by the W3C.  It does not indicate the version of
XSLT being used, which is specified by attributes (see <a href="#stylesheet-element"><b>3.4 Stylesheet Element</b></a> 
and <a href="#simplified-stylesheet"><b>3.5 Simplified Stylesheet Modules</b></a>).</p></td></tr></table></blockquote><p>XSLT <a title="processor" href="#dt-processor">processors</a> must use the XML namespaces 
mechanism <a href="#XMLNAMES">[XML Names]</a> to recognize elements and attributes from this
namespace. Elements from the XSLT namespace are recognized only in the
stylesheet and not in the source document. The complete list of
XSLT-defined elements is specified in <a href="#element-syntax-summary"><b>C Element Syntax Summary</b></a>.
<a title="implementation" href="#dt-implementation">Implementations</a> must not extend the XSLT
namespace with additional elements or attributes. Instead, any
extension must be in a separate namespace.  Any namespace that is used
for additional instruction elements must be identified by means of the
<a title="extension instruction" href="#dt-extension-instruction">extension instruction</a>
 mechanism specified in <a href="#extension-instruction"><b>18.2 Extension Instructions</b></a>.</p><p>This specification uses a prefix of <code>xsl:</code> for referring
to elements in the XSLT namespace. However, XSLT stylesheets are free
to use any prefix, provided that there is a namespace declaration that
binds the prefix to the URI of the XSLT namespace.</p><p>An element from the XSLT namespace may have any attribute not from
the XSLT namespace, provided that the <a title="expanded-QName" href="#dt-expanded-qname">expanded-QName</a> (see <a href="#XPATH20">[XPath 2.0]</a>) of the
attribute has a non-null namespace URI.  The presence of such
attributes must not change the behavior of XSLT elements and functions
defined in this document or in the XPath specification,
though they may be used to
modify the behavior of <a title="extension function" href="#dt-extension-function">extension functions</a> and
 <a title="extension instruction" href="#dt-extension-instruction">extension instructions</a>.
 Thus, an implementation is always free to
ignore such attributes, and must ignore such attributes without giving
an error if it does not recognize the namespace URI. Such attributes
can provide, for example, unique identifiers, optimization hints, or
documentation. The set of namespaces that are
recognized for such attributes is
 <a title="implementation-defined" href="#dt-implementation-defined">implementation-defined</a>.</p><blockquote><table width="90%"><tr><td width="10%" align="left" valign="top"><b>Note:</b></td><td align="left" valign="top"><p>Throughout this specification, an element or attribute that is in no 
				namespace, or an <a title="expanded-QName" href="#dt-expanded-qname">expanded-QName</a> whose namespace part is an empty sequence, is
				referred to as having a <b>null namespace URI</b>.</p></td></tr></table></blockquote><div class="example"><p>For example, the following code might be used to
indicate to a particular implementation that the <a href="#element-message"><code>xsl:message</code></a>
instruction is to ask the user for confirmation before continuing with the transformation:</p><div class="exampleInner"><pre>
&lt;xsl:message
    abc:pause="yes"
    xmlns:abc="http://vendor.example.com/xslt/extensions"&gt;Phase 1 complete&lt;/xsl:message&gt;
</pre></div><p>Implementations that do not recognize the namespace <code>http://vendor.example.com/xslt/extensions</code>
will simply ignore the extra attribute, and evaluate the <a href="#element-message"><code>xsl:message</code></a> instruction in the
normal way.</p></div><p>
					<a name="d5e1712"><small>[ERR007] </small></a>It is a <a title="static error" href="#dt-static-error">static error</a> for
 an element from the XSLT namespace to have an attribute 
 whose namespace is either null 
(i.e. an attribute with an unprefixed name) or the XSLT namespace, other than attributes defined
for the element in this document.
				</p><blockquote><table width="90%"><tr><td width="10%" align="left" valign="top"><b>Note:</b></td><td align="left" valign="top"><p>The conventions used for the names of XSLT elements,
attributes and functions are that names are all lower-case, use
hyphens to separate words, and use abbreviations only if they already
appear in the syntax of a related language such as XML or
HTML. Names of types defined in XML Schema however, are regarded as single words and are capitalized 
exactly as in XML Schema. This sometimes leads to composite function names such
as <u>fn:current-dateTime</u>.</p></td></tr></table></blockquote><p>
					<a name="dt-reserved-namespace" id="dt-reserved-namespace" title="reserved namespace"></a>The
 XSLT namespace, together with certain other namespaces
recognized by an XSLT processor, are classified as <b>reserved namespaces</b> 
and may be used only as specified in this and related specifications.
 The reserved namespaces are those listed below.</p><ul><li><p>The <a title="XSLT namespace" href="#dt-xslt-namespace">XSLT namespace</a>, described in this 
section, is reserved.</p></li><li><p>
							<a name="dt-standard-function-namespace" id="dt-standard-function-namespace" title="standard function namespace"></a>The <b>standard
function namespace</b>
								<code>http://www.w3.org/2002/08/xquery-functions</code> is used for functions
in the core function library, defined in <a href="#FANDO">[Functions and Operators]</a>
							
						</p><div><blockquote><p><b><a href="#issue-fn-namespace">Issue 155 (fn-namespace)</a>: </b>We need to review how function namespaces are handled in XSLT. Should users
    be able to declare the default namespace for functions? Should user-defined functions be
    allowed to be in no namespace? What namespace should be used for functions such as
    <a href="#function-generate-id"><b>generate-id</b></a> defined in this specification?</p></blockquote></div></li><li><p>
							<a name="dt-standard-operator-namespace" id="dt-standard-operator-namespace" title="standard operator namespace"></a>The <b>standard
operator namespace</b>
								<code>http://www.w3.org/2002/08/xquery-operators</code> is used for functions
that underpin XPath operators, defined in <a href="#FANDO">[Functions and Operators]</a>
							
						</p></li><li><p><a name="xml-namespace" id="xml-namespace" title="XML namespace"></a>The <b>XML namespace</b>, defined
in <a href="#XMLNAMES">[XML Names]</a> as <code>http://www.w3.org/XML/1998/namespace</code>,
 is used for attributes such as <code>xml:lang</code> and <code>xml:space</code></p></li><li><p>
							<a name="dt-schema-namespace" id="dt-schema-namespace" title="schema namespace"></a>The <b>schema
namespace</b>
								<code>http://www.w3.org/2001/XMLSchema</code> is used 
as defined in <a href="#XMLSCHEMA">[XML Schema]</a>
							. In a stylesheet this namespace may be used to refer
to built-in schema datatypes and to the constructor functions associated with those datatypes.</p></li><li><p>
							<a name="dt-schema-datatypes-namespace" id="dt-schema-datatypes-namespace" title="schema datatypes namespace"></a>The <b>schema
datatypes namespace</b>
								<code>http://www.w3.org/2001/XMLSchema-datatypes</code> is used  
as defined in <a href="#XMLSCHEMA">[XML Schema]</a>
							. In a stylesheet this namespace may be used to refer
to built-in schema datatypes and to the constructor functions associated with those datatypes: in these
respects it is equivalent to the <a title="schema namespace" href="#dt-schema-namespace">schema namespace</a>
						</p></li><li><p>
							<a name="dt-schema-instance-namespace" id="dt-schema-instance-namespace" title="schema instance namespace"></a>The <b>schema
instance namespace</b>
								<code>http://www.w3.org/2001/XMLSchema-instance</code> is used 
as defined in <a href="#XMLSCHEMA">[XML Schema]</a>
							. Attributes in this namespace, if they appear
in a stylesheet, are treated by the XSLT processor in the same way as any other attributes.</p></li></ul><p>Reserved namespaces may be used without restriction to refer to the names of
 elements and attributes in source documents and result documents. As far as the XSLT processor is concerned,
  reserved namespaces other than the XSLT namespace may be used without restriction in the names of
   <a title="literal result element" href="#dt-literal-result-element">literal result elements</a> and
 <a title="user-defined data element" href="#dt-data-element">user-defined data elements</a>, 
 and in the names of attributes of literal result elements or of XSLT instructions: 
 but other processors may impose restrictions or attach special meaning to them. Reserved namespaces must
 not be used, however, in the names of stylesheet-defined objects such as 
 <a title="variable" href="#dt-variable">variables</a> and <a title="stylesheet function" href="#dt-stylesheet-function">stylesheet functions</a>.</p><p>
					<a name="d5e1851"><small>[ERR008] </small></a>It is a <a title="static error" href="#dt-static-error">static error</a>
 to use a <a title="reserved namespace" href="#dt-reserved-namespace">reserved namespace</a> in the name of 
 a <a title="named template" href="#dt-named-template">named template</a>,
 a <a title="mode" href="#dt-mode">mode</a>,
 an <a title="attribute set" href="#dt-attribute-set">attribute set</a>, 
 a <a title="key" href="#dt-key">key</a>,
a named <a title="sort specification" href="#dt-sort-specification">sort specification</a>,
a <a title="decimal-format" href="#dt-decimal-format">decimal-format</a>,
 a <a title="variable" href="#dt-variable">variable</a> or <a title="parameter" href="#dt-parameter">parameter</a>,
a <a title="stylesheet function" href="#dt-stylesheet-function">stylesheet function</a>, or a
named <a title="output definition" href="#dt-output-definition">output definition</a>.
				</p><p>Implementations may reserve additional namespaces for use by the implementation,
provided they follow accepted practice to avoid naming collisions. The set of such namespaces is
<a title="implementation-defined" href="#dt-implementation-defined">implementation-defined</a>.</p><p>Future versions of this specification may reserve additional namespaces starting with
<code>http://www.w3.org/</code>.</p></div><div class="div2">
<h3><a name="d5e1902" id="d5e1902"></a>3.2 XSLT Media Type</h3><div><blockquote><p><b><a href="#issue-xslt-media-type">Issue 138 (xslt-media-type)</a>: </b>We may need to define an XSLT media type after all: see the TAG decision at
    <a href="http://www.w3.org/2001/tag/2002/0129-mime">http://www.w3.org/2001/tag/2002/0129-mime</a></p></blockquote></div></div><div class="div2">
<h3><a name="standard-attributes" id="standard-attributes"></a>3.3 Standard Attributes</h3><p>
					<a name="dt-standard-attributes" id="dt-standard-attributes" title="standard attributes"></a>There are a number of 
<b>standard attributes</b> that may appear on any XSLT element: specifically
<code>version</code>, 
						<code>exclude-result-prefixes</code>, 
<code>extension-element-prefixes</code>, and
<code>default-xpath-namespace</code>.
				</p><p>These attributes may also appear on a
<a title="literal result element" href="#dt-literal-result-element">literal result element</a>,
but in this case, to distinguish them from user-defined attributes, the
names of the attributes are in the <a title="XSLT namespace" href="#dt-xslt-namespace">XSLT namespace</a>. 
They are thus typically
written as <code>xsl:version</code>, <code>xsl:exclude-result-prefixes</code>, 

					<code>xsl:extension-element-prefixes</code>, or
<code>xsl:default-xpath-namespace</code>.</p><p>It is recommended that these attributes should also be permitted on
<a title="extension instruction" href="#dt-extension-instruction">extension instructions</a>, but
this is at the discretion of the implementor of each extension instruction. They 
may also be permitted on <a title="user-defined data element" href="#dt-data-element">user-defined data elements</a>, 
though they will only have any useful effect in the case of data elements that are designed to
behave like XSLT declarations or instructions.</p><p>In the following descriptions, these attributes are referred to
generically as <code>[xsl:]version</code>, and so on.</p><p>These attributes all affect the element they appear on, and any descendant
elements of the element they appear on, together with attributes of those
descendant elements. The
two forms with and without the XSLT namespace have the same effect; 
the XSLT namespace is used for the attribute if and only if
its parent element is <em>not</em> in the XSLT namespace.</p><p>In the case of <code>[xsl:]version</code> and
<code>[xsl:]default-xpath-namespace</code> the value
can be overridden by a different value for the
same attribute appearing on a descendant element. The effective value of the
attribute for a particular stylesheet element is determined by the innermost
containing element on which the attribute appears.</p><p>In the case of <code>[xsl:]exclude-result-prefixes</code>,
 and
<code>[xsl:]extension-element-prefixes</code> the values are cumulative. For these
attributes, the value may be given as
 a whitespace-separated list of namespace prefixes, and the
effective value for an element is the combined set of 
namespace URIs designated by the prefixes that appear in this
attribute for that element and any of its ancestor elements. Again, the
two forms with and without the XSLT namespace are equivalent.</p><p>Because these attributes may appear on any XSLT element, they are not listed
in the syntax summary of each individual element. Instead they are listed and
described in the description of the <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> and 
<a href="#element-transform"><code>xsl:transform</code></a> elements only.
This reflects the fact that these attributes are often used on the 
<a href="#element-stylesheet"><code>xsl:stylesheet</code></a> element, in which case they apply to the entire
<a title="stylesheet module" href="#dt-stylesheet-module">stylesheet module</a>.</p><p>Note that the effect of these attributes does <em>not</em> extend to
<a title="stylesheet module" href="#dt-stylesheet-module">stylesheet modules</a> referenced
by <a href="#element-include"><code>xsl:include</code></a> or <a href="#element-import"><code>xsl:import</code></a> declarations.</p><p>For the detailed effect of each attribute, see the following sections:</p><ul><li><p>
							<code>[xsl:]version</code>: see <a href="#backwards"><b>3.6 Backwards-Compatible Processing</b></a> and
<a href="#forwards"><b>3.7 Forwards-Compatible Processing</b></a>
						</p></li><li><p>
							<code>[xsl:]default-xpath-namespace</code>: see
 <a href="#unprefixed-qnames"><b>5.4 Unprefixed Names in Expressions and Patterns</b></a>.</p></li><li><p>
							<code>[xsl:]exclude-result-prefixes</code>
							: see
<a href="#lre-namespaces"><b>11.1.3 Namespace Nodes for Literal Result Elements</b></a>.</p></li><li><p>
							<code>[xsl:]extension-element-prefixes</code>: see
<a href="#extension-instruction"><b>18.2 Extension Instructions</b></a>.</p></li></ul><div><blockquote><p><b><a href="#issue-version-on-xsl-output">Issue 128 (version-on-xsl-output)</a>: </b>Allowing version as a standard attribute on any XSL element, to indicate backwards
    or forwards compatibility resquirements, conflicts with its existing use on the <a href="#element-output"><code>xsl:output</code></a>
    element. See also issue 122.</p></blockquote></div><blockquote><table width="100%"><tr><td width="10%" align="left" valign="top"><b>Ed. Note:</b></td><td align="left" valign="top">The XSL Working Group has decided in principle to impose
restrictions in the ability to mix different version attributes on different elements in a
stylesheet. The form of these restrictions has yet to be decided.</td></tr></table></blockquote></div><div class="div2">
<h3><a name="stylesheet-element" id="stylesheet-element"></a>3.4 Stylesheet Element</h3><p class="element-syntax"><a name="element-stylesheet"></a><code>&lt;xsl:stylesheet<br>&nbsp;&nbsp;id = <var>id</var><br>&nbsp;&nbsp;extension-element-prefixes = <var>tokens</var><br>&nbsp;&nbsp;exclude-result-prefixes = <var>tokens</var><br>&nbsp;&nbsp;<b>version</b> = <var>number</var><br>&nbsp;&nbsp;default-xpath-namespace = <var>uri</var>&gt;<br>&nbsp;&nbsp;&lt;!-- Content: (<a href="#element-import">xsl:import</a>*, <var>other-declarations</var>) --&gt;<br>&lt;/xsl:stylesheet&gt;</code></p><p class="element-syntax"><a name="element-transform"></a><code>&lt;xsl:transform<br>&nbsp;&nbsp;id = <var>id</var><br>&nbsp;&nbsp;extension-element-prefixes = <var>tokens</var><br>&nbsp;&nbsp;exclude-result-prefixes = <var>tokens</var><br>&nbsp;&nbsp;<b>version</b> = <var>number</var><br>&nbsp;&nbsp;default-xpath-namespace = <var>uri</var>&gt;<br>&nbsp;&nbsp;&lt;!-- Content: (<a href="#element-import">xsl:import</a>*, <var>other-declarations</var>) --&gt;<br>&lt;/xsl:transform&gt;</code></p><p>A stylesheet module is represented by an <a href="#element-stylesheet"><code>xsl:stylesheet</code></a>
element in an XML document.  <a href="#element-transform"><code>xsl:transform</code></a> is allowed as
a synonym for <a href="#element-stylesheet"><code>xsl:stylesheet</code></a>; everything
this specification says about the <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> element applies
equally to <a href="#element-transform"><code>xsl:transform</code></a>.</p><p>
					<a name="d5e2144"><small>[ERR009] </small></a>An <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> element must have a
<code>version</code> attribute, indicating the version of XSLT that
the stylesheet requires.
					<a name="d5e2153"><small>[ERR010] </small></a>The value of the <code>version</code> attribute
 
must be a number (specifically, it must be a <u>DecimalLiteral</u> as defined
 in <a href="#XPATH20">[XPath 2.0]</a>.) For this version of XSLT, the value should normally
be <code>2.0</code>.  When the value is less than 2.0, backwards-compatible 
processing behavior is enabled (see <a href="#backwards"><b>3.6 Backwards-Compatible Processing</b></a>). When the value
is greater than 2.0, 
<a title="forwards-compatible behavior" href="#dt-forwards-compatible-behavior">forwards-compatible behavior</a> 
is enabled (see <a href="#forwards"><b>3.7 Forwards-Compatible Processing</b></a>).</p><p>
					<a name="d5e2182"><small>[ERR011] </small></a>An <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> element must have
no text node children, other than text nodes consisting entirely of whitespace.
				</p><p>
					<a name="dt-top-level" id="dt-top-level" title="top-level"></a>An element occurring as
a child of an <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> element is called a
<b>top-level</b> element.
				</p><p>
					<a name="dt-declaration" id="dt-declaration" title="declaration"></a>Top-level 
elements fall into two categories: declarations, and 
user-defined data elements.
Top-level elements whose names are in the
<a title="XSLT namespace" href="#dt-xslt-namespace">XSLT namespace</a> are <b>declaration</b>s.
Top-level elements in any other namespace are
 <a title="user-defined data element" href="#dt-data-element">user-defined data elements</a>
(see <a href="#user-defined-top-level"><b>3.4.1 User-defined Data Elements</b></a>)
				</p><p>The <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> element may contain the following types
of <a title="declaration" href="#dt-declaration">declaration</a>:</p><ul><li><p>
							<a href="#element-import"><code>xsl:import</code></a>
						</p></li><li><p>
							<a href="#element-include"><code>xsl:include</code></a>
						</p></li><li><p>
							<a href="#element-attribute-set"><code>xsl:attribute-set</code></a>
						</p></li><li><p>
							<a href="#element-decimal-format"><code>xsl:decimal-format</code></a>
						</p></li><li><p>
							<a href="#element-function"><code>xsl:function</code></a>
						</p></li><li><p>
							<a href="#element-import-schema"><code>xsl:import-schema</code></a>
						</p></li><li><p>
							<a href="#element-key"><code>xsl:key</code></a>
						</p></li><li><p>
							<a href="#element-namespace-alias"><code>xsl:namespace-alias</code></a>
						</p></li><li><p>
							<a href="#element-output"><code>xsl:output</code></a>
						</p></li><li><p>
							<a href="#element-param"><code>xsl:param</code></a>
						</p></li><li><p>
							<a href="#element-preserve-space"><code>xsl:preserve-space</code></a>
						</p></li><li></li><li><p>
							<a href="#element-sort-key"><code>xsl:sort-key</code></a>
						</p></li><li><p>
							<a href="#element-strip-space"><code>xsl:strip-space</code></a>
						</p></li><li><p>
							<a href="#element-template"><code>xsl:template</code></a>
						</p></li><li><p>
							<a href="#element-variable"><code>xsl:variable</code></a>
						</p></li></ul><p>If there are <a href="#element-import"><code>xsl:import</code></a> elements, these must come before
any other elements. Apart from this, the child elements of the <a href="#element-stylesheet"><code>xsl:stylesheet</code></a>
element may appear in any order. The ordering of these elements does not affect the results
of the transformation unless there are conflicting declarations (for example, two template rules
with the same priority that match the same node). In general, it is an error for a stylesheet
to contain such conflicting declarations,
but in some cases the processor is allowed to recover from the error by choosing the declaration that
appears last in the stylesheet.</p><div class="div3">
<h4><a name="user-defined-top-level" id="user-defined-top-level"></a>3.4.1 User-defined Data Elements</h4><p>
						<a name="dt-data-element" id="dt-data-element" title="user-defined data element"></a>In addition to 
<a title="declaration" href="#dt-declaration">declarations</a>, 
the <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> element may contain
any element not from the <a title="XSLT namespace" href="#dt-xslt-namespace">XSLT namespace</a>,
 provided that the
<a title="expanded-QName" href="#dt-expanded-qname">expanded-QName</a> of the element has a non-null namespace URI.  Such
elements are referred to as <b>user-defined data elements</b>.
						<a name="d5e2353"><small>[ERR012] </small></a>It is a <a title="static error" href="#dt-static-error">static error</a>
 if the <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> element has
a child element having a null namespace URI.
					</p><p>An implementation may attach meaning to user-defined
data elements that appear in a namespace controlled by the vendor. The presence of
a user-defined data element must not change the behavior of XSLT elements
and functions defined in this document; for example, it is not
permitted for a user-defined data element to specify that
<a href="#element-apply-templates"><code>xsl:apply-templates</code></a> should use different rules to resolve
conflicts. Thus, an implementation is always free to ignore user-defined data elements,
 and must ignore such data elements without giving
an error if it does not recognize the namespace URI. 
The set of namespaces that are recognized for such data elements is
 <a title="implementation-defined" href="#dt-implementation-defined">implementation-defined</a>.</p><p>User-defined data elements can provide, for example,</p><ul><li><p>information used by <a title="extension instruction" href="#dt-extension-instruction">extension instructions</a> 
or <a title="extension function" href="#dt-extension-function">extension functions</a>
(see <a href="#extension"><b>18 Extensibility and Fallback</b></a>),</p></li><li><p>information about what to do with the result tree,</p></li><li><p>information about how to obtain the source tree,</p></li><li><p>optimization hints for the <a title="processor" href="#dt-processor">processor</a>,</p></li><li><p>metadata about the stylesheet,</p></li><li><p>structured documentation for the stylesheet.</p></li></ul><p>
						<a name="d5e2406"><small>[ERR013] </small></a>A <a title="user-defined data element" href="#dt-data-element">user-defined data element</a>
must not precede an <a href="#element-import"><code>xsl:import</code></a> element within a
<a title="stylesheet module" href="#dt-stylesheet-module">stylesheet module</a>.
					</p></div></div><div class="div2">
<h3><a name="simplified-stylesheet" id="simplified-stylesheet"></a>3.5 Simplified Stylesheet Modules</h3><p>A simplified syntax is allowed for a <a title="stylesheet module" href="#dt-stylesheet-module">stylesheet module</a>
that defines only a single template rule for the document node.
The stylesheet module may consist of
just a <a title="literal result element" href="#dt-literal-result-element">literal result element</a> 
(see <a href="#literal-result-element"><b>11.1 Literal Result Elements</b></a>) together with its contents.
  Such a stylesheet is equivalent to a
standard stylesheet module whose <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> element contains a
<a title="template rule" href="#dt-template-rule">template rule</a> containing the literal result element;
the template rule has a match <a title="pattern" href="#dt-pattern">pattern</a> of <code>/</code>.</p><div class="example"><p>For example:</p><div class="exampleInner"><pre>&lt;html xsl:version="2.0"
      xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
      xmlns="http://www.w3.org/1999/xhtml"&gt;
  &lt;head&gt;
    &lt;title&gt;Expense Report Summary&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;p&gt;Total Amount: &lt;xsl:value-of select="expense-report/total"/&gt;&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre></div><p>has the same meaning as</p><div class="exampleInner"><pre>&lt;xsl:stylesheet version="2.0"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                xmlns="http://www.w3.org/1999/xhtml"&gt;
&lt;xsl:template match="/"&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Expense Report Summary&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;p&gt;Total Amount: &lt;xsl:value-of select="expense-report/total"/&gt;&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
&lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;</pre></div></div><p>More formally, a simplified stylesheet module is
equivalent to the standard stylesheet module that would be generated by
applying the following transformation to the simplified stylesheet module,
invoking the transformation by calling the
 <a title="named template" href="#dt-named-template">named template</a>
						<code>expand</code>, with
the containing literal result element as the <a title="context node" href="#dt-context-node">context node</a>:
				</p><div class="exampleInner"><pre>&lt;xsl:stylesheet version="2.0"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

&lt;xsl:template name="expand"&gt;
  &lt;xsl:element name="xsl:stylesheet"&gt;
    &lt;xsl:attribute name="version"&gt;
      &lt;xsl:value-of select="@xsl:version"/&gt;
    &lt;/xsl:attribute&gt;
    &lt;xsl:element name="xsl:template"&gt;
      &lt;xsl:attribute name="match"&gt;/&lt;/xsl:attribute&gt;
      &lt;xsl:copy-of select="."/&gt;
    &lt;/xsl:element&gt;
  &lt;/xsl:element&gt;
&lt;/xsl:template&gt;  

&lt;/xsl:stylesheet&gt;</pre></div><p>
					<a name="d5e2478"><small>[ERR014] </small></a>A <a title="literal result element" href="#dt-literal-result-element">literal result element</a> that
 is used as the outermost element of a
simplified stylesheet module must have
 an <code>xsl:version</code> attribute. This
indicates the version of XSLT that the stylesheet requires.  
For this version of XSLT, the value should normally be <code>2.0</code>; the
value must be a <u>DecimalLiteral</u>
as defined in <a href="#XPATH20">[XPath 2.0]</a>.</p><p>Other
<a title="literal result element" href="#dt-literal-result-element">literal result elements</a> may also 
have an <code>xsl:version</code> attribute. When the <code>xsl:version</code> 
attribute is numerically less than
<code>2.0</code>, backwards-compatible processing behavior is enabled (see <a href="#backwards"><b>3.6 Backwards-Compatible Processing</b></a>). 
When the <code>xsl:version</code> attribute is numerically greater than <code>2.0</code>, 
<a title="forwards-compatible behavior" href="#dt-forwards-compatible-behavior">forwards-compatible behavior</a> 
is enabled (see <a href="#forwards"><b>3.7 Forwards-Compatible Processing</b></a>).</p><p>The allowed content of a literal result element when used as a
simplified stylesheet is the same as when it occurs within a
<a title="content constructor" href="#dt-content-constructor">content constructor</a>. 
Thus, a literal result element used as the document element of
a simplified stylesheet cannot
contain <a title="declaration" href="#dt-declaration">declarations</a>.</p></div><div class="div2">
<h3><a name="backwards" id="backwards"></a>3.6 Backwards-Compatible Processing</h3><p>
					<a name="dt-backwards-compatible-behavior" id="dt-backwards-compatible-behavior" title="backwards compatible behavior"></a>An element 
enables backwards-compatible behavior for itself, its
attributes, its descendants and their attributes if it has an
<code>[xsl:]version</code> attribute (see <a href="#standard-attributes"><b>3.3 Standard Attributes</b></a>)
whose value is less than <code>2.0</code>.  
An element
that has an <code>[xsl:]version</code> attribute whose value is greater than or equal to
<code>2.0</code> 
disables backwards-compatible behavior for itself, its attributes, its
descendants and their attributes. The compatibility
behavior established by an element overrides
any compatibility behavior established by an ancestor element.</p><p>If an attribute containing an XPath <a title="expression" href="#dt-expression">expression</a> is processed with
 backwards-compatible behavior, then:</p><ul><li><p>It is constrained to use syntax permitted by XPath 1.0</p></li><li><p>It is guaranteed to return the same result as would be returned by
XPath 1.0, after conversion of any <a title="variable" href="#dt-variable">variables</a> that it references to the
equivalent XPath 1.0 data type. This conversion is done as follows. Any numeric
value is converted to the nearest XPath 1.0 number. Boolean values remain as
booleans; any other atomic value is converted to a string. 
<a name="d5e2570"><small>[ERR015] </small></a>If the value
 
is an empty sequence or a sequence that consists entirely of nodes,
then it is converted to a node-set; it is a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a>
if the value is any other sequence of two or more items.
The <a title="processor" href="#dt-processor">processor</a> must signal the error.
							
 The result of the expression is converted to
an XPath 2.0 value by representing any node-set as a sequence of nodes in document
order.</p></li></ul><div><blockquote><p><b><a href="#issue-mixing-versions">Issue 122 (mixing-versions)</a>: </b>Mixing version 1.0 and version 2.0 code in the same stylesheet has considerable
      complications. We probably need to be more restrictive than we are here. </p></blockquote></div><p>It is
<a title="implementation-defined" href="#dt-implementation-defined">implementation-defined</a>
whether a particular XSLT 2.0 implementation supports backwards-compatible behavior.
<a name="d5e2594"><small>[ERR016] </small></a>If an implementation does not support backwards-compatible
behavior, then it is a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a>
if any element is evaluated that enables 
backwards-compatible behavior.
The <a title="processor" href="#dt-processor">processor</a> must signal the error.
					
				</p><blockquote><table width="90%"><tr><td width="10%" align="left" valign="top"><b>Note:</b></td><td align="left" valign="top"><p>To write a stylesheet that works with both XSLT 1.0 and 2.0 processors, while making
				selective use of XSLT 2.0 facilities, it is necessary to understand both the rules for
				backwards-compatible behavior in XSLT 2.0, and the rules for forwards-compatible
				behavior in XSLT 1.0. If the <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> element specifies
				<code>version="2.0"</code>, then an XSLT 1.0 processor will ignore XSLT 2.0 
				<a title="declaration" href="#dt-declaration">declarations</a> that were not defined in XSLT 1.0, for
				example <a href="#element-function"><code>xsl:function</code></a> and <a href="#element-sort-key"><code>xsl:sort-key</code></a>. If any new XSLT 2.0
				instructions are used (for example <a href="#element-analyze-string"><code>xsl:analyze-string</code></a> or <a href="#element-namespace"><code>xsl:namespace</code></a>),
				or if new XPath 2.0 features are used (for example, new functions, or syntax such as conditional
				expressions, or calls to a function defined using <a href="#element-function"><code>xsl:function</code></a>), 
				then the stylesheet must provide fallback behavior that relies on XSLT 1.0 and XPath 1.0
				facilities only. The fallback behavior can be invoked by using the <a href="#element-fallback"><code>xsl:fallback</code></a>
				instruction, or by testing the results of the <a href="#function-function-available"><b>function-available</b></a> or 
				<a href="#function-element-available"><b>element-available</b></a> functions, or by testing the value of the <code>xsl:version</code>
				property returned by the <a href="#function-system-property"><b>system-property</b></a> function.</p></td></tr></table></blockquote></div><div class="div2">
<h3><a name="forwards" id="forwards"></a>3.7 Forwards-Compatible Processing</h3><p>
					<a name="dt-forwards-compatible-behavior" id="dt-forwards-compatible-behavior" title="forwards-compatible behavior"></a>An element enables
 <b>forwards-compatible behavior</b> for itself, its
attributes, its descendants and their attributes if it has an
<code>[xsl:]version</code> attribute (see <a href="#standard-attributes"><b>3.3 Standard Attributes</b></a>) 
whose value is greater than <code>2.0</code>.
An element that has an <code>[xsl:]version</code> attribute 
whose value is less than or equal to <code>2.0</code> 
disables forwards-compatible behavior for itself, its attributes, its
descendants and their attributes.
The compatibility behavior established by an element overrides
any compatibility behavior established by an ancestor element.</p><p>Within a section of a stylesheet where forwards-compatible
behavior is enabled, errors that would normally be
 <a title="static error" href="#dt-static-error">static errors</a> are treated instead as
 <a title="dynamic error" href="#dt-dynamic-error">dynamic errors</a>. This means that
 no error is reported unless the construct containing the error is actually
 evaluated.</p><p>This means, for example, that when an element is processed with 
forwards-compatible behavior:</p><ul><li><p>if it is a <a title="declaration" href="#dt-declaration">declaration</a>
element and XSLT 2.0 does not allow such
elements as declarations, then the element must be ignored along
with its content;</p></li><li><p>if it is an element in a <a title="content constructor" href="#dt-content-constructor">content constructor</a> 
and XSLT 2.0 does not allow such elements to occur in
<a title="content constructor" href="#dt-content-constructor">content constructors</a>, then if the element is not evaluated, no error must 
be signaled, and if the element is evaluated, the <a title="processor" href="#dt-processor">processor</a> must perform
fallback for the element as specified in <a href="#fallback"><b>18.2.3 Fallback</b></a>;</p></li><li><p>if the element has an attribute that XSLT 2.0 does not allow the element to have or if the
element has an optional attribute with a value that XSLT 2.0 does not allow the attribute to have, then the
attribute must be ignored.</p></li><li><p>if an attribute of the element contains an XPath
<a title="expression" href="#dt-expression">expression</a> that does not match 
the allowed syntax of an XPath 2.0 expression, or one that calls a function 
whose name is in the
 <a title="standard function namespace" href="#dt-standard-function-namespace">standard function namespace</a>
(see <a href="#FANDO">[Functions and Operators]</a>)
but that is not defined in XPath 2.0 or XSLT 2.0, or that
calls such a function with the wrong number or type of arguments, the error
must not be signaled unless the expression is actually evaluated.</p></li></ul><div class="example"><p>Thus, any XSLT 2.0 <a title="processor" href="#dt-processor">processor</a> must be
able to process the following stylesheet without error, although the
stylesheet includes elements from 
the <a title="XSLT namespace" href="#dt-xslt-namespace">XSLT namespace</a> that are not
defined in this specification:</p><div class="exampleInner"><pre>&lt;xsl:stylesheet version="17.0"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
  &lt;xsl:template match="/"&gt;
    &lt;xsl:choose&gt;
      &lt;xsl:when test="system-property('xsl:version') &gt;= 17.0"&gt;
        &lt;xsl:exciting-new-17.0-feature/&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:otherwise&gt;
        &lt;html&gt;
        &lt;head&gt;
          &lt;title&gt;XSLT 17.0 required&lt;/title&gt;
        &lt;/head&gt;
        &lt;body&gt;
          &lt;p&gt;Sorry, this stylesheet requires XSLT 17.0.&lt;/p&gt;
        &lt;/body&gt;
        &lt;/html&gt;
      &lt;/xsl:otherwise&gt;
    &lt;/xsl:choose&gt;
  &lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;</pre></div></div><blockquote><table width="90%"><tr><td width="10%" align="left" valign="top"><b>Note:</b></td><td align="left" valign="top"><p>If a stylesheet depends crucially on a <a title="declaration" href="#dt-declaration">declaration</a>
introduced by a version of XSLT after 2.0, then
the stylesheet can use an <a href="#element-message"><code>xsl:message</code></a> element with
<code>terminate="yes"</code> (see <a href="#message"><b>17 Messages</b></a>) to ensure
that implementations that conform to an earlier version of XSLT will not silently ignore the
<a title="declaration" href="#dt-declaration">declaration</a>.</p></td></tr></table></blockquote><div class="example"><p>For example,</p><div class="exampleInner"><pre>&lt;xsl:stylesheet version="18.0"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

  &lt;xsl:important-new-17.0-declaration/&gt;

  &lt;xsl:template match="/"&gt;
    &lt;xsl:choose&gt;
      &lt;xsl:when test="system-property('xsl:version') &lt; 17.0"&gt;
        &lt;xsl:message terminate="yes"&gt;
          &lt;xsl:text&gt;Sorry, this stylesheet requires XSLT 17.0.&lt;/xsl:text&gt;
        &lt;/xsl:message&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:otherwise&gt;
        ...
      &lt;/xsl:otherwise&gt;
    &lt;/xsl:choose&gt;
  &lt;/xsl:template&gt;
  ...
&lt;/xsl:stylesheet&gt;</pre></div></div></div><div class="div2">
<h3><a name="d5e2757" id="d5e2757"></a>3.8 Combining Stylesheet Modules</h3><p>XSLT provides two mechanisms to construct
 a stylesheet from multiple stylesheet modules:</p><ul><li><p>an inclusion mechanism that allows stylesheet modules to be combined
without changing the semantics of the modules being combined,
and</p></li><li><p>an import mechanism that allows stylesheet modules to override each
other.</p></li></ul><div class="div3">
<h4><a name="include" id="include"></a>3.8.1 Stylesheet Inclusion</h4><p class="element-syntax"><a name="element-include"></a><code>&lt;!-- Category: declaration --&gt;<br>&lt;xsl:include<br>&nbsp;&nbsp;<b>href</b> = <var>uri-reference</var>&nbsp;/&gt;</code></p><p>A stylesheet module may include another stylesheet module using an
<a href="#element-include"><code>xsl:include</code></a> declaration. The <a href="#element-include"><code>xsl:include</code></a> declaration
has an <code>href</code> attribute whose value is a URI reference
identifying the stylesheet module to be included.  A relative URI is resolved
relative to the base URI of the <a href="#element-include"><code>xsl:include</code></a> declaration (see
<a href="#DATAMODEL">[Data Model]</a>).</p><p>It is <a title="implementation-defined" href="#dt-implementation-defined">implementation-defined</a> whether the URI reference may include
a fragment identifier, and if so, what form of fragment identifier is supported. A future
version of XSLT may define rules for the use of fragment identifiers in the URI reference, for example
by reference to the XPointer specification (see <a href="#XPOINTER">[XPointer]</a>). Note that if 
the implementation does not support the use of fragment identifiers in the URI reference,
then it will not be possible to include an <a title="embedded stylesheet module" href="#dt-embedded-stylesheet-module">embedded
stylesheet module</a>.</p><p>The included stylesheet module may be either a
 <a title="standard stylesheet module" href="#dt-standard-stylesheet-module">standard stylesheet module</a> or a
a <a title="simplified stylesheet module" href="#dt-simplified-stylesheet-module">simplified stylesheet module</a>. It may
be a complete XML document, or (if referenced using a suitable fragment identifier) it may be
an <a title="embedded stylesheet module" href="#dt-embedded-stylesheet-module">embedded stylesheet module</a>
						.</p><p>
						<a name="d5e2834"><small>[ERR017] </small></a>The <a href="#element-include"><code>xsl:include</code></a> element is allowed only as a
 <a title="top-level" href="#dt-top-level">top-level</a> element.
					</p><p>
						<a name="dt-stylesheet-level" id="dt-stylesheet-level" title="stylesheet level"></a>A <b>stylesheet level</b>
is a collection of <a title="stylesheet module" href="#dt-stylesheet-module">stylesheet modules</a> connected
using <a href="#element-include"><code>xsl:include</code></a> declarations: 
specifically, two stylesheet modules <var>A</var> and <var>B</var> are part of the same 
stylesheet level if one of them includes the other by means of an <a href="#element-include"><code>xsl:include</code></a>
declaration, or if there is a third stylesheet module <var>C</var> that is in the same 
stylesheet level as both <var>A</var> and <var>B</var>.
					</p><p>
						<a name="dt-declaration-order" id="dt-declaration-order" title="declaration order"></a>The
 <a title="declaration" href="#dt-declaration">declarations</a> within a
<a title="stylesheet level" href="#dt-stylesheet-level">stylesheet level</a> have a total ordering known
 as <b>declaration order</b>. The order of declarations within a stylesheet
 level is the same as the document order that would result if each stylesheet module were
 inserted textually in place of the <a href="#element-include"><code>xsl:include</code></a> element that references it.
In other respects, however, the effect of <a href="#element-include"><code>xsl:include</code></a> is not equivalent to
the effect that would be obtained by textual inclusion.</p><p>
						<a name="d5e2897"><small>[ERR018] </small></a>It is an <a title="static error" href="#dt-static-error">static error</a> 
if a stylesheet module
 directly or indirectly includes itself.
					</p><blockquote><table width="90%"><tr><td width="10%" align="left" valign="top"><b>Note:</b></td><td align="left" valign="top"><p>It is not intrinsically an error for a stylesheet
to include the same module more than once. However, doing so can cause errors
because of duplicate definitions.  Such multiple inclusions are less
obvious when they are indirect. For example, if stylesheet
<var>B</var> includes stylesheet <var>A</var>, stylesheet <var>C</var>
includes stylesheet <var>A</var>, and stylesheet <var>D</var> includes
both stylesheet <var>B</var> and stylesheet <var>C</var>, then
<var>A</var> will be included indirectly by <var>D</var> twice.  If
all of <var>B</var>, <var>C</var> and <var>D</var> are used as
independent stylesheets, then the error can be avoided by separating
everything in <var>B</var> other than the inclusion of <var>A</var>
into a separate stylesheet <var>B'</var> and changing <var>B</var> to
contain just inclusions of <var>B'</var> and <var>A</var>, similarly
for <var>C</var>, and then changing <var>D</var> to include
<var>A</var>, <var>B'</var>, <var>C'</var>.</p></td></tr></table></blockquote></div><div class="div3">
<h4><a name="import" id="import"></a>3.8.2 Stylesheet Import</h4><p class="element-syntax"><a name="element-import"></a><code>&lt;!-- Category: declaration --&gt;<br>&lt;xsl:import<br>&nbsp;&nbsp;<b>href</b> = <var>uri-reference</var>&nbsp;/&gt;</code></p><p>A stylesheet module may import another
stylesheet module using an
<a href="#element-import"><code>xsl:import</code></a>
						<a title="declaration" href="#dt-declaration">declaration</a>.  
Importing a stylesheet is the same
as including it (see <a href="#include"><b>3.8.1 Stylesheet Inclusion</b></a>) except that 
<a title="template rule" href="#dt-template-rule">template rules</a> 
and other <a title="declaration" href="#dt-declaration">declarations</a> in the 
importing stylesheet take precedence over
template rules and declarations in the imported stylesheet; this is
described in more detail below.  The <a href="#element-import"><code>xsl:import</code></a> declaration
has an <code>href</code> attribute whose value is a URI reference
identifying the stylesheet to be imported.  A relative URI is resolved
relative to the base URI of the <a href="#element-import"><code>xsl:import</code></a> element (see
<a href="#DATAMODEL">[Data Model]</a>).</p><p>It is <a title="implementation-defined" href="#dt-implementation-defined">implementation-defined</a>
 whether the URI reference may include
a fragment identifier, and if so, what form of fragment identifier is supported. A future
version of XSLT may define rules for the use of fragment identifiers in the URI reference, for example
by reference to the XPointer specification (see <a href="#XPOINTER">[XPointer]</a>). Note that if 
the implementation does not support the use of fragment identifiers in the URI reference,
then it will not be possible to import an <a title="embedded stylesheet module" href="#dt-embedded-stylesheet-module">embedded
stylesheet module</a>.</p><p>The imported stylesheet module may be either a
 <a title="standard stylesheet module" href="#dt-standard-stylesheet-module">standard stylesheet module</a> or a
a <a title="simplified stylesheet module" href="#dt-simplified-stylesheet-module">simplified stylesheet module</a>. It may
be a complete XML document, or (if referenced using a suitable fragment identifier) it may be
an <a title="embedded stylesheet module" href="#dt-embedded-stylesheet-module">embedded stylesheet module</a>.</p><p>
						<a name="d5e3036"><small>[ERR019] </small></a>The <a href="#element-import"><code>xsl:import</code></a>
							<a title="declaration" href="#dt-declaration">declaration</a> 
is allowed only as a <a title="top-level" href="#dt-top-level">top-level</a> element.
						<a name="d5e3048"><small>[ERR020] </small></a>The
<a href="#element-import"><code>xsl:import</code></a> element children must precede all other
element children of an <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> element, including
any <a href="#element-include"><code>xsl:include</code></a> element children and any
<a title="user-defined data element" href="#dt-data-element">user-defined data elements</a>.
					</p><div class="example"><p>For example,</p><div class="exampleInner"><pre>&lt;xsl:stylesheet version="2.0"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
  &lt;xsl:import href="article.xsl"/&gt;
  &lt;xsl:import href="bigfont.xsl"/&gt;
  &lt;xsl:attribute-set name="note-style"&gt;
    &lt;xsl:attribute name="font-style"&gt;italic&lt;/xsl:attribute&gt;
  &lt;/xsl:attribute-set&gt;
&lt;/xsl:stylesheet&gt;</pre></div></div><p>
						<a name="dt-import-tree" id="dt-import-tree" title="import tree"></a>The
<a title="stylesheet level" href="#dt-stylesheet-level">stylesheet levels</a>
making up a stylesheet are
treated as forming an <b>import tree</b>.  In the import tree,
each stylesheet level has one child for each
<a href="#element-import"><code>xsl:import</code></a> declaration that it contains. The ordering 
of the children is the <a title="declaration order" href="#dt-declaration-order">declaration order</a>
of the <a href="#element-import"><code>xsl:import</code></a> declarations within their stylesheet level.
<a name="dt-import-precedence" id="dt-import-precedence" title="import precedence"></a>A <a title="declaration" href="#dt-declaration">declaration</a>
							<var>D</var> in the stylesheet
is defined to have lower <b>import precedence</b> than another
declaration <var>E</var> if the stylesheet level containing <var>D</var> would be
visited before the stylesheet level containing <var>E</var> in a
post-order traversal of the import tree (that is, a traversal of the
import tree in which a stylesheet level is visited
after its children). Two declarations within the same stylesheet level have
the same import precedence.
					</p><p>For example, suppose</p><ul><li><p>stylesheet module <var>A</var> imports stylesheet modules <var>B</var>
and <var>C</var> in that order;</p></li><li><p>stylesheet module <var>B</var> imports stylesheet module
<var>D</var>;</p></li><li><p>stylesheet module <var>C</var> imports stylesheet module
<var>E</var>.</p></li></ul><p>Then the import tree has the following structure:</p><div class="exampleInner"><pre>
         A
         |
     +---+---+
     |       |
     B       C
     |       |
     D       E
</pre></div><p>The order of import precedence (lowest first) is
<var>D</var>, <var>B</var>, <var>E</var>, <var>C</var>, <var>A</var>.</p><p>In general, a <a title="declaration" href="#dt-declaration">declaration</a>
with higher import precedence takes precedence over a declaration with
lower import precedence.  This is defined in detail for each kind of declaration.</p><p>
						<a name="d5e3170"><small>[ERR021] </small></a>It is a <a title="static error" href="#dt-static-error">static error</a> if
 a stylesheet module directly or indirectly imports itself.
					</p><blockquote><table width="90%"><tr><td width="10%" align="left" valign="top"><b>Note:</b></td><td align="left" valign="top"><p>The case where a stylesheet with a particular
URI is imported in multiple places is not treated specially. The resulting
stylesheet will contain multiple declarations that are identical in content
but that differ in their import precedence.</p></td></tr></table></blockquote></div></div><div class="div2">
<h3><a name="embedded" id="embedded"></a>3.9 Embedded Stylesheet Modules</h3><p>A standard stylesheet module is a complete XML document with the
<a href="#element-stylesheet"><code>xsl:stylesheet</code></a> element as its document element. However,
a stylesheet module may also be embedded in another resource. Two forms
of embedding are possible:</p><ul><li><p>the XSLT stylesheet may be textually embedded in a non-XML
resource, or</p></li><li><p>the <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> element may occur in an XML
document other than as the document element.</p></li></ul><p>To facilitate the second form of embedding, the
<a href="#element-stylesheet"><code>xsl:stylesheet</code></a> element is allowed to have an ID attribute
that specifies a unique identifier.</p><blockquote><table width="90%"><tr><td width="10%" align="left" valign="top"><b>Note:</b></td><td align="left" valign="top"><p>In order for such an attribute to be used with the XPath
<u>fn:id</u> function, it must actually be declared in
the DTD or schema as being of type ID. 
The same requirement typically applies if
the identifier is to be used as a fragment identifier in a URI reference.</p></td></tr></table></blockquote><div class="example"><p>The following example shows how the <code>xml-stylesheet</code>
processing instruction (see <a href="#XMLSTYLE">[XML Stylesheet]</a>) can be used to allow a
source document to contain its own stylesheet. The URI reference uses a
relative URI with a fragment identifier to locate the
<a href="#element-stylesheet"><code>xsl:stylesheet</code></a> element:</p><div class="exampleInner"><pre>&lt;?xml-stylesheet type="text/xml" href="#style1"?&gt;
&lt;!DOCTYPE doc SYSTEM "doc.dtd"&gt;
&lt;doc&gt;
&lt;head&gt;
&lt;xsl:stylesheet id="style1"
                version="2.0"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                xmlns:fo="http://www.w3.org/1999/XSL/Format"&gt;
&lt;xsl:import href="doc.xsl"/&gt;
&lt;xsl:template match="id('foo')"&gt;
  &lt;fo:block font-weight="bold"&gt;&lt;xsl:apply-templates/&gt;&lt;/fo:block&gt;
&lt;/xsl:template&gt;
&lt;xsl:template match="xsl:stylesheet"&gt;
  &lt;!-- ignore --&gt;
&lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;para id="foo"&gt;
...
&lt;/para&gt;
&lt;/body&gt;
&lt;/doc&gt;
</pre></div></div><blockquote><table width="90%"><tr><td width="10%" align="left" valign="top"><b>Note:</b></td><td align="left" valign="top"><p>A stylesheet module that is embedded in the document to which it is
to be applied 

 typically needs
to contain a <a title="template rule" href="#dt-template-rule">template rule</a> that specifies that
<a href="#element-stylesheet"><code>xsl:stylesheet</code></a> elements are to be ignored.</p></td></tr></table></blockquote><blockquote><table width="90%"><tr><td width="10%" align="left" valign="top"><b>Note:</b></td><td align="left" valign="top"><p>The above example uses the pseudo-attribute <code>type="text/xml"</code>
in the <code>xml-stylesheet</code> processing instruction to denote an XSLT stylesheet. This usage
was defined provisionally in XSLT 1.0, and is subject to change. 
In the absence of a registered media type for XSLT stylesheets, some vendors' products
have adopted different conventions, notably <code>type="text/xsl"</code>.</p></td></tr></table></blockquote><blockquote><table width="90%"><tr><td width="10%" align="left" valign="top"><b>Note:</b></td><td align="left" valign="top"><p>Support for the <code>xml-stylesheet</code> processing instruction is not
a requirement for conformance with this Recommendation.</p></td></tr></table></blockquote></div><div class="div2">
<h3><a name="import-schema" id="import-schema"></a>3.10 Importing Schema Components</h3><p class="element-syntax"><a name="element-import-schema"></a><code>&lt;!-- Category: declaration --&gt;<br>&lt;xsl:import-schema<br>&nbsp;&nbsp;namespace = <var>uri-reference</var><br>&nbsp;&nbsp;schema-location = <var>uri-reference</var>&nbsp;/&gt;</code></p><p>The <a href="#element-import-schema"><code>xsl:import-schema</code></a> declaration is used to identify schema components (that is,
definitions of types) which need to be available statically, that is, before any source document is
available. Every type name used statically within the stylesheet
other than the built-in type names defined in XML Schema
 must be defined in an imported schema. The declaration imports the element and 
attribute declarations and type definitions from the schema, and maps them to types in the XPath data model
according to rules defined in <a href="#XPATH-FS">[Formal Semantics]</a>.</p><blockquote><table width="100%"><tr><td width="10%" align="left" valign="top"><b>Ed. Note:</b></td><td align="left" valign="top">The relationship of this document to the Formal Semantics needs
to be clarified.</td></tr></table></blockquote><p>The <code>namespace</code> and <code>schema-location</code> attributes are both optional. At least one
of them must be present, and it is permissible to supply both.</p><p>The <code>namespace</code> attribute indicates that a schema for the given namespace is required
by the stylesheet. This information may be enough on its own to enable an implementation to locate
the required schema components.</p><p>The <code>schema-location</code> attribute gives the URI of a location where a schema document 
or other resource containing the required definitions may be found. An XSLT processor must have the
capability to process an XML Schema that exists at this location in the form of a source XML document;
implementations may also be able to access equivalent information held in other forms, for example
a compiled XML Schema, or type information expressed using some other schema language.</p><p>
					<a name="d5e3300"><small>[ERR022] </small></a>It is a static error if the processor is not able to locate a schema using the <code>namespace</code>
and/or <code>schema-location</code> attributes , or if the document that it locates is neither a valid XML Schema nor any other resource that the
implementation can process.
				</p><p>
					<a name="d5e3317"><small>[ERR023] </small></a>It is a static error if two <a href="#element-import-schema"><code>xsl:import-schema</code></a> declarations yield multiple
definitions for the same named type, even if the definitions are consistent with each other.
				</p><p>The use of a namespace in an <a href="#element-import-schema"><code>xsl:import-schema</code></a> declaration does not by itself make
the namespace available for use in the stylesheet. If names from the namespace are used within the stylesheet, a prefix
must be associated with the namespace by means of a namespace declaration, in the normal way.</p><p>The precise way in which an implementation uses the <code>namespace</code>
and/or <code>schema-location</code> attributes to locate schema definitions
is <a title="implementation-defined" href="#dt-implementation-defined">implementation-defined</a>.</p><div><blockquote><p><b><a href="#issue-schema-conformance">Issue 125 (schema-conformance)</a>: </b>We need to describe a conformance level that does not require schema
      support.</p></blockquote></div></div></div><div class="div1">
<h2><a name="data-model" id="data-model"></a>4 Data Model</h2><p>The data model used by XSLT is the XPath 2.0 and XQuery 1.0 data model, as 
defined in <a href="#DATAMODEL">[Data Model]</a>, with the additions
described in this section.  XSLT operates on source, result and
stylesheet documents using the same data model.</p><p>Some of the sections below describe restrictions to the data model: that is,
features of the data model that are never used by XSLT. Some sections describe additions to the data model:
that is, information that is required to support XSLT processing, 
but that is not described in the data model. Other sections describe refinements to the data model,
that is, additional rules about the way in which trees in the data model are constructed. Each section
is therefore marked as a restriction, and addition, or a refinement.</p><blockquote><table width="90%"><tr><td width="10%" align="left" valign="top"><b>Note:</b></td><td align="left" valign="top"><p>Features of a source XML document that are not represented
in the tree defined by the data model will have no effect on the operation of
an XSLT stylesheet. Examples of such features are entity references, CDATA sections,
character references, whitespace within element tags, and the choice of single or double
quotes around attribute values.</p></td></tr></table></blockquote><blockquote><table width="100%"><tr><td width="10%" align="left" valign="top"><b>Ed. Note:</b></td><td align="left" valign="top">We need to say something here about schemas and DTDs.
See <a href="http://lists.w3.org/Archives/Member/w3c-xsl-wg/2002Jan/0113.html">http://lists.w3.org/Archives/Member/w3c-xsl-wg/2002Jan/0113.html</a><b> (members only) </b> and subsequent
      discussion.</td></tr></table></blockquote><div class="div2">
<h3><a name="rootless-nodes" id="rootless-nodes"></a>4.1 Parentless Nodes</h3><p>
					<em>Restriction</em>
				</p><p>The data model defined in <a href="#DATAMODEL">[Data Model]</a> allows a node to
be part of a tree whose root is a node other than a document node.</p><p>XSLT does not allow nodes with no parent (other than document nodes)
to be created: a node created during the
course of XSLT processing is not available for further processing until
it has been attached to a tree that is rooted at a document node. However,
implementations may allow parentless nodes to be supplied as input to the
transformation, for example as parameters to the stylesheet.</p></div><div class="div2">
<h3><a name="unparsed-entities" id="unparsed-entities"></a>4.2 Unparsed Entities</h3><blockquote><table width="90%"><tr><td width="10%" align="left" valign="top"><b>Note:</b></td><td align="left" valign="top"><p>Unparsed entities are now supported in the data model,
				as described in <a href="#DATAMODEL">[Data Model]</a>. This section is therefore no longer required.</p></td></tr></table></blockquote></div><div class="div2">
<h3><a name="strip" id="strip"></a>4.3 Whitespace Stripping</h3><p>
					<em>Refinement</em>
				</p><p>The source document supplied as input to the 
transformation process may contain whitespace nodes (that is, text nodes
consisting solely of whitespace characters) that are of no interest,
and that do not need to be retained by the transformation. Conceptually,
such whitespace nodes may be removed from the tree before the transformation
commences. This process is referred to as whitespace stripping. The source
tree itself must not be modified: the processor may implement whitespace
stripping either by creating a copy of the tree from which the
whitespace nodes have been removed, or by working on a virtual tree in which
the whitespace nodes are treated as if they were absent.</p><p>The stripping process takes as input a set of element names 
whose child whitespace nodes must be
preserved.  The stripping process is applied to both stylesheets and
source documents, but the set of whitespace-preserving element names
is determined differently for stylesheets and for source
documents.</p><blockquote><table width="90%"><tr><td width="10%" align="left" valign="top"><b>Note:</b></td><td align="left" valign="top"><p>Where multiple transformations are to be applied to the same
source document, a useful optimization is to do the whitespace stripping
only once. Implementations may therefore allow whitespace stripping to
be controlled as a separate operation from the rest of the transformation 
process.</p></td></tr></table></blockquote><p>A text node is preserved if any of the following apply:</p><ul><li><p>The element name of the parent of the text node is in the set
of whitespace-preserving element names.</p></li><li><p>The text node contains at least one non-whitespace character.
As in XML, a whitespace character is #x20, #x9, #xD or #xA.</p><div><blockquote><p><b><a href="#issue-NEL-char">Issue 95 (NEL-char)</a>: </b>Should we make provision for XML 1.1 and its introduction of NEL as a whitespace character?</p></blockquote></div></li><li><p>An ancestor element of the text node has an
<code>xml:space</code> attribute with a value of
<code>preserve</code>, and no closer ancestor element has
<code>xml:space</code> with a value of
<code>default</code>.</p></li></ul><p>Otherwise, the text node is stripped.</p><p>The <code>xml:space</code> attributes are not removed from the
tree.</p><blockquote><table width="90%"><tr><td width="10%" align="left" valign="top"><b>Note:</b></td><td align="left" valign="top"><p>This implies that if an <code>xml:space</code> attribute is
specified on a <a title="literal result element" href="#dt-literal-result-element">literal result element</a>, 
it will be included in the result.</p></td></tr></table></blockquote><p>For stylesheets, the set of whitespace-preserving element names
consists of just <a href="#element-text"><code>xsl:text</code></a>.</p><p>Processing instructions and comments in a stylesheet module are ignored:
the stylesheet module is treated as if the processing instructions and
comments were not there. This also means that sibling text nodes that are separated
by a processing instruction or comment in a stylesheet module are concatenated
into a single text node; and a text node is classified as a whitespace text node
for the purpose of whitespace stripping only after
this concatenation has taken place.</p><p>The content model for some XSLT elements (for example
 <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> and <a href="#element-choose"><code>xsl:choose</code></a>) does not permit text nodes
 as children of these elements. If the <code>xml:space="preserve"</code> attribute
  is used to suppress the stripping of whitespace text nodes within such elements,
  then any whitespace used for the layout of such elements will be retained in the
  stylesheet tree in the form of whitespace text nodes. Such text nodes must not be reported
  as an error. <a name="d5e3504"><small>[ERR024] </small></a>Within an XSLT element that is required to be empty,
  any content other than comments or processing instructions, including any whitespace-only
  text node preserved using the <code>xml:space="preserve"</code> attribute, is a
  <a title="static error" href="#dt-static-error">static error</a>.
				</p><p class="element-syntax"><a name="element-strip-space"></a><code>&lt;!-- Category: declaration --&gt;<br>&lt;xsl:strip-space<br>&nbsp;&nbsp;<b>elements</b> = <var>tokens</var>&nbsp;/&gt;</code></p><p class="element-syntax"><a name="element-preserve-space"></a><code>&lt;!-- Category: declaration --&gt;<br>&lt;xsl:preserve-space<br>&nbsp;&nbsp;<b>elements</b> = <var>tokens</var>&nbsp;/&gt;</code></p><p>For source documents, the set of
whitespace-preserving element names is specified by
<a href="#element-strip-space"><code>xsl:strip-space</code></a> and <a href="#element-preserve-space"><code>xsl:preserve-space</code></a>
					<a title="declaration" href="#dt-declaration">declarations</a>.  Whether an
element name is included in the set of whitespace-preserving names is
determined by the best match amongst <a href="#element-strip-space"><code>xsl:strip-space</code></a> or
<a href="#element-preserve-space"><code>xsl:preserve-space</code></a> declarations: it is included if and only
if there is no match or the best match is an
<a href="#element-preserve-space"><code>xsl:preserve-space</code></a> element.  The
<a href="#element-strip-space"><code>xsl:strip-space</code></a> and <a href="#element-preserve-space"><code>xsl:preserve-space</code></a>
elements each have an <code>elements</code> attribute whose value is a
whitespace-separated list of <u>NameTest</u>s; an element name matches an
<a href="#element-strip-space"><code>xsl:strip-space</code></a> or <a href="#element-preserve-space"><code>xsl:preserve-space</code></a>
element if it matches one of the <u>NameTest</u>s. 
An element matches a <u>NameTest</u> if and only if the <u>NameTest</u> would be true for the
element as an XPath node test.  When more than one <a href="#element-strip-space"><code>xsl:strip-space</code></a> and
<a href="#element-preserve-space"><code>xsl:preserve-space</code></a> element matches, the best matching
element is determined by the best matching <u>NameTest</u>.  This is determined in the
same way as with <a title="template rule" href="#dt-template-rule">template rules</a>:</p><ul><li><p>First, any match with lower <a title="import precedence" href="#dt-import-precedence">import precedence</a> than another
match is ignored.</p></li><li><p>Next, any match that has a lower
<a title="default priority" href="#dt-default-priority">default priority</a> than the
<a title="default priority" href="#dt-default-priority">default priority</a> of
another match is ignored.</p></li></ul><p>
					<a name="d5e3606"><small>[ERR025] </small></a>It is an <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> if
 this 
 leaves more than one match.  The <a title="processor" href="#dt-processor">processor</a> must either signal the error,
of must recover by choosing, from amongst the matches that are left, the
one that occurs last in
 <a title="declaration order" href="#dt-declaration-order">declaration order</a>.
 
					
				</p><blockquote><table width="90%"><tr><td width="10%" align="left" valign="top"><b>Note:</b></td><td align="left" valign="top"><p>A source document is supplied as input to the XSLT
<a title="processor" href="#dt-processor">processor</a> in the form of a tree. 
Nothing in this specification states that
this tree must be built by parsing an XML document; nor does it state that
the application that constructs the tree is required to treat whitespace 
in any particular way. The provisions in this section relate only to whitespace
text nodes that are present in the tree supplied as input to the processor.
In particular, the processor cannot preserve whitespace text nodes unless they were
actually present in the supplied tree.</p></td></tr></table></blockquote></div><div class="div2">
<h3><a name="namespace-fixup" id="namespace-fixup"></a>4.4 Namespace Fixup</h3><p>
					<em>Refinement</em>
				</p><p>In a tree supplied to or constructed by an XSLT processor, the following
constraints relating to namespace nodes must be satisfied in addition to those 
specified in <a href="#DATAMODEL">[Data Model]</a>:</p><ul><li><p>If an element node has an <a title="expanded-QName" href="#dt-expanded-qname">expanded-QName</a> with a non-null
namespace URI, then that element node must have at least one namespace
node whose string-value is the same as that namespace URI.</p></li><li><p>If an attribute node has an <a title="expanded-QName" href="#dt-expanded-qname">expanded-QName</a> with a non-null
namespace URI, then the parent element of that attribute must have at
least one namespace node whose string-value is the same as that
namespace URI and whose name is non-empty.</p></li><li><p>If an element node has a namespace node 
whose name is non-empty,						
						then every child element of that element
must also have a namespace node with that <a title="expanded-QName" href="#dt-expanded-qname">expanded-QName</a> (possibly with
a different string-value).</p><blockquote><table width="100%"><tr><td width="10%" align="left" valign="top"><b>Ed. Note:</b></td><td align="left" valign="top">This rule is based on the rules in XML Namespaces 1.0, and no longer applies
 in version 1.1. The XSL Working Group intends to examine the impact of the XML Namespaces 1.1
 proposal in a subsequent draft.</td></tr></table></blockquote></li><li><p>Every element must have a namespace node whose <a title="expanded-QName" href="#dt-expanded-qname">expanded-QName</a> has
local-part <code>xml</code> and whose string-value is
<code>http://www.w3.org/XML/1998/namespace</code>.</p></li><li><p>If an element or attribute is annotated with the type <code>xs:QName</code>, or a type derived
					from <code>xs:QName</code>, then that element, or the element containing that attribute, must have
					a namespace node whose string value is the same as the namespace URI of that QName value.</p></li></ul><p>
				<a name="dt-namespace-fixup" id="dt-namespace-fixup" title="namespace fixup"></a>The rules for the individual XSLT instructions that 
				construct a result tree (see <a href="#creating-new-nodes"><b>11 Creating New Nodes</b></a>) prescribe some of the situations
				in which namespace nodes are written to the tree. These rules, however, are not sufficient
				to ensure that the above constraints are always satisfied. The XSLT processor must therefore
				add additional namespace nodes to satisfy these constraints. This process is referred to
				as <b>namespace fixup</b>.</p><p>The actual namespace nodes that are added to the tree by the namespace fixup process are
				implementation-defined, provided firstly, that at the end of the process the above constraints
				must all be satisfied, and secondly, that a namespace node must not be added to the tree unless the namespace
				node is necessary either to satisfy these constraints, or to enable the tree to be serialized using 
				the original namespace prefixes from the source document or stylesheet.</p><blockquote><table width="100%"><tr><td width="10%" align="left" valign="top"><b>Ed. Note:</b></td><td align="left" valign="top">The above is a reformulation of the rules given in earlier drafts: it is intended to
				reflect the intent of the previous rules while leaving the detail to the implementor.</td></tr></table></blockquote><p>Namespace fixup must not result in an element having multiple
namespace nodes with the same <a title="expanded-QName" href="#dt-expanded-qname">expanded-QName</a>.</p><p>Namespace fixup is performed in two situations:</p><ul><li><p>It is applied to a result tree, before the result tree is 
made available to the calling application (whether by serialization
or otherwise: see <a href="#serialization"><b>20 Serialization</b></a>).</p></li><li><p>It is applied to a
 <a title="" href="#dt-temporary-tree">temporary tree</a>,
 before the temporary tree is made available for processing by stylesheet instructions.
 (see <a href="#temporary-trees"><b>9.4 Temporary Trees</b></a>).</p></li></ul><p>There is no requirement to perform namespace fixup for any source
document, that is, for a document in the 
<a title="initial input sequence" href="#dt-initial-input-sequence">initial input sequence</a>, a document
loaded using the <u>fn:document</u> or <u>fn:collection</u> function,
a document supplied as the value of a
 <a title="stylesheet parameter" href="#dt-stylesheet-parameter">stylesheet parameter</a>, or a document
returned by an <a title="extension function" href="#dt-extension-function">extension function</a>.
<a name="d5e3839"><small>[ERR026] </small></a>It is a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> if
 such a document  does
  not already
satisfy the constraints listed above . 
The <a title="processor" href="#dt-processor">processor</a> may signal the error,
or may recover by performing namespace fixup, 
or may produce <a title="implementation-dependent" href="#dt-implementation-dependent">implementation-dependent</a>
 results.
					
				</p></div><div class="div2">
<h3><a name="d-o-e-in-data-model" id="d-o-e-in-data-model"></a>4.5 Disable Output Escaping</h3><div><blockquote><p><b><a href="#issue-restrict-d-o-e">Issue 15 (restrict-d-o-e)</a>: </b>It is proposed that we should restrict the use of disable-output-escaping 
      so it can only be used on a final result tree. This would avoid distorting the data model.</p></blockquote></div><blockquote><table width="100%"><tr><td width="10%" align="left" valign="top"><b>Ed. Note:</b></td><td align="left" valign="top">The Working Group has decided in principle to resolve the above issue by
                disallowing <code>disable-output-escaping</code> when writing nodes to a temporary tree;
                it will be allowed only when writing to a final result tree that is serialized. The use cases
                for "sticky disable-output-escaping" will be satisfied by a new facility that allows user
                control over the way that individual characters are serialized, perhaps in the form of a new
                <code>xsl:character-representation</code> element defined as a child of <a href="#element-output"><code>xsl:output</code></a>.
                This means that the requirement to support a disable-output-escaping bit in the data model
                will disappear, and this section will therefore no longer be needed.</td></tr></table></blockquote><p>If an <a title="implementation" href="#dt-implementation">implementation</a> supports 
the <code>disable-output-escaping</code> attribute
of <a href="#element-text"><code>xsl:text</code></a>, <a href="#element-value-of"><code>xsl:value-of</code></a>
					, and <a href="#element-attribute"><code>xsl:attribute</code></a>
					
 (see <a href="#disable-output-escaping"><b>20.5 Disabling Output Escaping</b></a>), then the data model
for trees constructed by the <a title="processor" href="#dt-processor">processor</a> is augmented with a boolean value
representing the value of this property.</p><p>Conceptually, each character in a text node on a result tree, and each attribute node, has a boolean
property indicating whether the serializer should disable the normal rules
for escaping of special characters (for example, outputting of <code>&amp;</code>
as <code>&amp;amp;</code>) in respect of this character or attribute node.</p><p>This property is preserved when a text or attribute 
node is copied using <a href="#element-copy"><code>xsl:copy</code></a>
or <a href="#element-copy-of"><code>xsl:copy-of</code></a>.</p><blockquote><table width="90%"><tr><td width="10%" align="left" valign="top"><b>Note:</b></td><td align="left" valign="top"><p>There are many ways an implementation can avoid the overhead
of actually storing a boolean flag with every character.</p></td></tr></table></blockquote></div></div><div class="div1">
<h2><a name="constructs" id="constructs"></a>5 Syntactic Constructs</h2><div class="div2">
<h3><a name="qname" id="qname"></a>5.1 Qualified Names</h3><p>The name of a stylesheet-defined object, specifically a <a title="named template" href="#dt-named-template">named template</a>,
 a <a title="mode" href="#dt-mode">mode</a>,
 an <a title="attribute set" href="#dt-attribute-set">attribute set</a>, 
 a <a title="key" href="#dt-key">key</a>,
a named <a title="sort specification" href="#dt-sort-specification">sort specification</a>,
a <a title="decimal-format" href="#dt-decimal-format">decimal-format</a>,
 a <a title="variable" href="#dt-variable">variable</a> or <a title="parameter" href="#dt-parameter">parameter</a>,
a <a title="stylesheet function" href="#dt-stylesheet-function">stylesheet function</a>, or a
named <a title="output definition" href="#dt-output-definition">output definition</a>,
is specified as a <a title="QName" href="#dt-qname">QName</a>.</p><p>
					<a name="dt-qname" id="dt-qname" title="QName"></a>A <b>QName</b> is
always written in the form <code>(NCName ":")? NCName</code>, that is, a local name
optionally preceded by a namespace prefix. When two QNames are compared, however,
they are considered equal if the corresponding
 <a title="expanded-QName" href="#dt-expanded-qname">expanded-QNames</a> are the same.
				</p><p>
					<a name="dt-expanded-qname" id="dt-expanded-qname" title="expanded-QName"></a>An
<b>expanded-QName</b> is a pair of values containing a local name and an optional namespace URI.
A QName is expanded by replacing the namespace prefix with the corresponding namespace URI,
from the namespace declarations that are in scope at the point where the QName is written.
Two expanded-QNames are equal if the namespace URIs are the same 
(or both absent) and the local names are the
same.
				</p><p>
					<a name="d5e4004"><small>[ERR027] </small></a>It is a <a title="static error" href="#dt-static-error">static error</a>
to use a reserved namespace URI in the name of any stylesheet-defined object. The reserved namespaces are 
listed in <a href="#xslt-namespace"><b>3.1 XSLT Namespace</b></a>.
				</p><p>QNames may occur 
				either as the value of an attribute node in a stylesheet
module, or within an XPath <a title="expression" href="#dt-expression">expression</a> contained in such an attribute node, or as the result
of evaluating an XPath expression contained in such an attribute node. The element
containing this attribute node is referred to as the defining element of the QName.</p><p>If the QName has a prefix, then the
prefix is expanded into a URI reference using the namespace
declarations in effect on its defining element.  The
<a title="expanded-QName" href="#dt-expanded-qname">expanded-QName</a>
consisting of the local part of the name and the possibly null URI
reference is used as the name of the object.  The default namespace (as defined by
a namespace declaration of the form <code>xmlns="some.uri"</code>) is
<em>not</em> used for unprefixed names.</p><p>In the case of an unprefixed QName used as a
				 <code>NameTest</code> within an XPath <a title="expression" href="#dt-expression">expression</a>
(see <a href="#expressions"><b>5.2 Expressions</b></a>) or within a pattern (see <a href="#patterns"><b>5.3 Patterns</b></a>), 
or in the <code>elements</code> attribute of the <a href="#element-strip-space"><code>xsl:strip-space</code></a>
and <a href="#element-preserve-space"><code>xsl:preserve-space</code></a> instructions, the namespace
to be used in expanding the QName may be specified by means of the <code>[xsl:]default-xpath-namespace</code>
attribute, as specified in <a href="#unprefixed-qnames"><b>5.4 Unprefixed Names in Expressions and Patterns</b></a>.</p><p>
					<a name="d5e4060"><small>[ERR028] </small></a>In the case of a <a title="QName" href="#dt-qname">QName</a> 
used as the value of an attribute in the
stylesheet, or appearing within the text of an XPath <a title="expression" href="#dt-expression">expression</a> in the the stylesheet,
it is a <a title="static error" href="#dt-static-error">static error</a> if the defining element has
no namespace node whose name matches the prefix of the <a title="QName" href="#dt-qname">QName</a>.
				</p><p>
					<a name="d5e4077"><small>[ERR029] </small></a>In the case of a <a title="QName" href="#dt-qname">QName</a> produced by evaluating 
an XPath <a title="expression" href="#dt-expression">expression</a>,
it is a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> if the defining element has
no namespace node whose name matches the prefix of the <a title="QName" href="#dt-qname">QName</a>. The error is a dynamic error
even if the value of the expression is known statically, for example if the QName is written
as a string literal. The required action depends on the defining
element.
					
				</p></div><div class="div2">
<h3><a name="expressions" id="expressions"></a>5.2 Expressions</h3><p>XSLT uses the expression language defined by XPath 2.0 <a href="#XPATH20">[XPath 2.0]</a>.  
Expressions are used in XSLT for a variety of purposes including:</p><ul><li><p>selecting nodes for processing;</p></li><li><p>specifying conditions for different ways of processing a node;</p></li><li><p>generating text to be inserted in the result tree.</p></li></ul><p>
					<a name="dt-expression" id="dt-expression" title="expression"></a>Within this specification, the term
<b>XPath expression</b>, or simply <b>expression</b>, means
a string that matches the production <u>ExprSequence</u>
defined in <a href="#XPATH20">[XPath 2.0]</a>.
				</p><blockquote><table width="100%"><tr><td width="10%" align="left" valign="top"><b>Ed. Note:</b></td><td align="left" valign="top">This usage of the term <b>expression</b> is not aligned with the 
				terminology used in the XPath specification itself. An <b>ExprSequence</b> is defined there as a sequence
				of one or more expressions separated by commas.</td></tr></table></blockquote><p>An XPath expression may occur as the value of certain attributes on
XSLT-defined elements, and also within curly braces in
 <a title="attribute value template" href="#dt-attribute-value-template">attribute value
templates</a>.</p><p>
<a name="d5e4144"><small>[ERR030] </small></a>Except where otherwise stated, it is a 
<a title="static error" href="#dt-static-error">static error</a>
if the value of such an 
attribute, or the text between curly
braces in an attribute value template, does not match the
XPath production <u>ExprSequence</u>, or if it fails to satisfy
other static constraints defined in the XPath specification, for example
that all variable references must refer to <a title="variable" href="#dt-variable">variables</a> that are
in scope.
				</p><p><a name="d5e4165"><small>[ERR031] </small></a>The transformation fails with a
 <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> if any XPath
  <a title="expression" href="#dt-expression">expression</a>
 is evaluated and raises a dynamic error. The
  <a title="processor" href="#dt-processor">processor</a> must signal the error.</p><p>
					<a name="dt-required-type" id="dt-required-type" title="required type"></a>The context within a stylesheet
where an XPath <a title="expression" href="#dt-expression">expression</a>
 appears may specify the <b>required type</b> of
the expression. The required type indicates the data type of value that the
expression is expected to return. If no required type is specified, the
expression may return any value: in effect, the required type is then <code>item*</code>.
				</p><p><a name="dt-argument-conversion-rules" id="dt-argument-conversion-rules" title="argument conversion rules"></a>Except where otherwise indicated, the actual
value of an <a title="expression" href="#dt-expression">expression</a> is converted to the <a title="required type" href="#dt-required-type">required type</a>
using the <b>argument conversion rules</b>. These are the rules defined in
<a href="#XPATH20">[XPath 2.0]</a> for converting the supplied argument of a function call to the
required type of that argument, as defined in the function signature. The relevant
rules are those that apply when the "XPath 1.0 backwards compatibility flag" is not set.</p><p>
					<a name="d5e4211"><small>[ERR032] </small></a>It is a 
<a title="type errors" href="#dt-type-error">type error</a>
if an XPath <a title="expression" href="#dt-expression">expression</a> raises a type error, or if the type
of the XPath expression is incompatible with the
<a title="required type" href="#dt-required-type">required type</a>. 
The processor must either signal a type error
as a <a title="static error" href="#dt-static-error">static error</a>, 
or must attempt to recover by converting
the result of the expression to the required type using the
<a title="argument conversion rules" href="#dt-argument-conversion-rules">argument conversion rules</a>; 
if conversion is not possible under these
rules, the processor must signal a
<a title="dynamic error" href="#dt-dynamic-error">dynamic error</a>
						
					
				</p><p>The context for evaluation of an XPath <a title="expression" href="#dt-expression">expression</a> is determined according
to the following rules. The context has two parts: 
the static context, and the dynamic expression evaluation context.</p><p>The <b>static context</b> depends on the element in the stylesheet
that contains the attribute holding the XPath expression ("the containing element") as follows:</p><ul><li></li><li><p>The <em>in-scope namespaces</em> are the namespace declarations that are
in scope for the containing element.</p></li><li><p>The <em>default namespace for element names</em> is the namespace defined by the
innermost <code>[xsl:]default-xpath-namespace</code> attribute, as described in
<a href="#unprefixed-qnames"><b>5.4 Unprefixed Names in Expressions and Patterns</b></a>. The value of this attribute
is a namespace URI.</p></li><li><p>The <em>default namespace for function names</em> is the 

								<a title="standard function namespace" href="#dt-standard-function-namespace">standard function namespace</a>
							,
defined in <a href="#FANDO">[Functions and Operators]</a>. This means that it is not necessary to declare this
namespace in the stylesheet, nor to use the prefix <code>xf</code> used in the
specification of the core functions.</p></li><li><p>The <em>in-scope type definitions</em>
includes the built-in types of XML Schema (see <a href="#XMLSCHEMA">[XML Schema]</a>), plus
any types imported using the <a href="#element-import-schema"><code>xsl:import-schema</code></a>
declaration.</p></li><li><p>The <em>in-scope variables</em> are the
						 <a title="variable-binding element" href="#dt-variable-binding-element">variable binding elements</a> that are in scope
for the containing element (see <a href="#variables-and-parameters"><b>9 Variables and Parameters</b></a>).</p></li><li><p>The <em>in-scope functions</em> are the core functions defined by XPath, the additional
functions defined in this specification, the <a title="stylesheet function" href="#dt-stylesheet-function">stylesheet
functions</a> defined in the stylesheet, plus any <a title="extension function" href="#dt-extension-function">extension
functions</a> bound using <a title="implementation-defined" href="#dt-implementation-defined">implementation-defined</a> 
mechanisms (see <a href="#extension"><b>18 Extensibility and Fallback</b></a>).
<a name="d5e4338"><small>[ERR033] </small></a>It is a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> for
an <a title="expression" href="#dt-expression">expression</a> to call any function that is not included in the in-scope functions.
The <a title="processor" href="#dt-processor">processor</a> must signal the error,
but only if the function call is actually evaluated.
							
						</p></li><li><p>The <em>in-scope collations</em> are 
<a title="implementation-defined" href="#dt-implementation-defined">implementation-defined</a>.</p></li><li><p>The <em>default collation</em> is 
<a title="implementation-defined" href="#dt-implementation-defined">implementation-defined</a>.</p><blockquote><table width="90%"><tr><td width="10%" align="left" valign="top"><b>Note:</b></td><td align="left" valign="top"><p>Implementations should provide a mechanism allowing the user to select the default
collation for a transformation.</p></td></tr></table></blockquote></li><li><p>The <em>base URI</em> is the base URI of the containing element.</p></li></ul><blockquote><table width="100%"><tr><td width="10%" align="left" valign="top"><b>Ed. Note:</b></td><td align="left" valign="top">The way in which the XPath 2.0 backwards compatibility
				flag is set has yet to be determined.</td></tr></table></blockquote><p>The <b>evaluation context</b>, which includes the <b>focus</b>,
is determined as follows:</p><ul><li><p>The <em>variable values</em> are the current values of the in-scope 
						<a title="variable-binding element" href="#dt-variable-binding-element">variable binding elements</a>.</p></li></ul><p>Where the containing element is an <a title="instruction" href="#dt-instruction">instruction</a>
or a <a title="literal result element" href="#dt-literal-result-element">literal result element</a>, 
the <b>focus</b> is established as follows. In other cases, the rules are given for the
specific containing element.</p><ul><li><p>The initial context item, context position, and context size 
for the XPath <a title="expression" href="#dt-expression">expression</a> are the same as
the 
							<a title="context item" href="#dt-context-item">context item</a>,
<a title="context position" href="#dt-context-position">context position</a>, and
<a title="context size" href="#dt-context-size">context size</a> for the 
evaluation of the containing instruction or literal result element. (Note that these
values may change for evaluation of sub-expressions within the XPath <a title="expression" href="#dt-expression">expression</a>,
according to the XPath rules.)</p></li></ul></div><div class="div2">
<h3><a name="patterns" id="patterns"></a>5.3 Patterns</h3><p>A <a title="template rule" href="#dt-template-rule">template rule</a> identifies the
nodes to which it applies by means of a pattern.  As well as
being used in template rules, patterns are used for numbering (see
<a href="#number"><b>12 Numbering</b></a>), for grouping (see
<a href="#grouping"><b>14 Grouping</b></a>), 
 and for declaring <a title="" href="#key">keys</a> (see <a href="#key"><b>16.3 Keys</b></a>).</p><p>
					<a name="dt-pattern" id="dt-pattern" title="pattern"></a>A <b>pattern</b> specifies
 a set of conditions on a node. A
node that satisfies the conditions matches the pattern; a node that
does not satisfy the conditions does not match the pattern.  The
syntax for patterns is a subset of the syntax for <a title="expression" href="#dt-expression">expressions</a>. 
As explained in detail below, a node matches a pattern
 if the node can be selected by evaluating this expression with
respect to some possible context.</p><div class="example"><p>Here are some examples of patterns:</p><ul><li><p>
								<code>para</code> matches any <code>para</code> element</p></li><li><p>
								<code>*</code> matches any element</p></li><li><p>
								<code>chapter|appendix</code> matches any
<code>chapter</code> element and any <code>appendix</code>
element</p></li><li><p>
								<code>olist/item</code> matches any <code>item</code> element with
an <code>olist</code> parent</p></li><li><p>
								<code>appendix//para</code> matches any <code>para</code> element with
an <code>appendix</code> ancestor element</p></li><li><p>
								<code>/</code> matches the document node
 of any source document</p></li><li><p>
								<code>text()</code> matches any text node</p></li><li><p>
								<code>node()</code> matches any node other than an attribute
node, namespace node, or document node</p></li><li><p>
								<code>fn:id("W11")</code> matches the element with unique ID
<code>W11</code>
							</p></li><li><p>
								<code>para[1]</code> matches any <code>para</code> element
that is the first <code>para</code> child element of its
parent</p></li><li><p>
								<code>item[fn:position() mod 2 = 1]</code> matches any
<code>item</code> element that is an odd-numbered <code>item</code>
child of its parent.</p></li><li><p>
								<code>div[@class="appendix"]//p</code> matches any
<code>p</code> element with a <code>div</code> ancestor element that
has a <code>class</code> attribute with value
<code>appendix</code>
							</p></li><li><p>
								<code>@class</code> matches any <code>class</code> attribute
(<em>not</em> any element that has a <code>class</code>
attribute)</p></li><li><p>
								<code>@*</code> matches any attribute node</p></li></ul></div><div><blockquote><p><b><a href="#issue-type-matching-in-patterns">Issue 110 (type-matching-in-patterns)</a>: </b>The current syntax for matching elements of a particular type is cumbersome,
      for example <code>match="*[. instance of element us-address of type address]"</code>.</p></blockquote></div><p>
					<a name="d5e4621"><small>[ERR034] </small></a>Where an attribute is
defined to contain a <a title="pattern" href="#dt-pattern">pattern</a>,
it is a <a title="static error" href="#dt-static-error">static error</a> if the
 pattern does not match the production <a href="#NT-Pattern">Pattern</a>.
  Every pattern is a legal XPath
<a title="expression" href="#dt-expression">expression</a>, but the converse is not true: <code>2+2</code>
is an example of a legal XPath expression that is not a pattern.
The XPath expressions that can be used as patterns are those that
match the grammar for <a href="#NT-Pattern">Pattern</a>, given below.</p><p>Informally, a <a href="#NT-Pattern">Pattern</a> is
a set of path expressions separated by <code>|</code>, where each step
in the path expression is constrained to be an <u>AxisStepExpr</u> that uses only the
<code>child</code> or <code>attribute</code> axes.  Patterns may
also use the <code>//</code> operator, and they may start with an
<u>fn:id</u> or <a href="#function-key"><b>key</b></a> function call,
provided that the value to be matched is supplied as either a literal or a reference to
a <a title="variable" href="#dt-variable">variable</a> or <a title="parameter" href="#dt-parameter">parameter</a>, 
and the key name (in the case of the <a href="#function-key"><b>key</b></a> function)
is supplied as a string literal.
 Predicates in a pattern (the construct enclosed between square brackets)
can contain arbitrary XPath expressions in the same way as predicates in a path expression.</p><p>If a pattern occurs in part of the stylesheet where
<a title="backwards compatible behavior" href="#dt-backwards-compatible-behavior">backwards compatible behavior</a>
is enabled (see <a href="#backwards"><b>3.6 Backwards-Compatible Processing</b></a>), then the pattern is restricted to use the syntax for patterns defined
in XSLT 1.0, and will match a node if and only if it would have matched that node
under the rules defined in XSLT 1.0.</p>
<h5><a name="d5e4689" id="d5e4689"></a>Patterns</h5><table class="scrap" summary="Scrap"><tbody><tr valign="baseline"><td><a name="NT-Pattern" id="NT-Pattern"></a>[1]&nbsp;&nbsp;&nbsp;</td><td><code>Pattern</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>
								<a href="#NT-PathPattern">PathPattern</a>
							</code></td></tr><tr valign="baseline"><td></td><td></td><td></td><td><code>| <a href="#NT-Pattern">Pattern</a> ('|' | 'union') <a href="#NT-PathPattern">PathPattern</a>
							</code></td></tr><tr valign="baseline"><td><a name="NT-PathPattern" id="NT-PathPattern"></a>[2]&nbsp;&nbsp;&nbsp;</td><td><code>PathPattern</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>
								<a href="#NT-RelativePathPattern">RelativePathPattern</a>
							</code></td></tr><tr valign="baseline"><td></td><td></td><td></td><td><code>| '/' <a href="#NT-RelativePathPattern">RelativePathPattern</a>?</code></td></tr><tr valign="baseline"><td></td><td></td><td></td><td><code>| '//' <a href="#NT-RelativePathPattern">RelativePathPattern</a>
							</code></td></tr><tr valign="baseline"><td></td><td></td><td></td><td><code>| <a href="#NT-IdKeyPattern">IdKeyPattern</a> (('/' | '//') <a href="#NT-RelativePathPattern">RelativePathPattern</a>)?</code></td></tr><tr valign="baseline"><td><a name="NT-RelativePathPattern" id="NT-RelativePathPattern"></a>[3]&nbsp;&nbsp;&nbsp;</td><td><code>RelativePathPattern</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>
								<a href="#NT-PatternStep">PatternStep</a> (('/' | '//') <a href="#NT-RelativePathPattern">RelativePathPattern</a>)?</code></td></tr><tr valign="baseline"><td><a name="NT-PatternStep" id="NT-PatternStep"></a>[4]&nbsp;&nbsp;&nbsp;</td><td><code>PatternStep</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>
								<a href="#NT-PatternAxis">PatternAxis</a>? <u>NodeTest</u> ( '[' <u>Expr</u> ']' )*</code></td></tr><tr valign="baseline"><td><a name="NT-PatternAxis" id="NT-PatternAxis"></a>[5]&nbsp;&nbsp;&nbsp;</td><td><code>PatternAxis</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>('child' '::' | 'attribute' '::' | '@') </code></td></tr><tr valign="baseline"><td><a name="NT-IdKeyPattern" id="NT-IdKeyPattern"></a>[6]&nbsp;&nbsp;&nbsp;</td><td><code>IdKeyPattern</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>'id' '(' <a href="#NT-IdKeyValue">IdKeyValue</a> ')'</code></td></tr><tr valign="baseline"><td></td><td></td><td></td><td><code>| 'key' '(' <u>StringLiteral</u> ',' <a href="#NT-IdKeyValue">IdKeyValue</a> ')'</code></td></tr><tr valign="baseline"><td><a name="NT-IdKeyValue" id="NT-IdKeyValue"></a>[7]&nbsp;&nbsp;&nbsp;</td><td><code>IdKeyValue</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>
								<u>Literal</u> | <u>Variable</u>
							</code></td></tr></tbody></table><p>The constructs <u>NodeTest</u>, 
<u>StringLiteral</u>, and
 <u>Expr</u> are part of the XPath expression
language, and are defined in <a href="#XPATH20">[XPath 2.0]</a>.</p><p>The meaning of a pattern is defined formally as follows. To determine whether
a node <var>N</var> matches a pattern <var>PAT</var>, evaluate the <a title="expression" href="#dt-expression">expression</a>
<code>//(<var>PAT</var>)</code> with a 
<a title="singleton focus" href="#dt-singleton-focus">singleton focus</a> based on <var>N</var>.
If the result is a sequence of nodes that includes <var>N</var>, then node <var>N</var>
matches the pattern; otherwise node <var>N</var> does not match the pattern.
This expression is constructed by textually inserting the pattern <var>PAT</var>
exactly as written in the stylesheet.</p><div class="example"><p>For example, <code>p</code> matches any <code>p</code> element,
because a <code>p</code> element will always be present in the result
of evaluating the <a title="expression" href="#dt-expression">expression</a> <code>//(p)</code>. Similarly, <code>/</code>
matches a document node, and only a document node, because the result of the 
<a title="expression" href="#dt-expression">expression</a> <code>//(/)</code>
						returns the document
node of the document containing the context node.
					</p></div><blockquote><table width="90%"><tr><td width="10%" align="left" valign="top"><b>Note:</b></td><td align="left" valign="top"><p>Although the semantics of patterns are specified formally in
terms of expression evaluation, it is possible to understand pattern
matching using a different model.  In a pattern, <code>|</code> indicates alternatives; a
pattern with one or more <code>|</code> separated alternatives matches
if any one of the alternatives matches.  A pattern such as <code>book/chapter/section</code>
can be examined from right to left. A node will only match this pattern
 if it is a <code>section</code> element;
and then, only if its parent is a <code>chapter</code>; and then, only
if the parent of that <code>chapter</code> is a <code>book</code>. When the
pattern uses the <code>//</code> operator, one can still read it from right to
left, but this time testing the ancestors of a node rather than its parent.
For example <code>appendix//section</code> matches every <code>section</code>
element that has an ancestor <code>appendix</code> element.</p><p>The formal definition, however, is useful for understanding the meaning
of a pattern such as <code>item[1]</code>. This matches any node selected
by the expression <code>//(item[1])</code>: that is, any <code>item</code>
element that is the first <code>item</code> child of its parent.</p></td></tr></table></blockquote><p>The pattern <code>node()</code> matches all nodes selected by the expression
<code>//(node())</code>, that is, all element, text, comment, and processing
instruction nodes. It does not match attribute or namespace nodes because the 
expression does not select nodes using the attribute or namespace axes.</p><blockquote><table width="90%"><tr><td width="10%" align="left" valign="top"><b>Note:</b></td><td align="left" valign="top"><p>An implementation, of course, may use any
algorithm it wishes for evaluating patterns, so long as the result corresponds
with the formal definition above. An implementation that followed the formal
semantics by evaluating the equivalent expression and then testing the membership of
a specific node in the result would probably be very inefficient.</p></td></tr></table></blockquote></div><div class="div2">
<h3><a name="unprefixed-qnames" id="unprefixed-qnames"></a>5.4 Unprefixed Names in Expressions and Patterns</h3><p>The attribute <code>[xsl:]default-xpath-namespace</code> 
(see <a href="#standard-attributes"><b>3.3 Standard Attributes</b></a>) may be used
on an element in the stylesheet to define the namespace that will be
used for an unprefixed name used as a <u>NameTest</u> within a step 
of an XPath <u>PathExpression</u>
or an XSLT <a href="#NT-Pattern">Pattern</a> 
or in the <code>elements</code> attribute of the <a href="#element-strip-space"><code>xsl:strip-space</code></a>
or <a href="#element-preserve-space"><code>xsl:preserve-space</code></a> instructions,
where the <u>NameTest</u> occurs in an attribute
of that stylesheet element or an attribute
of a descendant of that stylesheet element.
The value of the attribute is the namespace URI to be used.</p><div><blockquote><p><b><a href="#issue-default-xpath-keyword">Issue 147 (default-xpath-keyword)</a>: </b>Would it be better to name "default-xpath-namespace" as
    "default-element-namespace"? Raised by Jeni Tennison, see
    <a href="http://lists.w3.org/Archives/Member/w3c-xsl-wg/2002Oct/0006.html">http://lists.w3.org/Archives/Member/w3c-xsl-wg/2002Oct/0006.html</a><b> (members only) </b></p></blockquote></div><p>This default namespace URI applies only to a <u>NameTest</u> used with an axis whose
principal node type is elements: it does not apply when the step is using the attribute or namespace axis.
The default namespace URI for such a name is the value of the
<code>[xsl:]default-xpath-namespace</code> attribute on the innermost ancestor element that has
such an attribute, considering all ancestor elements of the attribute
 containing the XPath <a title="expression" href="#dt-expression">expression</a> or XSLT pattern. 
 The <code>[xsl:]default-xpath-namespace</code> attribute must be in the
 XSLT namespace if and only if its parent element is <em>not</em> in the XSLT namespace.</p><p>In the absence of this attribute, an unqualified <code>NameTest</code> (that
is, a <code>NameTest</code> that is an <code>NCName</code>) matches
an <a title="expanded-QName" href="#dt-expanded-qname">expanded-QName</a> whose namespace URI is null: the default namespace (as defined by
an <code>xmlns="some-uri"</code> declaration) is <em>not</em> used.</p><p>The <code>default-xpath-namespace</code> only affects unqualified names (names
containing no colon) used
in a <code>NameTest</code> within an <a title="expression" href="#dt-expression">expression</a> or pattern, and
unqualified names used in the <code>elements</code> attribute of the <a href="#element-strip-space"><code>xsl:strip-space</code></a>
and <a href="#element-preserve-space"><code>xsl:preserve-space</code></a> instructions.
It does not affect other names, for example function names,
variable names, or names used as arguments to the <a href="#function-key"><b>key</b></a> or
 <a href="#function-system-property"><b>system-property</b></a> functions.</p></div><div class="div2">
<h3><a name="attribute-value-templates" id="attribute-value-templates"></a>5.5 Attribute Value Templates</h3><p>
					<a name="dt-attribute-value-template" id="dt-attribute-value-template" title="attribute value template"></a>In an 
attribute that is designated as an
<b>attribute value template</b>, such as an attribute of a
<a title="literal result element" href="#dt-literal-result-element">literal result element</a>, 
an <a title="expression" href="#dt-expression">expression</a> can be used by surrounding
the expression with curly braces (<code>{}</code>).</p><p>An attribute value template consists of an alternating
sequence of fixed parts and variable parts. A variable part consists of
an XPath <a title="expression" href="#dt-expression">expression</a> enclosed
 in curly braces (<code>{}</code>). A fixed part
may contain any characters, except that a left curly brace must be written as 
<code>{{</code> and a right curly brace must be written as <code>}}</code>.</p><blockquote><table width="90%"><tr><td width="10%" align="left" valign="top"><b>Note:</b></td><td align="left" valign="top"><p>An expression within a variable part may contain an unescaped curly brace
within a <u>StringLiteral</u>. It may also
contain a construct, such as a comment, that is delimited by paired opening and closing
braces.
					</p></td></tr></table></blockquote><p>
					<a name="d5e5085"><small>[ERR035] </small></a>It is a <a title="static error" href="#dt-static-error">static error</a>
if a left curly brace appears in an attribute value template without a matching right
curly brace.
				</p><p>
					<a name="d5e5093"><small>[ERR036] </small></a>It is a <a title="static error" href="#dt-static-error">static error</a>
if the string contained between matching curly braces in an attribute value template
does not match the XPath production <u>Expr</u>.
				</p><p>
					<a name="d5e5104"><small>[ERR037] </small></a>It is a <a title="static error" href="#dt-static-error">static error</a> 
if a right curly brace occurs in an attribute value template outside an <a title="expression" href="#dt-expression">expression</a> 
without being followed by a second right curly brace.  
A right curly brace inside a <u>StringLiteral</u> in an expression is not
recognized as terminating the expression.</p><p>
					<a name="dt-effective-value" id="dt-effective-value" title="effective value"></a>The 
result of evaluating an attribute value template is referred to as the
<b>effective value</b> of the attribute. The effective value
is the string obtained by concatenating the expansions
of the fixed and variable parts. The expansion of a fixed part is obtained by
replacing any double curly braces (<code>{{</code> or <code>}}</code>) by the
corresponding single curly brace. The expansion of a variable part is obtained
by evaluating the enclosed XPath
<a title="expression" href="#dt-expression">expression</a> and converting the resulting value to a string.
This
conversion is done by <b>atomizing</b> the result of the expression using the
procedure defined in <a href="#XPATH20">[XPath 2.0]</a>,
and then converting each of the atomic values in the atomized sequence to a string, adding
a single space after each value other than the last. If the atomized sequence is empty, the result
is a zero-length string.
				</p><blockquote><table width="90%"><tr><td width="10%" align="left" valign="top"><b>Note:</b></td><td align="left" valign="top"><p>This may give a different result from XSLT 1.0. In XSLT 1.0, if the expression
returned a node-set, all nodes other than the first were ignored.</p></td></tr></table></blockquote><p>Curly braces are
not treated specially in an attribute value in an XSLT stylesheet unless the
attribute is specifically designated as one that permits an
attribute value template; in an element syntax summary, the value
of such attributes is surrounded by curly braces.</p><blockquote><table width="90%"><tr><td width="10%" align="left" valign="top"><b>Note:</b></td><td align="left" valign="top"><p>Not all attributes are interpreted as attribute value
templates.  Attributes whose value is an
 <a title="expression" href="#dt-expression">expression</a> or
  <a title="pattern" href="#dt-pattern">pattern</a>,
attributes of <a title="declaration" href="#dt-declaration">declaration</a> elements
and attributes that refer to named XSLT objects are not interpreted as
attribute value templates.   In addition, <code>xmlns</code> attributes
are not interpreted as attribute value templates: 
this is because they must be interpreted in the same way
 by the XML parser and the XSLT processor.
					</p></td></tr></table></blockquote><div class="example"><p>The following example creates an <code>img</code> result element
from a <code>photograph</code> element in the source; the value of the
<code>src</code> attribute of the <code>img</code> element is computed
from the value of the <code>image-dir</code> variable and the
string-value of the <code>href</code> child of the
<code>photograph</code> element; the value of the <code>width</code>
attribute of the <code>img</code> element is computed from the value
of the <code>width</code> attribute of the <code>size</code> child of
the <code>photograph</code> element:</p><div class="exampleInner"><pre>&lt;xsl:variable name="image-dir"&gt;/images&lt;/xsl:variable&gt;

&lt;xsl:template match="photograph"&gt;
&lt;img src="{$image-dir}/{href}" width="{size/@width}"/&gt;
&lt;/xsl:template&gt;</pre></div><p>With this source</p><div class="exampleInner"><pre>&lt;photograph&gt;
  &lt;href&gt;headquarters.jpg&lt;/href&gt;
  &lt;size width="300"/&gt;
&lt;/photograph&gt;</pre></div><p>the result would be</p><div class="exampleInner"><pre>&lt;img src="/images/headquarters.jpg" width="300"/&gt;</pre></div></div><p>&nbsp;</p><div class="example"><p>The following source:</p><div class="exampleInner"><pre>&lt;temperature readings="{10.32, 5.50, 8.31}"/&gt;</pre></div><p>produces the result:</p><div class="exampleInner"><pre>&lt;temperature readings="10.32 5.5 8.31"/&gt;</pre></div><p>Note that there is no requirement to surround the
					XPath <u>ExprSequence</u> with parentheses.</p></div><p>Curly braces are <em>not</em> recognized recursively inside
expressions.</p><div class="example"><p>For example:</p><div class="exampleInner"><pre>&lt;a href="#{id({@ref})/title}"&gt;</pre></div><p>is <em>not</em> allowed.  Instead, use simply:</p><div class="exampleInner"><pre>&lt;a href="#{id(@ref)/title}"&gt;</pre></div></div></div><div class="div2">
<h3><a name="content-constructors" id="content-constructors"></a>5.6 Content Constructors</h3><blockquote><table width="90%"><tr><td width="10%" align="left" valign="top"><b>Note:</b></td><td align="left" valign="top"><p>The term <em>content constructor</em>
replaces <em>template</em> as used in XSLT 1.0. 
The change is made partly for clarity (to avoid confusion
with <a title="template rule" href="#dt-template-rule">template rules</a> and
<a title="named template" href="#dt-named-template">named templates</a>), 
 but also to reflect a more formal definition of the semantics.
Whereas XSLT 1.0 described a template as a sequence of instructions that write
to the result tree, XSLT 2.0 describes a content constructor as something that can be
evaluated to return a sequence of nodes; what happens to these nodes depends on the containing
instruction.</p></td></tr></table></blockquote><p>Many XSLT elements (including
 <a title="literal result element" href="#dt-literal-result-element">literal result elements</a>) are defined to take as
their content a <em>content constructor</em>.</p><p>
					<a name="dt-content-constructor" id="dt-content-constructor" title="content constructor"></a>A <b>content
constructor</b> is a sequence of nodes in the stylesheet that 
is used to generate nodes in a result tree.
The new nodes become children, attributes, or namespaces of the
 <a title="current destination node" href="#dt-current-destination-node">current destination node</a>.
					
				</p><p>Informally, the nodes in a content constructor act as templates for nodes
to be added to a result tree. Some nodes (text nodes and literal result elements) are copied
directly from the stylesheet to the result tree. Other nodes (XSLT instructions and extension
instructions) are evaluated to produce new nodes, which are added to the result tree: for example, the
<a href="#element-element"><code>xsl:element</code></a> instruction produces an element node, and the <a href="#element-comment"><code>xsl:comment</code></a>
instruction produces a comment node.</p><p>When a document or element node <var>P</var> is added to the result tree by an instruction
that contains a content constructor <var>C</var>, then the content constructor <var>C</var> 
is evaluated with the
document or element node <var>P</var> as the <a title="current destination node" href="#dt-current-destination-node">current destination node</a>.
This means that a tree of instructions in the stylesheet causes the construction of a tree of nodes
in the result document.</p><div class="example"><p>For example, consider the following stylesheet fragment:</p><div class="exampleInner"><pre>&lt;td&gt;
&lt;xsl:attribute name="valign"&gt;top&lt;/xsl:attribute&gt;
&lt;xsl:value-of select="@description"/&gt;
&lt;/td&gt;</pre></div><p>This fragment consists of a literal result element <code>td</code>, acting as the parent of
a content constructor that consists of two instructions: <a href="#element-attribute"><code>xsl:attribute</code></a> and
<a href="#element-value-of"><code>xsl:value-of</code></a>. 
The <code>td</code> instruction causes a <code>td</code> element
to be created in the result tree as a child of the <a title="current destination node" href="#dt-current-destination-node">current
destination node</a>. The <a href="#element-attribute"><code>xsl:attribute</code></a> and
<a href="#element-value-of"><code>xsl:value-of</code></a> instructions are executed with this new <code>td</code> element as
the <a title="current destination node" href="#dt-current-destination-node">current
destination node</a>; the new attribute therefore becomes an attribute of the new <code>td</code> element,
while the text node created by the <a href="#element-value-of"><code>xsl:value-of</code></a> instruction becomes a child of the
<code>td</code> element.
						
					</p></div><p>Four kinds of nodes may be encountered in a content constructor:</p><ul><li><p>
							<em>Text nodes</em> appearing in the stylesheet (if they have not been
removed in the process of whitespace stripping: see <a href="#strip"><b>4.3 Whitespace Stripping</b></a>) are copied
 to create a new text node in the result sequence.</p></li><li><p>
							<a title="literal result element" href="#dt-literal-result-element">Literal result elements</a> 
are evaluated to create a new element node,
having the same name as the literal result element, which is added to the result
sequence: see <a href="#literal-result-element"><b>11.1 Literal Result Elements</b></a>
						</p></li><li><p>XSLT <a title="instruction" href="#dt-instruction">instructions</a> produce
a sequence of zero, one, or more nodes as their 
result. These nodes are added to the result sequence. Some instructions,
such as <a href="#element-element"><code>xsl:element</code></a>, return a newly constructed node (which may
have its own attributes, namespaces, children, and other descendants); others, such
as <a href="#element-if"><code>xsl:if</code></a>, return nodes produced by their own nested content
constructors.</p></li><li><p>
							<a title="extension instruction" href="#dt-extension-instruction">Extension instructions</a> 
also produce a sequence of nodes as their
result, which is added to the result sequence.</p></li></ul><p>The node sequences produced by each node in the content constructor are
concatenated to form a single result sequence. This concatenation retains the order
 of the nodes within the content constructor: if while evaluating a content constructor,
 node <var>M</var> is constructed by instruction <var>I</var>, and node <var>N</var>
  is constructed by a different instruction <var>J</var>,
   then <var>N</var> will appear after <var>M</var> in
   the result sequence if and only
  if <var>J</var> follows <var>I</var> in document order. This does not mean 
that the nodes in a content constructor must be evaluated sequentially: on the contrary, they
may be evaluated in any order, or in parallel, provided that their results are
assembled in the correct sequence on completion.</p><p>If the result sequence contains two or more adjacent text nodes, these
adjacent text nodes are concatenated to form a single text node.</p><p>The result sequence will never contain a document node.
<a name="d5e5487"><small>[ERR038] </small></a>It is an 
<a title="dynamic error" href="#dt-dynamic-error">dynamic error</a>
if an <a title="extension instruction" href="#dt-extension-instruction">extension instruction</a>
 attempts to return a sequence containing a document node.
 The <a title="processor" href="#dt-processor">processor</a> must signal the error.
					
				</p><p>
					<a name="d5e5504"><small>[ERR039] </small></a>It is a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> if
 the result sequence  
 (after concatenating the results of individual instructions) contains a namespace node or
 attribute node that is preceded
in the sequence by a node that is neither a namespace node nor an attribute node. 
The <a title="processor" href="#dt-processor">processor</a> must either signal
the error, or must recover by ignoring the offending namespace or attribute node.

					
				</p><p>
							<a name="d5e5567"><small>[ERR041] </small></a>Elements such as <a href="#element-variable"><code>xsl:variable</code></a>, <a href="#element-param"><code>xsl:param</code></a>,
<a href="#element-message"><code>xsl:message</code></a>, and <a href="#element-result-document"><code>xsl:result-document</code></a> construct a new document node,
, which becomes the <a title="current destination node" href="#dt-current-destination-node">current
destination node</a> for the nodes in the result sequence returned by the content constructor.
								In this case it is an <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a>
 if the result sequence contains namespace
or attribute nodes. The <a title="processor" href="#dt-processor">processor</a> must either signal the error, or must recover by ignoring the offending
nodes.
							 The elements, comments, processing instructions, and text nodes
in the node sequence form the children of the newly constructed document node.</p><p>Elements such as <a href="#element-element"><code>xsl:element</code></a>, <a href="#element-copy"><code>xsl:copy</code></a>,
and <a title="literal result element" href="#dt-literal-result-element">literal result elements</a> construct a new element node,
, which becomes the <a title="current destination node" href="#dt-current-destination-node">current
destination node</a> for the nodes in the result sequence returned by the content constructor.
							 The elements, comments, processing instructions, and text nodes
in the result sequence form the children of the newly constructed element node.</p><ul><li><p>If the result sequence contains two or more namespace nodes with the same name (or no name)
and the same string-value (that is, two namespace nodes mapping the same prefix to the same namespace URI), then
the duplicate nodes are ignored.</p><p><a name="d5e5628"><small>[ERR042] </small></a>It is a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> if
the result sequence contains two or more namespace nodes having the same name but different string-values (that is, 
namespace nodes that map the same prefix to different namespace URIs). The processor
must either signal the error, or must recover by ignoring all conflicting namespace nodes other than the one
that appears last in the result sequence.</p><p><a name="d5e5636"><small>[ERR043] </small></a>It is a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> if
the result sequence contains a namespace node with no name and the <a title="current destination node" href="#dt-current-destination-node">current destination node</a>
is an element with a null namespace URI (that is, to define a default namespace when the element is in no namespace).
In both cases the <a title="processor" href="#dt-processor">processor</a> must either signal the error,
    or must recover by ignoring the offending namespace node.</p></li><li><p>
    Any attribute nodes in the result sequence are added to the 
    
										<a title="current destination node" href="#dt-current-destination-node">current destination node</a>
									.
     If two or more attributes in the
    result sequence have the same <a title="expanded-QName" href="#dt-expanded-qname">expanded-QName</a>, the one that appears latest in the
    result sequence is the only one that is used.</p></li></ul><p>The <a href="#element-comment"><code>xsl:comment</code></a>, <a href="#element-attribute"><code>xsl:attribute</code></a>, 
<a href="#element-processing-instruction"><code>xsl:processing-instruction</code></a>, <a href="#element-text"><code>xsl:text</code></a>,
 and <a href="#element-namespace"><code>xsl:namespace</code></a> elements
 create nodes that cannot have children. In these
cases the result sequence produced by the content constructor is used to establish the
string-value of the new node.
<a name="d5e5684"><small>[ERR044] </small></a>It is a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> 
if the result sequence  contains nodes other
than text nodes. The <a title="processor" href="#dt-processor">processor</a> must either signal the error, or must recover by ignoring
the non-text nodes together with their content.
							
						</p><blockquote><table width="100%"><tr><td width="10%" align="left" valign="top"><b>Ed. Note:</b></td><td align="left" valign="top">The above text should be rewritten to provide a formal mapping to the 
constructor functions defined in the data model.</td></tr></table></blockquote></div></div><div class="div1">
<h2><a name="rules" id="rules"></a>6 Template Rules</h2><p>Template rules implement the <em>push processing</em> model
described in <a href="#push-processing"><b>2.4.1 Push Processing Instructions</b></a>.</p><div class="div2">
<h3><a name="d5e5729" id="d5e5729"></a>6.1 Defining Template Rules</h3><p class="element-syntax"><a name="element-template"></a><code>&lt;!-- Category: declaration --&gt;<br>&lt;xsl:template<br>&nbsp;&nbsp;match = <var>pattern</var><br>&nbsp;&nbsp;name = <var>qname</var><br>&nbsp;&nbsp;priority = <var>number</var><br>&nbsp;&nbsp;mode = <var>tokens</var>&gt;<br>&nbsp;&nbsp;&lt;!-- Content: (<a href="#element-param">xsl:param</a>*, <var>content-constructor</var>) --&gt;<br>&lt;/xsl:template&gt;</code></p><p>A <a title="template rule" href="#dt-template-rule">template rule</a> is specified with the <a href="#element-template"><code>xsl:template</code></a>
element. The <code>match</code> attribute is a <a href="#NT-Pattern">Pattern</a> that identifies the source node or nodes
to which the rule applies.  The <code>match</code> attribute is
required unless the <a href="#element-template"><code>xsl:template</code></a> element has a
<code>name</code> attribute (see <a href="#named-templates"><b>10.1 Named Templates</b></a>).
 The result of applying the template rule is the
 result of evaluating the content constructor contained in the 
 <a href="#element-template"><code>xsl:template</code></a> element, with the matching node used
 as the <a title="context node" href="#dt-context-node">context node</a>
				</p><div class="example"><p>For example, an XML document might contain:</p><div class="exampleInner"><pre>This is an &lt;emph&gt;important&lt;/emph&gt; point.</pre></div><p>The following <a title="template rule" href="#dt-template-rule">template rule</a> matches <code>emph</code> elements and
produces a <code>fo:wrapper</code> formatting object with a
<code>font-weight</code> property of <code>bold</code>.</p><div class="exampleInner"><pre>&lt;xsl:template match="emph"&gt;
  &lt;fo:wrapper font-weight="bold"&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/fo:wrapper&gt;
&lt;/xsl:template&gt;
</pre></div><blockquote><table width="90%"><tr><td width="10%" align="left" valign="top"><b>Note:</b></td><td align="left" valign="top"><p>Examples in this document use the <code>fo:</code> prefix for
the namespace <code>http://www.w3.org/1999/XSL/Format</code>, which is
the namespace of the formatting objects defined in <a href="#XSLFO">[XSL Formatting Objects]</a>.</p></td></tr></table></blockquote></div><p>As described in the next section, the <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> element
can be used to process the children of a source element, and their children, recursively.</p></div><div class="div2">
<h3><a name="d5e5820" id="d5e5820"></a>6.2 Applying Template Rules</h3><p class="element-syntax"><a name="element-apply-templates"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:apply-templates<br>&nbsp;&nbsp;select = <var>node-sequence-expression</var><br>&nbsp;&nbsp;mode = <var>token</var>&gt;<br>&nbsp;&nbsp;&lt;!-- Content: (<a href="#element-sort">xsl:sort</a> | <a href="#element-with-param">xsl:with-param</a>)* --&gt;<br>&lt;/xsl:apply-templates&gt;</code></p><p>The <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction
takes as input a sequence of nodes in the source tree, and produces
as output a sequence of nodes which are typically added to the result
tree. Each node in the input sequence is processed by finding a
<a title="template rule" href="#dt-template-rule">template rule</a> whose <a title="pattern" href="#dt-pattern">pattern</a>
 matches that node. If there is more than one,
the best among them is chosen, using rules described below; if there is none, a built-in template rule 
is used. The chosen template rule is evaluated,
and produces a sequence of new nodes. The resulting sequences of nodes
(one for each node in the input sequence) are then concatenated, to form
a single sequence. They are concatenated retaining the order of the nodes 
in the original input sequence, unless a different order is requested using
<a href="#element-sort"><code>xsl:sort</code></a>.
The final concatenated sequence of nodes forms the result of the 
<a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction, and is passed to its parent instruction,
which will normally add the nodes to the result tree.

				</p><div class="example"><p>This example creates a block for a <code>chapter</code> element and
then processes its immediate children.</p><div class="exampleInner"><pre>&lt;xsl:template match="chapter"&gt;
  &lt;fo:block&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/fo:block&gt;
&lt;/xsl:template&gt;</pre></div></div><p>In the absence of a <code>select</code> attribute, the
<a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction processes all of the
children of the <a title="context node" href="#dt-context-node">context node</a>, including text nodes.  
<a name="d5e5876"><small>[ERR045] </small></a>It is a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> if 

the <a title="context item" href="#dt-context-item">context item</a> is not a node. 
The <a title="processor" href="#dt-processor">processor</a> must either signal the error, or
must recover by returning an empty sequence.
					
				</p><p>
					If stripping of whitespace nodes has not been
enabled for an element, then all whitespace in the content of the
element will be processed as text, and thus whitespace
between child elements will count in determining the position of a
child element as returned by the <u>fn:position</u>
function. This effect can be prevented by
stripping whitespace text nodes as specified in <a href="#strip"><b>4.3 Whitespace Stripping</b></a>.
				</p><p>A <code>select</code> attribute can be used to process nodes
selected by an expression instead of processing all children.  The
value of the <code>select</code> attribute is an
 <a title="expression" href="#dt-expression">expression</a>.  The expression must
evaluate to a sequence of nodes (it can contain
zero, one, or more nodes). The order of the result nodes will be the same as
the order of this sequence, unless a sorting specification is present (see
<a href="#sorting"><b>13 Sorting</b></a>).</p><p>
					<a name="d5e5933"><small>[ERR046] </small></a>It is a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> if 
the sequence returned by the <code>select</code> expression 

contains an item that is not a node.
The <a title="processor" href="#dt-processor">processor</a> must either signal the error, or must recover by ignoring the offending
items.
					
				</p><blockquote><table width="90%"><tr><td width="10%" align="left" valign="top"><b>Note:</b></td><td align="left" valign="top"><p>In XSLT 1.0, the <code>select</code> attribute selected a set of nodes, which
by default were processed in document order. In XSLT 2.0, it selects a sequence of nodes.
In cases that would have been valid in XSLT 1.0, the expression will return a sequence of
nodes in document order, so the effect is the same.</p></td></tr></table></blockquote><div class="example"><p>The following example processes all of the
<code>author</code> children of the <code>author-group</code>:</p><div class="exampleInner"><pre>&lt;xsl:template match="author-group"&gt;
  &lt;fo:wrapper&gt;
    &lt;xsl:apply-templates select="author"/&gt;
  &lt;/fo:wrapper&gt;
&lt;/xsl:template&gt;</pre></div></div><p>&nbsp;</p><div class="example"><p>The following example processes all of the <code>given-name</code>s
of the <code>author</code>s that are children of
<code>author-group</code>:</p><div class="exampleInner"><pre>&lt;xsl:template match="author-group"&gt;
  &lt;fo:wrapper&gt;
    &lt;xsl:apply-templates select="author/given-name"/&gt;
  &lt;/fo:wrapper&gt;
&lt;/xsl:template&gt;</pre></div><p>This example processes all of the <code>heading</code> descendant
elements of the <code>book</code> element.</p><div class="exampleInner"><pre>&lt;xsl:template match="book"&gt;
  &lt;fo:block&gt;
    &lt;xsl:apply-templates select=".//heading"/&gt;
  &lt;/fo:block&gt;
&lt;/xsl:template&gt;</pre></div></div><p>&nbsp;</p><div class="example"><p>It is also possible to process elements that are not descendants of
the context node.  This example assumes that a <code>department</code>
element has <code>group</code> children and <code>employee</code>
descendants. It finds an employee's department and then processes
the <code>group</code> children of the <code>department</code>.</p><div class="exampleInner"><pre>&lt;xsl:template match="employee"&gt;
  &lt;fo:block&gt;
    Employee &lt;xsl:apply-templates select="name"/&gt; belongs to group
    &lt;xsl:apply-templates select="ancestor::department/group"/&gt;
  &lt;/fo:block&gt;
&lt;/xsl:template&gt;</pre></div></div><p>&nbsp;</p><div class="example"><p>Multiple <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> elements can be used within a
single template to do simple reordering.  The following example
creates two HTML tables. The first table is filled with domestic sales
while the second table is filled with foreign sales.</p><div class="exampleInner"><pre>&lt;xsl:template match="product"&gt;
  &lt;table&gt;
    &lt;xsl:apply-templates select="sales/domestic"/&gt;
  &lt;/table&gt;
  &lt;table&gt;
    &lt;xsl:apply-templates select="sales/foreign"/&gt;
  &lt;/table&gt;
&lt;/xsl:template&gt;</pre></div></div><blockquote><table width="90%"><tr><td width="10%" align="left" valign="top"><b>Note:</b></td><td align="left" valign="top"><p>It is possible for there to be two matching descendants where one
is a descendant of the other.  This case is not treated specially:
both descendants will be processed as usual.</p><div class="example"><p> For example, given a source document</p><div class="exampleInner"><pre>&lt;doc&gt;&lt;div&gt;&lt;div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/doc&gt;</pre></div><p>the rule</p><div class="exampleInner"><pre>&lt;xsl:template match="doc"&gt;
  &lt;xsl:apply-templates select=".//div"/&gt;
&lt;/xsl:template&gt;</pre></div><p>will process both the outer <code>div</code> and inner <code>div</code>
elements.</p></div></td></tr></table></blockquote><blockquote><table width="90%"><tr><td width="10%" align="left" valign="top"><b>Note:</b></td><td align="left" valign="top"><p>Typically, <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> is used to
process only nodes that are descendants of the context node.  Such use
of <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> cannot result in non-terminating
processing loops.  However, when <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> is
used to process elements that are not descendants of the context node,
the possibility arises of non-terminating loops. For example,</p><div class="exampleInner"><pre>&lt;xsl:template match="foo"&gt;
  &lt;xsl:apply-templates select="."/&gt;
&lt;/xsl:template&gt;</pre></div><p>Implementations may be able to detect such loops in some cases, but
the possibility exists that a stylesheet may enter a non-terminating
loop that an implementation is unable to detect. This may present a
denial of service security risk.</p></td></tr></table></blockquote></div><div class="div2">
<h3><a name="conflict" id="conflict"></a>6.3 Conflict Resolution for Template Rules</h3><p>It is possible for a node in a source document to match more than one 
<a title="template rule" href="#dt-template-rule">template rule</a>.
 The template rule to be used is determined as follows:</p><ol type="1"><li><p>First, all matching template rules that have lower <a title="import precedence" href="#dt-import-precedence">import precedence</a> than the
matching template rule or rules with the highest import precedence are
eliminated from consideration.</p></li><li><p>Next, all matching template rules that have lower priority
than the matching template rule or rules with the highest priority are
eliminated from consideration.  The priority of a template rule is
specified by the <code>priority</code> attribute on the template rule.
<a name="d5e6082"><small>[ERR047] </small></a>The value of this
 
 must be a real number (positive or negative),
matching the production <u>NumericLiteral</u>
with an optional leading minus sign (<code>-</code>).
							<a name="d5e6100"><small>[ERR048] </small></a>If an <a href="#element-template"><code>xsl:template</code></a> element does not have
a <code>match</code> attribute, then it must not have a <code>priority</code>
attribute.
						</p><p>
							<a name="dt-default-priority" id="dt-default-priority" title="default priority"></a>If no <code>priority</code>
attribute is specified on the <a href="#element-template"><code>xsl:template</code></a> element, the <b>default
priority</b> is computed as follows:
						</p><ul><li><p>If the pattern contains multiple alternatives separated by
<code>|</code>, then it is treated equivalently to a set of template
rules, one for each alternative. Note, however, that
it is not an error if a node matches more than one of the alternatives. </p></li><li><p>If the pattern has the form of a <a title="QName" href="#dt-qname">QName</a> optionally preceded by a <a href="#NT-PatternAxis">PatternAxis</a>
or has the form
<code>processing-instruction(</code>
									<u>StringLiteral</u>
									<code>)</code> optionally preceded by a <a href="#NT-PatternAxis">PatternAxis</a>,
then the priority is 0.</p></li><li><p>If the pattern has the form <u>NCName</u>
									<code>:*</code> 
or <code>*:</code>
									<u>NCName</u>,
optionally preceded by a <a href="#NT-PatternAxis">PatternAxis</a>,
then the priority is -0.25.</p></li><li><p>Otherwise, if the pattern consists of just a <u>NodeTest</u> optionally preceded by a <a href="#NT-PatternAxis">PatternAxis</a>,
then the priority is -0.5.</p></li><li><p>Otherwise, the priority is 0.5.</p></li></ul><blockquote><table width="90%"><tr><td width="10%" align="left" valign="top"><b>Note:</b></td><td align="left" valign="top"><p>In many cases this means that highly selective patterns have higher
priority than less selective patterns. The most common kind of pattern (a pattern that tests for a
node with a particular type and a particular <a title="expanded-QName" href="#dt-expanded-qname">expanded-QName</a>) has
priority 0. The next less specific kind of pattern (a pattern that
tests for a node with a particular type and an <a title="expanded-QName" href="#dt-expanded-qname">expanded-QName</a> with a
particular namespace URI) has priority -0.25.  Patterns less specific
than this (patterns that just tests for nodes with particular types)
have priority -0.5.  Patterns more specific than the most common kind
of pattern have priority 0.5. However, it is not invariably true that
a more selective pattern has higher priority than a less selective pattern.
For example, the priority of the pattern <code>node()[self::*]</code> is higher than that of
the pattern <code>item</code>. Therefore, to achieve clarity in a stylesheet
it is good practice to allocate explicit priorities.</p></td></tr></table></blockquote></li></ol><p>
					<a name="d5e6201"><small>[ERR049] </small></a>It is a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> if
 this 
 leaves more than one matching template
rule.  The <a title="processor" href="#dt-processor">processor</a> must either signal the error, or must recover by choosing, from amongst the matching
template rules that are left, the one that occurs last in
<a title="declaration order" href="#dt-declaration-order">declaration order</a>.
					
				</p></div><div class="div2">
<h3><a name="modes" id="modes"></a>6.4 Modes</h3><p>
					<a name="dt-mode" id="dt-mode" title="mode"></a>
						<b>Modes</b> 
allow a node in the source tree to be processed multiple times, each time
producing a different result. They also allow different sets 
of <a title="template rule" href="#dt-template-rule">template rules</a>
 to be active when processing different
trees, for example when processing documents loaded using the <u>fn:document</u> function
(see <a href="#document"><b>16.1 Multiple Source Documents</b></a>) or when processing <a title="" href="#dt-temporary-tree">temporary trees</a>
 (see <a href="#temporary-trees"><b>9.4 Temporary Trees</b></a>)
				</p><p>Modes are identified by a <a title="QName" href="#dt-qname">QName</a>,
except for the default mode, which is unnamed.</p><p>A <a title="template rule" href="#dt-template-rule">template rule</a> is applicable to
one or more modes. The modes to which it is applicable are defined by the <code>mode</code> attribute
of the <a href="#element-template"><code>xsl:template</code></a> element. 
If the attribute is omitted, then the template rule is applicable to the default mode. If the attribute
is present, then its value must be a space-separated list of tokens, each of which defines a mode
to which the template rule is applicable. Each token must either be a 
<a title="QName" href="#dt-qname">QName</a>, which is expanded as described
in <a href="#qname"><b>5.1 Qualified Names</b></a> to define the name of the mode, or it must be the token
<code>#default</code>, to indicate that the template is applicable to the default mode.</p><p>The  <a href="#element-apply-templates"><code>xsl:apply-templates</code></a>
element also has an optional <code>mode</code> attribute. The value of this
attribute must either be a <a title="QName" href="#dt-qname">QName</a>, which is expanded as described
in <a href="#qname"><b>5.1 Qualified Names</b></a> to define the name of a mode, or the token <code>#default</code>, to 
indicate that the default mode is to be used, or the token <code>#current</code>, to indicate that
the <a title="current mode" href="#dt-current-mode">current mode</a> is to be used. 
If the attribute is omitted, the default mode is used.</p><p>When searching for a template rule to process each node selected by
the <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction, only those template rules that are
applicable to the selected mode are considered.</p><p>
					<a name="dt-current-mode" id="dt-current-mode" title="current mode"></a>At any point in the processing
 of a stylesheet, there is a <b>current mode</b>.  When the transformation is initiated,
 the current mode is the default mode (unless the processor provides some mechanism for
 starting processing in a different mode). Whenever an <a href="#element-apply-templates"><code>xsl:apply-templates</code></a>
 instruction is evaluated, the current mode becomes the mode selected by this instruction.
					When a stylesheet function is called, the current mode becomes the default
 mode.
 No other instruction changes the current mode. On completion of the <a href="#element-apply-templates"><code>xsl:apply-templates</code></a>
 instruction, the current mode reverts to its previous value. The current mode is used when an
 <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction uses the syntax <code>mode="#current"</code>;
 it is also used by the <a href="#element-apply-imports"><code>xsl:apply-imports</code></a> instruction (see <a href="#apply-imports"><b>6.6 Overriding Template Rules</b></a>).</p><p>
					<a name="d5e6324"><small>[ERR050] </small></a>If an <a href="#element-template"><code>xsl:template</code></a> element does not have
a <code>match</code> attribute, then it is a
 <a title="static error" href="#dt-static-error">static error</a> if it has a <code>mode</code>
attribute.
				</p></div><div class="div2">
<h3><a name="built-in-rule" id="built-in-rule"></a>6.5 Built-in Template Rules</h3><p>When a node is selected by <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> and there is no
template rule in the stylesheet that can be used to process that node, a built-in template rule
is evaluated instead. The built-in template rule for document nodes and elements nodes causes
the children of the node to be processed; the built in rule for text nodes and attribute nodes
causes the text to be copied to the result tree.</p><p>The built-in template rules apply to all modes. It is not possible for a
user-written template rule to apply to all modes, but for the sake of illustration, the syntax
<code>mode="#all"</code> is used in the examples below as shorthand for a list of all modes
(including the default mode) that are used in the stylesheet.</p><p>The built-in rule for document nodes and element nodes
is equivalent to calling <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> with no <code>select</code>
attribute, and with the <code>mode</code> attribute set to <code>#current</code>. If
the built-in rule was invoked with parameters, those parameters are passed on in the implicit
<a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction.</p><p>For example, suppose the stylesheet contains the following instruction:</p><div class="exampleInner"><pre>&lt;xsl:apply-templates select="title" mode="mm"&gt;
  &lt;xsl:with-param name="init" select="10"/&gt;
&lt;/xsl:apply-template&gt;</pre></div><p>If there is no explicit template rule that matches the <code>title</code> element,
then the following implicit rule is used:</p><div class="exampleInner"><pre>&lt;xsl:template match="title" mode="#all"&gt;
  &lt;xsl:with-param name="init"/&gt;
  &lt;xsl:apply-templates mode="#current"&gt;
    &lt;xsl:with-param name="init" select="$init"/&gt;
  &lt;/xsl:apply-templates&gt;
&lt;/xsl:template&gt;</pre></div><p>The built-in <a title="template rule" href="#dt-template-rule">template rule</a> 
for text and attribute nodes returns a text node containing the string value of the context node.
 It is effectively:</p><div class="exampleInner"><pre>&lt;xsl:template match="text()|@*" mode="#all"&gt;
  &lt;xsl:value-of select="."/&gt;
&lt;/xsl:template&gt;</pre></div><p>The built-in <a title="template rule" href="#dt-template-rule">template rule</a> for processing instructions and comments
does nothing (it returns the empty sequence).</p><div class="exampleInner"><pre>&lt;xsl:template match="processing-instruction()|comment()" mode="#all"/&gt;</pre></div><p>The built-in <a title="template rule" href="#dt-template-rule">template rule</a> for namespace nodes is also to do
nothing. There is no pattern that can match a namespace node; so, the
built-in template rule is the only template rule that is applied for
namespace nodes.</p><p>The built-in <a title="template rule" href="#dt-template-rule">template rules</a>
have lower <a title="import precedence" href="#dt-import-precedence">import precedence</a> than all other
template rules.  Thus, the stylesheet author can override a built-in template
rule by including an explicit template rule.</p></div><div class="div2">
<h3><a name="apply-imports" id="apply-imports"></a>6.6 Overriding Template Rules</h3><p class="element-syntax"><a name="element-apply-imports"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:apply-imports&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <a href="#element-with-param">xsl:with-param</a>* --&gt;<br>&lt;/xsl:apply-imports&gt;</code></p><p>A <a title="template rule" href="#dt-template-rule">template rule</a> that
 is being used to override a template rule in
an imported stylesheet (see <a href="#conflict"><b>6.3 Conflict Resolution for Template Rules</b></a>) can use the
<a href="#element-apply-imports"><code>xsl:apply-imports</code></a> element to invoke the overridden
template rule.</p><p>
					<a name="dt-current-template-rule" id="dt-current-template-rule" title="current template rule"></a>At any point in the processing
 of a stylesheet, there may be a
<b>current template rule</b>.  Whenever a <a title="template rule" href="#dt-template-rule">template rule</a> is
chosen by matching a pattern, the template rule becomes the current
template rule for the evaluation of the rule's content constructor. When an
<a href="#element-for-each"><code>xsl:for-each</code></a> or <a href="#element-for-each-group"><code>xsl:for-each-group</code></a> 
instruction is evaluated, or when 
a <a title="stylesheet function" href="#dt-stylesheet-function">stylesheet function</a>
 is called (see <a href="#stylesheet-functions"><b>10.3 Stylesheet Functions</b></a>), the current
template rule becomes null for the evaluation of that instruction
or function.
				</p><p>The current template rule is not affected by invoking
named templates (see <a href="#named-templates"><b>10.1 Named Templates</b></a>) or named attribute
sets (see <a href="#attribute-sets"><b>10.2 Named Attribute Sets</b></a>). While evaluating a 
<a title="global variable" href="#dt-global-variable">global variable</a>
or the default value of a <a title="stylesheet parameter" href="#dt-stylesheet-parameter">stylesheet parameter</a>
 (see <a href="#global-variables"><b>9.5 Global Variables and Parameters</b></a>) 
the current template rule is null.</p><p>
					<a href="#element-apply-imports"><code>xsl:apply-imports</code></a> searches for 
a <a title="template rule" href="#dt-template-rule">template rule</a> that matches the
context node, and 
that is applicable to the 
<a title="current mode" href="#dt-current-mode">current mode</a>
					
 (see <a href="#modes"><b>6.4 Modes</b></a>). In choosing
a template rule, it uses the usual criteria such as the priority and 
<a title="import precedence" href="#dt-import-precedence">import precedence</a> of 
the template rules, but it considers as candidates 
only those template rules contained in <a title="stylesheet level" href="#dt-stylesheet-level">stylesheet levels</a>
that are descendants in the <a title="import tree" href="#dt-import-tree">import tree</a>
of the <a title="stylesheet level" href="#dt-stylesheet-level">stylesheet 
level</a> that contains the
 <a title="current template rule" href="#dt-current-template-rule">current template rule</a>.</p><blockquote><table width="90%"><tr><td width="10%" align="left" valign="top"><b>Note:</b></td><td align="left" valign="top"><p>This is <em>not</em> the same as saying that the search considers
all template rules whose import precedence is lower than that of the current template rule.</p></td></tr></table></blockquote><p>If no matching template rule is
  found that satisfies these criteria, the
built-in template rule for the
 node type is used (see <a href="#built-in-rule"><b>6.5 Built-in Template Rules</b></a>).</p><p>
					<a name="d5e6522"><small>[ERR051] </small></a>It is an error if the <a href="#element-apply-imports"><code>xsl:apply-imports</code></a>
instruction is evaluated when the <a title="context item" href="#dt-context-item">context item</a> 
is not a node. The <a title="processor" href="#dt-processor">processor</a>
must either signal the error, or must recover by returning an empty sequence.
					
				</p><p>An <a href="#element-apply-imports"><code>xsl:apply-imports</code></a> element may use
<a href="#element-with-param"><code>xsl:with-param</code></a> child elements to pass
parameters to the chosen <a title="template rule" href="#dt-template-rule">template rule</a>
(see <a href="#with-param"><b>10.1.1 Passing Parameters to Templates</b></a>).</p><p>
					<a name="d5e6552"><small>[ERR052] </small></a>It is a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> if
<a href="#element-apply-imports"><code>xsl:apply-imports</code></a> is evaluated when the
 <a title="current template rule" href="#dt-current-template-rule">current template rule</a> is null. 
 The <a title="processor" href="#dt-processor">processor</a> must signal the error.
					
				</p><div class="example"><p>For example, suppose the stylesheet <code>doc.xsl</code> contains a
<a title="template rule" href="#dt-template-rule">template rule</a> for <code>example</code> elements:</p><div class="exampleInner"><pre>&lt;xsl:template match="example"&gt;
  &lt;pre&gt;&lt;xsl:apply-templates/&gt;&lt;/pre&gt;
&lt;/xsl:template&gt;</pre></div><p>Another stylesheet could import <code>doc.xsl</code> and modify the
treatment of <code>example</code> elements as follows:</p><div class="exampleInner"><pre>&lt;xsl:import href="doc.xsl"/&gt;

&lt;xsl:template match="example"&gt;
  &lt;div style="border: solid red"&gt;
     &lt;xsl:apply-imports/&gt;
  &lt;/div&gt;
&lt;/xsl:template&gt;</pre></div><p>The combined effect would be to transform an <code>example</code>
into an element of the form:</p><div class="exampleInner"><pre>&lt;div style="border: solid red"&gt;&lt;pre&gt;...&lt;/pre&gt;&lt;/div&gt;</pre></div></div></div></div><div class="div1">
<h2><a name="for-each" id="for-each"></a>7 Repetition</h2><p class="element-syntax"><a name="element-for-each"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:for-each<br>&nbsp;&nbsp;<b>select</b> = <var>sequence-expression</var>&gt;<br>&nbsp;&nbsp;&lt;!-- Content: (<a href="#element-sort">xsl:sort</a>*, <var>content-constructor</var>) --&gt;<br>&lt;/xsl:for-each&gt;</code></p><p>The <a href="#element-for-each"><code>xsl:for-each</code></a> instruction
processes each item in a sequence of items, evaluating the
<a title="content constructor" href="#dt-content-constructor">content constructor</a>
within the <a href="#element-for-each"><code>xsl:for-each</code></a> instruction once for each item
in that sequence.</p><p>
The <code>select</code> attribute is required, and 
the <a title="expression" href="#dt-expression">expression</a> must evaluate to a sequence, 
called the input sequence. If there is an <a href="#element-sort"><code>xsl:sort</code></a>
element present (see <a href="#sorting"><b>13 Sorting</b></a>) the input sequence
is sorted to produce a sorted sequence. Otherwise, the sorted sequence
is the same as the input sequence.</p><p>The <a href="#element-for-each"><code>xsl:for-each</code></a> instruction contains a
 <a title="content constructor" href="#dt-content-constructor">content constructor</a>, which is
evaluated once for each item in the sorted sequence.    
The <a title="content constructor" href="#dt-content-constructor">content constructor</a>
is evaluated with the <a title="focus" href="#dt-focus">focus</a> set as follows:</p><ul><li><p>The <a title="context item" href="#dt-context-item">context item</a> is the item being processed. 
If this is a node, it will
also be the <a title="context node" href="#dt-context-node">context node</a>. If it
is not a node, there will be no context node: that is, the value of <code>self::node()</code> will
be an empty sequence.
					</p></li><li><p>The <a title="context position" href="#dt-context-position">context position</a> is the position of this item 
in the sorted sequence.</p></li><li><p>The <a title="context size" href="#dt-context-size">context size</a> is the size
 of the sorted sequence (which is the same as the
size of the input sequence).</p></li><li></li></ul><p> For each item in the input sequence, evaluating the
 <a title="content constructor" href="#dt-content-constructor">content constructor</a> produces a sequence
of output nodes; these output sequences are concatenated in the same order as the
sorted sequence. The result of the <a href="#element-for-each"><code>xsl:for-each</code></a> instruction
is the concatenated sequence of output nodes.</p><blockquote><table width="90%"><tr><td width="10%" align="left" valign="top"><b>Note:</b></td><td align="left" valign="top"><p>With XSLT 1.0, the selected nodes were processed in document order.
With XSLT 2.0, XPath expressions that would have been valid under XPath 1.0 (such
as path expressions and union expressions) will return a sequence of nodes
that is already in document order, so backwards compatibility is maintained.</p></td></tr></table></blockquote><div class="example"><p>For example, given an XML document with this structure</p><div class="exampleInner"><pre>&lt;customers&gt;
  &lt;customer&gt;
    &lt;name&gt;...&lt;/name&gt;
    &lt;order&gt;...&lt;/order&gt;
    &lt;order&gt;...&lt;/order&gt;
  &lt;/customer&gt;
  &lt;customer&gt;
    &lt;name&gt;...&lt;/name&gt;
    &lt;order&gt;...&lt;/order&gt;
    &lt;order&gt;...&lt;/order&gt;
  &lt;/customer&gt;
&lt;/customers&gt;</pre></div><p>the following would create an HTML document containing a table with
a row for each <code>customer</code> element</p><div class="exampleInner"><pre>&lt;xsl:template match="/"&gt;
  &lt;html&gt;
    &lt;head&gt;
      &lt;title&gt;Customers&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
      &lt;table&gt;
	&lt;tbody&gt;
	  &lt;xsl:for-each select="customers/customer"&gt;
	    &lt;tr&gt;
	      &lt;th&gt;
		&lt;xsl:apply-templates select="name"/&gt;
	      &lt;/th&gt;
	      &lt;xsl:for-each select="order"&gt;
		&lt;td&gt;
		  &lt;xsl:apply-templates/&gt;
		&lt;/td&gt;
	      &lt;/xsl:for-each&gt;
	    &lt;/tr&gt;
	  &lt;/xsl:for-each&gt;
	&lt;/tbody&gt;
      &lt;/table&gt;
    &lt;/body&gt;
  &lt;/html&gt;
&lt;/xsl:template&gt;</pre></div></div></div><div class="div1">
<h2><a name="conditionals" id="conditionals"></a>8 Conditional Processing</h2><p>There are two instructions in XSLT that support conditional
processing in a template: <a href="#element-if"><code>xsl:if</code></a> and
<a href="#element-choose"><code>xsl:choose</code></a>. The <a href="#element-if"><code>xsl:if</code></a> instruction provides
simple if-then conditionality; the <a href="#element-choose"><code>xsl:choose</code></a> instruction
supports selection of one choice when there are several
possibilities.</p><div class="div2">
<h3><a name="d5e6729" id="d5e6729"></a>8.1 Conditional Processing with <a href="#element-if"><code>xsl:if</code></a>
				</h3><p class="element-syntax"><a name="element-if"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:if<br>&nbsp;&nbsp;<b>test</b> = <var>expression</var>&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>content-constructor</var> --&gt;<br>&lt;/xsl:if&gt;</code></p><p>The <a href="#element-if"><code>xsl:if</code></a> element has a <code>test</code> attribute,
which specifies an <a title="expression" href="#dt-expression">expression</a>.
The content is a
 <a title="content constructor" href="#dt-content-constructor">content constructor</a>.</p><p>The result of the <a href="#element-if"><code>xsl:if</code></a> instruction
depends on the <em>effective boolean value</em> of the expression
in the <code>test</code> attribute. The rules for determining the
effective boolean value of an expression are given in <a href="#XPATH20">[XPath 2.0]</a>: they
are the same as the rules used for XPath conditional expressions.</p><p>If the effective boolean value of 
				the <a title="expression" href="#dt-expression">expression</a> is true, then
the <a title="content constructor" href="#dt-content-constructor">content constructor</a> is evaluated,
and the resulting node sequence is returned as the result of
the <a href="#element-if"><code>xsl:if</code></a> instruction; otherwise, an empty sequence is returned.</p><div class="example"><p>In the following example, the names in a group of names are formatted
as a comma separated list:</p><div class="exampleInner"><pre>&lt;xsl:template match="namelist/name"&gt;
  &lt;xsl:apply-templates/&gt;
  &lt;xsl:if test="not(fn:position()=fn:last())"&gt;, &lt;/xsl:if&gt;
&lt;/xsl:template&gt;</pre></div><p>The following colors every other table row yellow:</p><div class="exampleInner"><pre>&lt;xsl:template match="item"&gt;
  &lt;tr&gt;
    &lt;xsl:if test="fn:position() mod 2 = 0"&gt;
       &lt;xsl:attribute name="bgcolor"&gt;yellow&lt;/xsl:attribute&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/tr&gt;
&lt;/xsl:template&gt;</pre></div></div></div><div class="div2">
<h3><a name="d5e6792" id="d5e6792"></a>8.2 Conditional Processing with <a href="#element-choose"><code>xsl:choose</code></a>
				</h3><p class="element-syntax"><a name="element-choose"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:choose&gt;<br>&nbsp;&nbsp;&lt;!-- Content: (<a href="#element-when">xsl:when</a>+, <a href="#element-otherwise">xsl:otherwise</a>?) --&gt;<br>&lt;/xsl:choose&gt;</code></p><p class="element-syntax"><a name="element-when"></a><code>&lt;xsl:when<br>&nbsp;&nbsp;<b>test</b> = <var>expression</var>&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>content-constructor</var> --&gt;<br>&lt;/xsl:when&gt;</code></p><p class="element-syntax"><a name="element-otherwise"></a><code>&lt;xsl:otherwise&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>content-constructor</var> --&gt;<br>&lt;/xsl:otherwise&gt;</code></p><p>The <a href="#element-choose"><code>xsl:choose</code></a> element selects one among a number of
possible alternatives. It consists of a sequence of
<a href="#element-when"><code>xsl:when</code></a> elements followed by an optional
<a href="#element-otherwise"><code>xsl:otherwise</code></a> element.  Each <a href="#element-when"><code>xsl:when</code></a>
element has a single attribute, <code>test</code>, which specifies an
<a title="expression" href="#dt-expression">expression</a>. The content of the
<a href="#element-when"><code>xsl:when</code></a> and <a href="#element-otherwise"><code>xsl:otherwise</code></a> elements is a
<a title="content constructor" href="#dt-content-constructor">content constructor</a>.</p><p>When an <a href="#element-choose"><code>xsl:choose</code></a> element is processed, each
of the <a href="#element-when"><code>xsl:when</code></a> elements is tested in turn
(that is, in document order as the elements appear in the stylesheet),
until one of the 
						<a href="#element-when"><code>xsl:when</code></a> elements is satisfied.
An <a href="#element-when"><code>xsl:when</code></a> element is satisfied if
the <em>effective boolean value</em> of the <a title="expression" href="#dt-expression">expression</a>
in its <code>test</code> attribute is <code>true</code>. The rules for determining the
effective boolean value of an expression are given in <a href="#XPATH20">[XPath 2.0]</a>: they
are the same as the rules used for XPath conditional expressions.
				</p><p>The content
of the first, and only the first, <a href="#element-when"><code>xsl:when</code></a> element 
that is satisfied is evaluated, 
and the resulting node sequence is returned as the result of the
 <a href="#element-choose"><code>xsl:choose</code></a> instruction.
  If no <a href="#element-when"><code>xsl:when</code></a>
					element is satisfied,
the content of the <a href="#element-otherwise"><code>xsl:otherwise</code></a> element is
evaluated, and the resulting node sequence is returned as the result
 of the <a href="#element-choose"><code>xsl:choose</code></a> instruction.
If no <a href="#element-when"><code>xsl:when</code></a> element is satisfied, and no
<a href="#element-otherwise"><code>xsl:otherwise</code></a> element is present, the result of the
 <a href="#element-choose"><code>xsl:choose</code></a> instruction
is an empty sequence.</p><p>Only the content constructor of the selected <a href="#element-when"><code>xsl:when</code></a> or
 <a href="#element-otherwise"><code>xsl:otherwise</code></a>
instruction is evaluated. The <code>test</code> expressions
for <a href="#element-when"><code>xsl:when</code></a> instructions after the selected one are not evaluated.</p><div class="example"><p>The following example enumerates items in an ordered list using
arabic numerals, letters, or roman numerals depending on the depth to
which the ordered lists are nested.</p><div class="exampleInner"><pre>&lt;xsl:template match="orderedlist/listitem"&gt;
  &lt;fo:list-item indent-start='2pi'&gt;
    &lt;fo:list-item-label&gt;
      &lt;xsl:variable name="level"
                    select="count(ancestor::orderedlist) mod 3"/&gt;
      &lt;xsl:choose&gt;
        &lt;xsl:when test='$level=1'&gt;
          &lt;xsl:number format="i"/&gt;
        &lt;/xsl:when&gt;
        &lt;xsl:when test='$level=2'&gt;
          &lt;xsl:number format="a"/&gt;
        &lt;/xsl:when&gt;
        &lt;xsl:otherwise&gt;
          &lt;xsl:number format="1"/&gt;
        &lt;/xsl:otherwise&gt;
      &lt;/xsl:choose&gt;
      &lt;xsl:text&gt;. &lt;/xsl:text&gt;
    &lt;/fo:list-item-label&gt;
    &lt;fo:list-item-body&gt;
      &lt;xsl:apply-templates/&gt;
    &lt;/fo:list-item-body&gt;
  &lt;/fo:list-item&gt;
&lt;/xsl:template&gt;</pre></div></div></div></div><div class="div1">
<h2><a name="variables-and-parameters" id="variables-and-parameters"></a>9 Variables and Parameters</h2><p><a name="dt-variable-binding-element" id="dt-variable-binding-element" title="variable-binding element"></a>The 
two elements <a href="#element-variable"><code>xsl:variable</code></a> and <a href="#element-param"><code>xsl:param</code></a>
are referred to as <b>variable-binding elements</b>
.</p><p><a name="dt-variable" id="dt-variable" title="variable"></a>The <a href="#element-variable"><code>xsl:variable</code></a> element declares a
<b>variable</b>, which may be a <a title="global variable" href="#dt-global-variable">global variable</a>
 or a <a title="local variable" href="#dt-local-variable">local variable</a>.
<a name="dt-parameter" id="dt-parameter" title="parameter"></a>The <a href="#element-param"><code>xsl:param</code></a>
element declares a <b>parameter</b>, which may be a 
<a title="stylesheet parameter" href="#dt-stylesheet-parameter">stylesheet parameter</a>,
a <a title="template parameter" href="#dt-template-parameter">template parameter</a>,
or a <a title="function parameter" href="#dt-function-parameter">function parameter</a>. A parameter
is a <a title="variable" href="#dt-variable">variable</a> with the additional property that its value can be set
 by the caller of the stylesheet, the template, or the function.</p><p>A variable is a binding between a name and a value.  
<a name="dt-value" id="dt-value" title="value"></a>The value to
which a variable is bound (the <b>value</b> of the variable) is
any sequence (of nodes and/or atomic values), as defined in <a href="#DATAMODEL">[Data Model]</a>.</p><div class="div2">
<h3><a name="variables" id="variables"></a>9.1 Variables</h3><p class="element-syntax"><a name="element-variable"></a><code>&lt;!-- Category: declaration --&gt;<br>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:variable<br>&nbsp;&nbsp;<b>name</b> = <var>qname</var><br>&nbsp;&nbsp;select = <var>expression</var><br>&nbsp;&nbsp;as = <var>sequence-type</var><br>&nbsp;&nbsp;type-information = "strict" | "lax" | "preserve" | "none"&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>content-constructor</var> --&gt;<br>&lt;/xsl:variable&gt;</code></p><p>The <a href="#element-variable"><code>xsl:variable</code></a> element has a
required <code>name</code> attribute, which specifies the name of the
variable.  The value of the <code>name</code> attribute is a <a title="QName" href="#dt-qname">QName</a>, which is expanded as described
in <a href="#qname"><b>5.1 Qualified Names</b></a>.</p><p>The <a href="#element-variable"><code>xsl:variable</code></a> element has an
optional <code>as</code> attribute, which specifies the
<a title="required type" href="#dt-required-type">required type</a> of the
variable.  The value of the <code>as</code> attribute is a 
<u>SequenceType</u>, 
as defined in <a href="#XPATH20">[XPath 2.0]</a>. The result of evaluating the <a title="expression" href="#dt-expression">expression</a> contained
in the <code>select</code> attribute is referred to as the supplied value of the variable.
<a name="d5e7063"><small>[ERR053] </small></a>If the <code>as</code> attribute 

is specified, then the supplied value of the
variable is converted to the required type, using the 
<a title="argument conversion rules" href="#dt-argument-conversion-rules">argument conversion rules</a>.

It is a <a title="type errors" href="#dt-type-error">type error</a>
if this conversion fails.
			</p><p>If the <code>as</code> attribute is omitted, the supplied value of the variable is used
directly, and no conversion takes place. The effect is the same as
if the type were specified as <code>item*</code>.</p><p>The <code>type-information</code> attribute is used to determine what
type annotations should be present in a newly constructed tree. <a name="d5e7097"><small>[ERR054] </small></a>It is an error
to specify the <code>type-information</code> attribute on a variable binding element that has 
empty content. For details of the meaning of this attribute, see <a href="#temporary-trees"><b>9.4 Temporary Trees</b></a>.</p></div><div class="div2">
<h3><a name="d5e7105" id="d5e7105"></a>9.2 Parameters</h3><p class="element-syntax"><a name="element-param"></a><code>&lt;!-- Category: declaration --&gt;<br>&lt;xsl:param<br>&nbsp;&nbsp;<b>name</b> = <var>qname</var><br>&nbsp;&nbsp;select = <var>expression</var><br>&nbsp;&nbsp;as = <var>sequence-type</var><br>&nbsp;&nbsp;required = "yes" | "no"<br>&nbsp;&nbsp;type-information = "strict" | "lax" | "preserve" | "none"&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>content-constructor</var> --&gt;<br>&lt;/xsl:param&gt;</code></p><p>The <a href="#element-param"><code>xsl:param</code></a> element may be used as a child of <a href="#element-stylesheet"><code>xsl:stylesheet</code></a>, to define
a parameter to the transformation; or as a child of <a href="#element-template"><code>xsl:template</code></a> to define a parameter to a
template, which may be supplied when the template is invoked using <a href="#element-call-template"><code>xsl:call-template</code></a>,
<a href="#element-apply-templates"><code>xsl:apply-templates</code></a>, or <a href="#element-apply-imports"><code>xsl:apply-imports</code></a>; or as a child of <a href="#element-function"><code>xsl:function</code></a> to define a parameter
to a stylesheet function, which may be supplied when the function is called from an XPath <a title="expression" href="#dt-expression">expression</a>.</p><p>The <a href="#element-param"><code>xsl:param</code></a> element has a
required <code>name</code> attribute, which specifies the name of the
parameter.  The value of the <code>name</code> attribute is a <a title="QName" href="#dt-qname">QName</a>, which is expanded as described
in <a href="#qname"><b>5.1 Qualified Names</b></a>.</p><p>The <a href="#element-param"><code>xsl:param</code></a> element has an
optional <code>as</code> attribute, which specifies the
<a title="required type" href="#dt-required-type">required type</a> of the
parameter.  The value of the <code>as</code> attribute is a 
<u>SequenceType</u>, 
as defined in <a href="#XPATH20">[XPath 2.0]</a>. The the value supplied by the caller
 is referred to as the supplied value of the parameter.
<a name="d5e7191"><small>[ERR055] </small></a>If the <code>as</code> attribute 

is specified, then the supplied value of the
parameter is converted to the required type, using 
<a title="argument conversion rules" href="#dt-argument-conversion-rules">argument conversion rules</a>.
It is a <a title="type errors" href="#dt-type-error">type error</a>
if this conversion fails.
			</p><p>If the <code>as</code> attribute is omitted, the supplied value of the 
			parameter is used directly, and no conversion takes place. The effect is the same as
if the type were specified as <code>item*</code>.</p><p>The <code>type-information</code> attribute is used to determine what
type annotations should be present in a newly constructed tree. The <code>type-information</code> attribute is
relevant only to the default value of the parameter; it does not affect the treatment of a value supplied
as an actual parameter by the caller.
<a name="d5e7224"><small>[ERR056] </small></a>It is an error
to specify the <code>type-information</code> attribute on an <a href="#element-param"><code>xsl:param</code></a> element that has 
empty content. For details of the meaning of this attribute, see <a href="#temporary-trees"><b>9.4 Temporary Trees</b></a>.</p><p>The <code>required</code> attribute may be used
to indicate that a parameter is mandatory. This attribute may be specified for 
<a title="stylesheet parameter" href="#dt-stylesheet-parameter">stylesheet parameters</a> and for
<a title="template parameter" href="#dt-template-parameter">template parameters</a>;
it must not be specified for <a title="function parameter" href="#dt-function-parameter">function parameters</a>, 
which are always mandatory. The default
value is <code>no</code>, indicating that the parameter is optional. If the value of the <code>required</code>
attribute is <code>yes</code>, the <a href="#element-param"><code>xsl:param</code></a> element must be empty, and must have no <code>select</code>
attribute.</p><p><a name="d5e7265"><small>[ERR057] </small></a>If the value of the <code>required</code> attribute is <code>no</code>, 
and the caller supplies
no value for the parameter, then it is a <a title="type errors" href="#dt-type-error">type error</a> if the default value
of the parameter cannot be converted to the required type, using the
<a title="argument conversion rules" href="#dt-argument-conversion-rules">argument conversion rules</a>. 
 If the default value is supplied implicitly, that is, if the <a href="#element-param"><code>xsl:param</code></a>
element has no <code>select</code> attribute and has empty content, then the default value is a zero-length string;
if the zero-length string cannot be converted to the required type, then an error must be signalled
 only as a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a>, if the 
 caller supplies no value for the parameter. In all other cases the type error may be signalled
 either as a static error or as a dynamic error.</p></div><div class="div2">
<h3><a name="variable-values" id="variable-values"></a>9.3 Values of Variables and Parameters</h3><p>A <a title="variable-binding element" href="#dt-variable-binding-element">variable-binding element</a>
 can specify the supplied value of the <a title="variable" href="#dt-variable">variable</a> 
 or <a title="parameter" href="#dt-parameter">parameter</a> in
three different ways.</p><ul><li><p>
							<a name="d5e7308"><small>[ERR058] </small></a>If 
the <a title="variable-binding element" href="#dt-variable-binding-element">variable-binding element</a> has a <code>select</code>
attribute, then the value of the attribute must be an
<a title="expression" href="#dt-expression">expression</a> and the supplied value of the variable
is the value that results from evaluating the expression.  In this
case, the content of the variable-binding element must be empty.
						</p></li><li><p>
							<a name="dt-temporary-tree" id="dt-temporary-tree" title=""></a>If a <a title="variable-binding element" href="#dt-variable-binding-element">variable-binding element</a> has no <code>select</code>
attribute and has non-empty content (i.e. the variable-binding element
has one or more child nodes), then the content of the
variable-binding element specifies the supplied value. The content of the
variable-binding element is a
 <a title="content constructor" href="#dt-content-constructor">content constructor</a>; a new
document (referred to as a <b>temporary tree</b>) is constructed with a document
 node having as its children
the sequence of nodes that results from evaluating the content constructor.
							Temporary trees are described in more detail in
<a href="#temporary-trees"><b>9.4 Temporary Trees</b></a>.
						</p></li><li><p>If the <a title="variable-binding element" href="#dt-variable-binding-element">variable-binding element</a> has empty content and does not have
a <code>select</code> attribute, then the supplied value of the variable is a
zero-length string . Thus</p><div class="exampleInner"><pre>&lt;xsl:variable name="x"/&gt;</pre></div><p>is equivalent to</p><div class="exampleInner"><pre>&lt;xsl:variable name="x" select="''"/&gt;</pre></div></li></ul><p>The actual value of the variable depends on the supplied value,
as described above, and the required type, which is determined by the value of the <code>as</code> attribute.</p><div class="example"><blockquote><table width="90%"><tr><td width="10%" align="left" valign="top"><b>Note:</b></td><td align="left" valign="top"><p>When a variable is used to select nodes by position, be careful
not to do:</p><div class="exampleInner"><pre>&lt;xsl:variable name="n"&gt;2&lt;/xsl:variable&gt;
...
&lt;xsl:value-of select="td[$n]"/&gt;</pre></div><p>This will output the value of the first <code>td</code> element, because the
variable <code>n</code> will be bound to a node, not a number. Instead, do one of the following:</p><div class="exampleInner"><pre>&lt;xsl:variable name="n" select="2"/&gt;
...
&lt;xsl:value-of select="td[$n]"/&gt;</pre></div><p>or</p><div class="exampleInner"><pre>&lt;xsl:variable name="n"&gt;2&lt;/xsl:variable&gt;
...
&lt;xsl:value-of select="td[fn:position()=$n]"/&gt;</pre></div><p>or</p><div class="exampleInner"><pre>&lt;xsl:variable name="n" as="xs:integer"&gt;2&lt;/xsl:variable&gt;
...
&lt;xsl:value-of select="td[$n]"/&gt;</pre></div></td></tr></table></blockquote></div></div><div class="div2">
<h3><a name="temporary-trees" id="temporary-trees"></a>9.4 Temporary Trees</h3><p>A temporary tree is constructed by evaluating an
<a href="#element-variable"><code>xsl:variable</code></a>, <a href="#element-param"><code>xsl:param</code></a>, <a href="#element-with-param"><code>xsl:with-param</code></a>,
or <a href="#element-result"><code>xsl:result</code></a> element that has non-empty content. This element is referred
to as the variable-binding element. The supplied value of the <a title="variable" href="#dt-variable">variable</a> is a single node, the document node
of the temporary tree. This document node acts as the
<a title="current destination node" href="#dt-current-destination-node">current destination node</a> for the evaluation
of the <a title="content constructor" href="#dt-content-constructor">content constructor</a> owned by the variable-binding element.
				</p><p>The actual value of the variable depends on the supplied value,
as described above, and the required type, which is determined by the value of the <code>as</code> attribute.</p><div><blockquote><p><b><a href="#issue-tree-to-string-conversion">Issue 135 (tree-to-string-conversion)</a>: </b>The current XPath 2.0 rules for function calling, as well as addition and equality comparison,
    do not allow a document node to be converted to a string.</p></blockquote></div><p>
					<a title="namespace fixup" href="#dt-namespace-fixup">Namespace fixup</a> is
performed on the temporary tree (see <a href="#namespace-fixup"><b>4.4 Namespace Fixup</b></a>). </p><p>The base URI of a node in the
 <a title="" href="#dt-temporary-tree">temporary tree</a> is determined as
if all the nodes in the temporary tree came from a single entity whose URI
was the base URI of the <a title="variable-binding element" href="#dt-variable-binding-element">variable-binding element</a> (see <a href="#DATAMODEL">[Data Model]</a>). 
Thus, the base URI of the document node will be equal
to the base URI of the variable-binding element; an
<code>xml:base</code> attribute within the temporary tree will change the
base URI for its parent element and that element's descendants, just
as it would within a document constructed by parsing.</p><p>A <a title="" href="#dt-temporary-tree">temporary tree</a> is
 available for processing
in exactly the same way as any source document. For example, its nodes
are accessible using path expressions, and they can be processed using
instructions such as <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> and <a href="#element-for-each"><code>xsl:for-each</code></a>.
Also, the <a href="#function-key"><b>key</b></a> function can be used to find nodes
within a temporary tree, provided that at the time the function is called, the context item
is a node within the temporary tree.
				</p><p>The <code>type-information</code> attribute determines what
 type annotations will be present on the element and attribute nodes of the constructed
 tree. The default value is <code>none</code>. The values are as follows:</p><ul><li><p>The value <code>none</code> indicates that all element nodes in the tree will be
 annotated as <code>xs:anyType</code>, and all attributes will be annotated as <code>xs:anySimpleType</code>.
 Any previously created annotations on these nodes will be discarded.</p></li><li><p>The value <code>preserve</code> indicates that any annotations placed on 
 individual element and attribute nodes at the time they were created (for example, 
 by using the <code>type-annotation</code> attribute of <a href="#element-element"><code>xsl:element</code></a> or
 the <code>copy-type-annotations</code> attribute of <a href="#element-copy-of"><code>xsl:copy-of</code></a>) are preserved. Any other nodes
 are annotated as <code>xs:anyType</code> for elements, and <code>xs:anySimpleType</code> for
 attributes.</p></li><li><p>The value <code>strict</code> indicates that element and attributes are assigned types
 by performing strict schema validation: that is, every element and attribute in the tree must
 be defined in the relevant schema, and must conform to its definition.
 The relevant schema may be located using any of the mechanisms described in
 <a href="#XMLSCHEMA">[XML Schema]</a>. Specifically, a schema may be located implicitly from knowledge of the namespace
 in which the elements and attributes appear; or it may be located using the <code>xsi:schemaLocation</code>
 attribute of elements within the tree.</p></li><li><p>The value <code>lax</code> indicates that element and attributes are assigned types
 by performing lax schema validation: that is, every element and attribute in the tree must
 conform to its definition if it is present in a relevant schema (defined
 as in the previous paragraph).</p></li></ul><p>When requested, schema validation is performed according to the process described in
 <a href="#XMLSCHEMA">[XML Schema]</a>. As well as adding type annotations, this process may also insert nodes
 to represent defaulted attributes.</p><p>
					<a name="d5e7534"><small>[ERR059] </small></a>If schema validation is requested and the document
 is not well-formed (that is, if it contains text nodes as children of the document node, or
 if the number of element children of the document root is not exactly one), a dynamic
 error occurs. The processor must signal the error.
					
				</p><div><blockquote><p><b><a href="#issue-validation-implies-well-formedness">Issue 143 (validation-implies-well-formedness)</a>: </b>Should we require that when validation of a temporary tree is performed, the tree must
    contain a single top-level element node? It would be possible to define validation without
    requiring this: it could mean that each top-level element is independently validated.</p></blockquote></div><p>
					<a name="d5e7543"><small>[ERR060] </small></a>If schema validation is requested and the schema
 validity assessment concludes that the document is invalid, a dynamic
 error occurs. The processor must signal the error.
					
				</p><div class="example"><p>For example, the following stylesheet uses a temporary tree as the intermediate
result of a two-phase transformation, using different <a title="mode" href="#dt-mode">modes</a>
 for the two phases (see <a href="#modes"><b>6.4 Modes</b></a>): </p><blockquote><table width="100%"><tr><td width="10%" align="left" valign="top"><b>Ed. Note:</b></td><td align="left" valign="top">We need to add examples to clarify how the <code>as</code> attribute works,
especially with temporary trees.</td></tr></table></blockquote><div class="exampleInner"><pre>&lt;xsl:stylesheet
  version="2.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

&lt;xsl:import href="phase1.xsl"/&gt;
&lt;xsl:import href="phase2.xsl"/&gt;

&lt;xsl:variable name="intermediate"&gt;
  &lt;xsl:apply-templates select="/" mode="phase1"/&gt;
&lt;/xsl:variable&gt;

&lt;xsl:template match="/"&gt;
  &lt;xsl:apply-templates select="$intermediate" mode="phase2"/&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre></div></div><blockquote><table width="90%"><tr><td width="10%" align="left" valign="top"><b>Note:</b></td><td align="left" valign="top"><p>The algorithm for matching nodes against template rules is
exactly the same regardless which tree the nodes come from; if nodes
from different trees cannot be distinguished by their <a title="expanded-QName" href="#dt-expanded-qname">expanded-QName</a>,
it is therefore a good idea to use modes to ensure that each tree is
processed using the appropriate set of template rules.</p></td></tr></table></blockquote></div><div class="div2">
<h3><a name="global-variables" id="global-variables"></a>9.5 Global Variables and Parameters</h3><p>Both <a href="#element-variable"><code>xsl:variable</code></a> and <a href="#element-param"><code>xsl:param</code></a> are
allowed as <a title="declaration" href="#dt-declaration">declaration</a> elements:
that is, they may appear as children of the <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> element. 
<a name="dt-global-variable" id="dt-global-variable" title="global variable"></a>A 
top-level <a title="variable-binding element" href="#dt-variable-binding-element">variable-binding element</a>
 declares a <b>global variable</b> that
is visible everywhere (except where it
is <a title="shadows" href="#dt-shadows">shadowed</a> by another
binding).
<a name="dt-stylesheet-parameter" id="dt-stylesheet-parameter" title="stylesheet parameter"></a>A top-level <a href="#element-param"><code>xsl:param</code></a> element
declares a <b>stylesheet parameter</b>.
A stylesheet parameter is a global variable with the additional property 
that its value can be supplied
by the caller when a transformation is initiated. XSLT does not define the
mechanism by which parameter values are passed to the stylesheet.</p><p>If a stylesheet contains more than one
binding for a global variable of a particular name, then the binding with the
highest <a title="import precedence" href="#dt-import-precedence">import
precedence</a> is used. <a name="d5e7620"><small>[ERR061] </small></a>It is a
<a title="static error" href="#dt-static-error">static error</a> if a
 stylesheet contains more than one binding of a global
variable with the same name and same
 <a title="import precedence" href="#dt-import-precedence">import precedence</a>.
				</p><p>For a global variable or  the default value of a stylesheet parameter, 
the <a title="expression" href="#dt-expression">expression</a> or <a title="content constructor" href="#dt-content-constructor">content constructor</a>
 specifying the variable value is
evaluated with a <a title="singleton focus" href="#dt-singleton-focus">singleton focus</a> based
on the document node of the document containing the 
<a title="initial context node" href="#dt-initial-context-node">initial context node</a>
					.</p><div class="example"><p>The following example declares a global parameter
						<code>para-font-size</code>,
which it references in an <a title="attribute value template" href="#dt-attribute-value-template">attribute value template</a>.</p><div class="exampleInner"><pre>&lt;xsl:param name="para-font-size" as="xs:string"&gt;12pt&lt;/xsl:variable&gt;

&lt;xsl:template match="para"&gt;
 &lt;fo:block font-size="{$para-font-size}"&gt;
   &lt;xsl:apply-templates/&gt;
 &lt;/fo:block&gt;
&lt;/xsl:template&gt;
</pre></div><p>The implementation is expected to provide a mechanism allowing the user to supply
a value for the parameter <code>para-font-size</code> when invoking the stylesheet; the value <code>12pt</code>
acts as a default.</p></div></div><div class="div2">
<h3><a name="local-variables" id="local-variables"></a>9.6 Local Variables and Parameters</h3><p><a name="dt-local-variable" id="dt-local-variable" title="local variable"></a>As 
well as being allowed as <a title="declaration" href="#dt-declaration">declaration</a> elements, the
<a href="#element-variable"><code>xsl:variable</code></a> element is also
allowed in <a title="content constructor" href="#dt-content-constructor">content constructors</a>
and within the <a href="#element-function"><code>xsl:function</code></a> element
(see <a href="#stylesheet-functions"><b>10.3 Stylesheet Functions</b></a>) after any <a href="#element-param"><code>xsl:param</code></a> elements and before the
<a href="#element-result"><code>xsl:result</code></a> element. Such a variable
is known as a <b>local variable</b>.</p><p><a name="dt-template-parameter" id="dt-template-parameter" title="template parameter"></a>
An <a href="#element-param"><code>xsl:param</code></a> element may appear as a child of an <a href="#element-template"><code>xsl:template</code></a>
element, before any non-<a href="#element-param"><code>xsl:param</code></a> children of that element. Such a parameter
is known as a <b>template parameter</b>. A template parameter is a 
<a title="local variable" href="#dt-local-variable">local variable</a> with the additional 
property that its value can be set when the template
is called, using any of the instructions <a href="#element-call-template"><code>xsl:call-template</code></a>, <a href="#element-apply-templates"><code>xsl:apply-templates</code></a>,
or <a href="#element-apply-imports"><code>xsl:apply-imports</code></a>.</p><p><a name="dt-function-parameter" id="dt-function-parameter" title="function parameter"></a>
An <a href="#element-param"><code>xsl:param</code></a> element may appear as a child of an <a href="#element-function"><code>xsl:function</code></a>
element, before any non-<a href="#element-param"><code>xsl:param</code></a> children of that element. Such a parameter
is known as a <b>function parameter</b>. A function parameter is a 
<a title="local variable" href="#dt-local-variable">local variable</a> with the additional 
property that its value can be set when the function
is called, using a function call in an XPath <a title="expression" href="#dt-expression">expression</a>.</p><p>The result of evaluating
a local <a href="#element-variable"><code>xsl:variable</code></a> or <a href="#element-param"><code>xsl:param</code></a> element (that is,
the contribution it makes to the result of the
 <a title="content constructor" href="#dt-content-constructor">content constructor</a> it is part of)
is an empty sequence.</p></div><div class="div2">
<h3><a name="d5e7759" id="d5e7759"></a>9.7 Scope of Variables</h3><p>For any  <a title="variable-binding element" href="#dt-variable-binding-element">variable-binding element</a>, 
there is a region
of the stylesheet within which the binding is visible.  
The set of variable bindings in scope for an
XPath <a title="expression" href="#dt-expression">expression</a> consists of those bindings that are visible at the point in
the stylesheet where the expression occurs.</p><p>A global <a title="variable-binding element" href="#dt-variable-binding-element">variable binding element</a> is
visible everywhere in the stylesheet (including other stylesheet modules) except within the 
<a href="#element-variable"><code>xsl:variable</code></a> or <a href="#element-param"><code>xsl:param</code></a>
element itself and any region where it is
<a title="shadows" href="#dt-shadows">shadowed</a> by another variable binding.</p><p>A local <a title="variable-binding element" href="#dt-variable-binding-element">variable binding element</a>
 is visible for all following siblings and their descendants.
The binding is not visible for the <a href="#element-variable"><code>xsl:variable</code></a> or <a href="#element-param"><code>xsl:param</code></a>
element itself.</p><p><a name="dt-shadows" id="dt-shadows" title="shadows"></a>A binding <b>shadows</b> another
binding if the binding occurs at a point where the other binding is visible, and
the bindings have the same name.
 
  It is not an error if a binding
established by a local <a href="#element-variable"><code>xsl:variable</code></a> or <a href="#element-param"><code>xsl:param</code></a>
					<a title="shadows" href="#dt-shadows">shadows</a> a global binding. In this case, the global
binding will not be visible in the region of the stylesheet where it
is shadowed by the other binding.</p><div class="example"><p>Thus, the following is allowed:</p><div class="exampleInner"><pre>&lt;xsl:param name="x" select="1"/&gt;
&lt;xsl:template name="foo"&gt;
  &lt;xsl:variable name="x" select="2"/&gt;
&lt;/xsl:template&gt;</pre></div></div><p>It is also not an error if a binding established by a local <a href="#element-variable"><code>xsl:variable</code></a> or
<a href="#element-param"><code>xsl:param</code></a> element <a title="shadows" href="#dt-shadows">shadows</a>
another binding established by another local <a href="#element-variable"><code>xsl:variable</code></a> 
or <a href="#element-param"><code>xsl:param</code></a>. However, such shadowing is discouraged and
implementations may output a warning when it occurs. </p><div class="example"><p>Thus, the following is not an error, but is discouraged, because
					the effect is probably not what was intended. The template outputs
					<code>&lt;x value="1"/&gt;</code>, because the declaration of the inner
					variable named <code>$x</code> has no effect on the value of the outer
					variable named <code>$x</code>.</p><div class="exampleInner"><pre>&lt;xsl:template name="foo"&gt;
  &lt;xsl:variable name="x" select="1"/&gt;
  &lt;xsl:for-each select="1 to 5"&gt;
    &lt;xsl:variable name="x" select="$x+1"/&gt;
  &lt;xsl:for-each&gt;
  &lt;x value="{$x}"/&gt;
&lt;/xsl:template&gt;</pre></div></div><blockquote><table width="90%"><tr><td width="10%" align="left" valign="top"><b>Note:</b></td><td align="left" valign="top"><p>Once a variable has been given a value, the value cannot subsequently
be changed. XSLT does not provide an equivalent to the 
assignment operator  available in many procedural programming languages. 
</p><p>This is because an assignment operator
 would make it harder to create an implementation that
processes a document other than in a batch-like way, starting at the
beginning and continuing through to the end.</p></td></tr></table></blockquote><p>As well as global variables and local variables, an XPath
					 <a title="expression" href="#dt-expression">expression</a> may also declare range variables
for use locally within an expression. For details, see <a href="#XPATH20">[XPath 2.0]</a>.</p><p>Where a reference to a variable occurs in an XPath expression, it is resolved first by reference
to range variables that are in scope, then by reference to local variables and parameters, and finally by reference
to global variables and parameters. A range variable may shadow a local variable or a global variable.
XPath also allows a range variable to shadow another range variable.</p></div><div class="div2">
<h3><a name="circularity" id="circularity"></a>9.8 Circular Definitions</h3><p>
					<a name="dt-circularity" id="dt-circularity" title="circularity"></a>If th
					e <a title="expression" href="#dt-expression">expression</a> or <a title="content constructor" href="#dt-content-constructor">content constructor</a>
specifying the value of a <a title="global variable" href="#dt-global-variable">global variable</a> <var>X</var> references a
global variable <var>Y</var>, then the value for <var>Y</var> must
be computed before the value of <var>X</var>.   If it
is impossible to do this for all global variable definitions,
then a <b>circularity</b> is said to exist.
				</p><p>For example the following two declarations create a circularity:</p><div class="exampleInner"><pre>&lt;xsl:variable name="x" select="$y+1"/&gt;

&lt;xsl:variable name="y" select="$x+1"/&gt;</pre></div><p>The definition of a global variable can be circular even if no other variable is involved.
For example the following two declarations (see <a href="#stylesheet-functions"><b>10.3 Stylesheet Functions</b></a> for
an explanation of the <a href="#element-function"><code>xsl:function</code></a> element) also create a circularity:</p><div class="exampleInner"><pre>&lt;xsl:variable name="x" select="my:f()"/&gt;

&lt;xsl:function name="my:f"&gt;
  &lt;xsl:result select="$x"/&gt;
&lt;/xsl:function&gt;
</pre></div><p>The definition of a variable is also circular if the evaluation of the
variable invokes an <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction and the variable is
referenced in the pattern used in the <code>match</code> attribute of any template rule
in the stylesheet. For example the following definition is circular:</p><div class="exampleInner"><pre>&lt;xsl:variable name="x"&gt;
  &lt;xsl:apply-templates select="//param[1]"/&gt;
&lt;/xsl:variable&gt;

&lt;xsl:template match="param[$x]"&gt;1&lt;/xsl:template&gt;
</pre></div><p>Similarly, a variable definition is circular if it causes a call on the <a href="#function-key"><b>key</b></a>
function, and the definition of that <a title="" href="#key">key</a> refers to that variable in its
<code>match</code> or <code>use</code> attributes. So the following definition is circular:</p><div class="exampleInner"><pre>&lt;xsl:variable name="x" select="my:f(10)"/&gt;

&lt;xsl:function name="my:f"&gt;
  &lt;xsl:param name="arg1"/&gt;
  &lt;xsl:result select="key('k', $arg1)"/&gt;
&lt;/xsl:function&gt;

&lt;xsl:key name="k" match="item[@code=$x]" use="@desc"/&gt;
</pre></div><p>
					<a name="d5e7955"><small>[ERR062] </small></a>In general, a <a title="circularity" href="#dt-circularity">circularity</a>
 in a stylesheet is a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a>.
The <a title="processor" href="#dt-processor">processor</a> must signal the error.
					
However, as with all other dynamic errors, an implementation will signal
the error only if it actually executes the instructions and expressions that
participate in the circularity. 
Because different implementations may optimize the execution of a stylesheet
in different ways, it is
 <a title="implementation-dependent" href="#dt-implementation-dependent">implementation-dependent</a>
 whether a particular circularity will actually be signaled.</p><p>For example, in the following declarations, the function declares a
default value for a parameter, but it returns a result that does
not require the default value to be evaluated. It is <a title="implementation-dependent" href="#dt-implementation-dependent">implementation-dependent</a>
whether the default value is actually evaluated, and it is therefore
implementation-dependent whether the circularity is signaled as an error:</p><div class="exampleInner"><pre>&lt;xsl:variable name="x" select="my:f(1)/&gt;

&lt;xsl:function name="my:f"&gt;
  &lt;xsl:param name="a" select="$x"/&gt;
  &lt;xsl:result select="$a"/&gt;
&lt;/xsl:function&gt;
</pre></div><p>Circularities usually involve global variables or parameters, but they
can also exist between <a title="" href="#key">key</a> definitions (see <a href="#key"><b>16.3 Keys</b></a>), between
named <a title="attribute set" href="#dt-attribute-set">attribute set</a>s (see <a href="#attribute-sets"><b>10.2 Named Attribute Sets</b></a>),
 or between
any combination of these constructs. For example, a circularity exists if a
key definition invokes a function that references an attribute set that calls the <a href="#function-key"><b>key</b></a>
function, supplying the name of the original key definition as an argument.</p><p>Circularity is not the same as recursion. Stylesheet functions
 (see <a href="#stylesheet-functions"><b>10.3 Stylesheet Functions</b></a>)
and named templates (see <a href="#named-templates"><b>10.1 Named Templates</b></a>) may
call other functions and named templates without restriction. With careless coding,
recursion may be non-terminating. Implementations are required
to signal circularity as a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a>, 
but they are not required to detect non-terminating recursion.</p></div></div><div class="div1">
<h2><a name="callable-components" id="callable-components"></a>10 Callable Components</h2><p>This section describes three constructs that can be used
to provide subroutine-like functionality that can be invoked from anywhere in
the stylesheet: named templates (see <a href="#named-templates"><b>10.1 Named Templates</b></a>), named attribute
sets (see <a href="#attribute-sets"><b>10.2 Named Attribute Sets</b></a>) and
 <a title="stylesheet function" href="#dt-stylesheet-function">stylesheet functions</a>
(see <a href="#stylesheet-functions"><b>10.3 Stylesheet Functions</b></a>).</p><div class="div2">
<h3><a name="named-templates" id="named-templates"></a>10.1 Named Templates</h3><p class="element-syntax"><a name="element-call-template"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:call-template<br>&nbsp;&nbsp;<b>name</b> = <var>qname</var>&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <a href="#element-with-param">xsl:with-param</a>* --&gt;<br>&lt;/xsl:call-template&gt;</code></p><p>
					<a name="dt-named-template" id="dt-named-template" title="named template"></a>Templates can be invoked by name.  
An <a href="#element-template"><code>xsl:template</code></a>
element with a <code>name</code> attribute specifies a <b>named template</b>.
The value of the <code>name</code> attribute is a <a title="QName" href="#dt-qname">QName</a>, which is expanded as described
in <a href="#qname"><b>5.1 Qualified Names</b></a>. If an <a href="#element-template"><code>xsl:template</code></a> element has
a <code>name</code> attribute, it may, but need not, also have a
<code>match</code> attribute.  An <a href="#element-call-template"><code>xsl:call-template</code></a>
element invokes a template by name; it has a required
<code>name</code> attribute that identifies the template to be
invoked.  Unlike <a href="#element-apply-templates"><code>xsl:apply-templates</code></a>, the
<a href="#element-call-template"><code>xsl:call-template</code></a> instruction does not change 
the <a title="focus" href="#dt-focus">focus</a>.</p><p>The <code>match</code>, <code>mode</code> and <code>priority</code> attributes on an
<a href="#element-template"><code>xsl:template</code></a> element do not affect whether the template
is invoked by an <a href="#element-call-template"><code>xsl:call-template</code></a> element.  Similarly,
the <code>name</code> attribute on an <a href="#element-template"><code>xsl:template</code></a>
element does not affect whether the template is invoked by an
<a href="#element-apply-templates"><code>xsl:apply-templates</code></a> element.</p><p>
					<a name="d5e8103"><small>[ERR063] </small></a>It is a <a title="static error" href="#dt-static-error">static error</a> if a
 stylesheet contains more than one template with
the same name and the same <a title="import precedence" href="#dt-import-precedence">import
precedence</a>.</p><p>The result of evaluating an <a href="#element-call-template"><code>xsl:call-template</code></a>
instruction is the node sequence produced by evaluating the <a title="content constructor" href="#dt-content-constructor">content constructor</a>
contained in the associated <a href="#element-template"><code>xsl:template</code></a> element. The associated <a href="#element-template"><code>xsl:template</code></a>
element is the one whose <code>name</code> attribute matches the <code>name</code> attribute of the <a href="#element-call-template"><code>xsl:call-template</code></a>
instruction and that has higher <a title="import precedence" href="#dt-import-precedence">import precedence</a> than any other
template with this name.</p><p><a name="d5e8140"><small>[ERR064] </small></a>It is a <a title="static error" href="#dt-static-error">static error</a> if
a stylesheet contains an <a href="#element-call-template"><code>xsl:call-template</code></a> instruction whose <code>name</code> attribute does
not match the <code>name</code> attribute of any <a href="#element-template"><code>xsl:template</code></a> in the stylesheet.</p><div class="div3">
<h4><a name="with-param" id="with-param"></a>10.1.1 Passing Parameters to Templates</h4><p class="element-syntax"><a name="element-with-param"></a><code>&lt;xsl:with-param<br>&nbsp;&nbsp;<b>name</b> = <var>qname</var><br>&nbsp;&nbsp;select = <var>expression</var><br>&nbsp;&nbsp;type-information = "strict" | "lax" | "preserve" | "none"&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>content-constructor</var> --&gt;<br>&lt;/xsl:with-param&gt;</code></p><p>Parameters are passed to templates using the
<a href="#element-with-param"><code>xsl:with-param</code></a> element.  The required <code>name</code>
attribute specifies the name of the <a title="template parameter" href="#dt-template-parameter">template parameter</a> (the variable the value
of whose binding is to be replaced).  The value of the
<code>name</code> attribute is a <a title="QName" href="#dt-qname">QName</a>, which is expanded as described
in <a href="#qname"><b>5.1 Qualified Names</b></a>.</p><p>
						<a href="#element-with-param"><code>xsl:with-param</code></a> is allowed
within <a href="#element-call-template"><code>xsl:call-template</code></a>,
<a href="#element-apply-templates"><code>xsl:apply-templates</code></a> and <a href="#element-apply-imports"><code>xsl:apply-imports</code></a>.
<a name="d5e8210"><small>[ERR065] </small></a>It is a <a title="static error" href="#dt-static-error">static error</a> if
a single <a href="#element-call-template"><code>xsl:call-template</code></a>,
<a href="#element-apply-templates"><code>xsl:apply-templates</code></a> or <a href="#element-apply-imports"><code>xsl:apply-imports</code></a>
element contains more than one <a href="#element-with-param"><code>xsl:with-param</code></a> element
with the same name.</p><p>The value of the parameter is
specified in the same way as for <a href="#element-variable"><code>xsl:variable</code></a> and
<a href="#element-param"><code>xsl:param</code></a> (see <a href="#variable-values"><b>9.3 Values of Variables and Parameters</b></a>.  The <a title="focus" href="#dt-focus">focus</a> used
for computing the value specified by <a href="#element-with-param"><code>xsl:with-param</code></a>
element is the same as that used for the
<a href="#element-apply-templates"><code>xsl:apply-templates</code></a>, <a href="#element-apply-imports"><code>xsl:apply-imports</code></a>, or
<a href="#element-call-template"><code>xsl:call-template</code></a>
element within which it occurs.  It is not an error to pass a
parameter <var>x</var> to a template that does not have an
<a title="template parameter" href="#dt-template-parameter">template parameter</a> named <var>x</var>; the parameter is
simply ignored.</p><div><blockquote><p><b><a href="#issue-static-checks-on-call-template">Issue 150 (static-checks-on-call-template)</a>: </b>We currently state that it is not an error if a parameter is supplied when calling
    a template, and the template does not declare such a parameter. This makes sense on apply-templates.
    On call-template, we could report this as a static error. This is related to the introduction of
    required="yes" on xsl:param, which can (in the case of call-template) lead to a static error.</p></blockquote></div><p><a name="d5e8263"><small>[ERR066] </small></a>In the case of <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> and
<a href="#element-apply-imports"><code>xsl:apply-imports</code></a>, it is a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> if
the template that is invoked declares a <a title="template parameter" href="#dt-template-parameter">template parameter</a>
 with <code>required="yes"</code> and no value for
this parameter is supplied by the calling instruction. The processor must signal 
the error.</p><p><a name="d5e8283"><small>[ERR067] </small></a>In the case of <a href="#element-call-template"><code>xsl:call-template</code></a>,
it is a <a title="static error" href="#dt-static-error">static error</a> if
the template that is invoked declares a <a title="template parameter" href="#dt-template-parameter">template parameter</a> 
with <code>required="yes"</code> and no value for
this parameter is supplied by the calling instruction.</p><p>The <code>type-information</code> attribute determines what
 type annotations will be present on the element and attribute nodes of the constructed
 tree. This attribute must be omitted if the content of the <a href="#element-with-param"><code>xsl:with-param</code></a>
 element is empty. The default value is <code>none</code>. For details, see <a href="#temporary-trees"><b>9.4 Temporary Trees</b></a>.</p><div class="example"><p>This example defines a named template for a
<code>numbered-block</code> with an argument to control the format of
the number.</p><div class="exampleInner"><pre>&lt;xsl:template name="numbered-block"&gt;
  &lt;xsl:param name="format"&gt;1. &lt;/xsl:param&gt;
  &lt;fo:block&gt;
    &lt;xsl:number format="{$format}"/&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/fo:block&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="ol//ol/li"&gt;
  &lt;xsl:call-template name="numbered-block"&gt;
    &lt;xsl:with-param name="format"&gt;a. &lt;/xsl:with-param&gt;
  &lt;/xsl:call-template&gt;
&lt;/xsl:template&gt;</pre></div></div><blockquote><table width="90%"><tr><td width="10%" align="left" valign="top"><b>Note:</b></td><td align="left" valign="top"><p>Arguments to <a title="stylesheet function" href="#dt-stylesheet-function">stylesheet functions</a> are supplied as part of an XPath
function call: see <a href="#stylesheet-functions"><b>10.3 Stylesheet Functions</b></a>
						</p></td></tr></table></blockquote></div></div><div class="div2">
<h3><a name="attribute-sets" id="attribute-sets"></a>10.2 Named Attribute Sets</h3><p class="element-syntax"><a name="element-attribute-set"></a><code>&lt;!-- Category: declaration --&gt;<br>&lt;xsl:attribute-set<br>&nbsp;&nbsp;<b>name</b> = <var>qname</var><br>&nbsp;&nbsp;use-attribute-sets = <var>qnames</var>&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <a href="#element-attribute">xsl:attribute</a>* --&gt;<br>&lt;/xsl:attribute-set&gt;</code></p><p>
					<a name="dt-attribute-set" id="dt-attribute-set" title="attribute set"></a>The
 <a href="#element-attribute-set"><code>xsl:attribute-set</code></a> element defines a named <b>attribute set</b>: that is,
 a collection of attribute values that can be used repeatedly on different elements in the
 result tree.
The <code>name</code> attribute specifies the name of the
attribute set.  The value of the <code>name</code> attribute is a <a title="QName" href="#dt-qname">QName</a>, which is expanded as described
in <a href="#qname"><b>5.1 Qualified Names</b></a>. The content of the <a href="#element-attribute-set"><code>xsl:attribute-set</code></a>
element consists of zero or more <a href="#element-attribute"><code>xsl:attribute</code></a> elements
that specify the attributes in the set.</p><p>
					<a title="attribute set" href="#dt-attribute-set">Attribute sets</a> are used by specifying a
<code>use-attribute-sets</code> attribute on the <a href="#element-element"><code>xsl:element</code></a>,
<a href="#element-copy"><code>xsl:copy</code></a> (see <a href="#copying"><b>11.8 Copying Nodes from a Source Tree to a Result Tree</b></a>) or
<a href="#element-attribute-set"><code>xsl:attribute-set</code></a> elements.
  The value of the <code>use-attribute-sets</code> 
attribute is a whitespace-separated
list of names of attribute sets.  Each name is specified as a <a title="QName" href="#dt-qname">QName</a>, which is expanded as described
in <a href="#qname"><b>5.1 Qualified Names</b></a>.  Specifying a
<code>use-attribute-sets</code> attribute is equivalent to adding
<a href="#element-attribute"><code>xsl:attribute</code></a> elements for each of the attributes in each
of the named attribute sets to the beginning of the content of the
element with the <code>use-attribute-sets</code> attribute, in the
same order in which the names of the attribute sets are specified in
the <code>use-attribute-sets</code> attribute.  
<a name="d5e8417"><small>[ERR068] </small></a>It is a
 <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> if use
of <code>use-attribute-sets</code> attributes on
<a href="#element-attribute-set"><code>xsl:attribute-set</code></a> elements causes an attribute set to
use itself, directly or indirectly. 
The <a title="processor" href="#dt-processor">processor</a> must signal the error
					
				</p><p>
					<a title="attribute set" href="#dt-attribute-set">Attribute sets</a> can also be used by specifying an
<code>xsl:use-attribute-sets</code> attribute on 
a <a title="literal result element" href="#dt-literal-result-element">literal result element</a>.  
The value of the <code>xsl:use-attribute-sets</code>
attribute is a whitespace-separated list of names of attribute sets.
The <code>xsl:use-attribute-sets</code> attribute has the same effect
as the <code>use-attribute-sets</code> attribute on
<a href="#element-element"><code>xsl:element</code></a> with the additional rule that attributes
specified on the literal result element itself are treated as if they
were specified by <a href="#element-attribute"><code>xsl:attribute</code></a> elements before any
actual <a href="#element-attribute"><code>xsl:attribute</code></a> elements but after any
<a href="#element-attribute"><code>xsl:attribute</code></a> elements implied by the
<code>xsl:use-attribute-sets</code> attribute.  Thus, in
the node sequence produced by evaluating the content constructor for a literal
result element, attributes from attribute sets named in an
<code>xsl:use-attribute-sets</code> attribute will appear first, in
the order listed in the attribute; these
will be followed by attributes specified on the
literal result element will be added; finally, any attributes
specified by <a href="#element-attribute"><code>xsl:attribute</code></a> elements will appear.  Since
in a sequence of attribute nodes produced by a content constructor,
only the last attribute with a given <a title="expanded-QName" href="#dt-expanded-qname">expanded-QName</a> 
has any effect (see <a href="#content-constructors"><b>5.6 Content Constructors</b></a>),  
this means that attributes specified
in attribute sets can be overridden by attributes specified on the
literal result element itself.</p><p>The <a title="content constructor" href="#dt-content-constructor">content constructor</a>
 within each <a href="#element-attribute"><code>xsl:attribute</code></a> element in an
<a href="#element-attribute-set"><code>xsl:attribute-set</code></a> element is evaluated each time the
<a title="attribute set" href="#dt-attribute-set">attribute set</a> is used; it is evaluated using the same 
<a title="focus" href="#dt-focus">focus</a>
 as is used for evaluating the element bearing
the <code>use-attribute-sets</code> or
<code>xsl:use-attribute-sets</code> attribute. However, it is the
position in the stylesheet of the <a href="#element-attribute"><code>xsl:attribute</code></a> element
rather than of the element bearing the <code>use-attribute-sets</code>
or <code>xsl:use-attribute-sets</code> attribute that determines which
variable bindings are visible (see <a href="#variables-and-parameters"><b>9 Variables and Parameters</b></a>); thus,
only global variables and parameters and local variables declared within
an <a href="#element-attribute"><code>xsl:attribute</code></a> instruction are visible.</p><div class="example"><p>The following example creates a named <a title="attribute set" href="#dt-attribute-set">attribute set</a>
						<code>title-style</code> and uses it in a <a title="template rule" href="#dt-template-rule">template rule</a>.</p><div class="exampleInner"><pre>&lt;xsl:template match="chapter/heading"&gt;
  &lt;fo:block font-stretch="condensed" xsl:use-attribute-sets="title-style"&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/fo:block&gt;
&lt;/xsl:template&gt;

&lt;xsl:attribute-set name="title-style"&gt;
  &lt;xsl:attribute name="font-size"&gt;12pt&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="font-weight"&gt;bold&lt;/xsl:attribute&gt;
&lt;/xsl:attribute-set&gt;</pre></div></div><p>Multiple definitions of an <a title="attribute set" href="#dt-attribute-set">attribute set</a> with the same
<a title="expanded-QName" href="#dt-expanded-qname">expanded-QName</a> are merged.  An attribute from a definition that has
higher <a title="import precedence" href="#dt-import-precedence">import precedence</a>
takes precedence over an attribute from a definition that has lower
<a title="import precedence" href="#dt-import-precedence">import precedence</a>.  
<a name="d5e8549"><small>[ERR069] </small></a>It
is a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> if there
 are two attribute sets that have the same
<a title="expanded-QName" href="#dt-expanded-qname">expanded-QName</a> and equal import precedence and that both contain
the same attribute, unless there is a definition of the attribute set
with higher <a title="import precedence" href="#dt-import-precedence">import
precedence</a> that also contains the attribute.  The <a title="processor" href="#dt-processor">processor</a>
 must either signal the error, or
must recover by choosing from amongst the definitions that specify the
attribute that have the highest import precedence the one that was
specified last in <a title="declaration order" href="#dt-declaration-order">declaration
 order</a>.
					
				</p><p>Where the attributes in an
<a title="attribute set" href="#dt-attribute-set">attribute set</a> were specified is relevant only in merging the
attributes into the attribute set; it makes no difference when the
attribute set is used. For each
attribute set name occurring in a <code>use-attribute-sets</code> attribute on
an <a href="#element-attribute-set"><code>xsl:attribute-set</code></a> element, all definitions of an
attribute set with that name must be merged <em>before</em> the
<code>use-attribute-sets</code> attribute is replaced by the
equivalent sequence of <a href="#element-attribute"><code>xsl:attribute</code></a> child elements.  Any
<code>use-attribute-sets</code> attribute on an
<a href="#element-attribute-set"><code>xsl:attribute-set</code></a> element must be replaced by the
equivalent sequence of <a href="#element-attribute"><code>xsl:attribute</code></a> child elements
<em>before</em> that <a href="#element-attribute-set"><code>xsl:attribute-set</code></a> element is
merged with other <a href="#element-attribute-set"><code>xsl:attribute-set</code></a> elements with the
same <a title="expanded-QName" href="#dt-expanded-qname">expanded-QName</a>. When <a href="#element-attribute-set"><code>xsl:attribute-set</code></a> elements with
the same <a title="expanded-QName" href="#dt-expanded-qname">expanded-QName</a> are merged, any <a href="#element-attribute"><code>xsl:attribute</code></a>
child elements added to replace a <code>use-attribute-sets</code>
attribute are treated exactly as if they had originally been specified
in the stylesheet as child elements.</p></div><div class="div2">
<h3><a name="stylesheet-functions" id="stylesheet-functions"></a>10.3 Stylesheet Functions</h3><p>
					<a name="dt-stylesheet-function" id="dt-stylesheet-function" title="stylesheet function"></a>An <a href="#element-function"><code>xsl:function</code></a> 
declaration declares the name, parameters, and implementation of a
 <b>stylesheet function</b>
 that can be called from any XPath
<a title="expression" href="#dt-expression">expression</a> within the stylesheet.
					<a name="d5e8640"><small>[ERR070] </small></a>A stylesheet function must have a prefixed name,
to remove any risk of a clash with a system-defined function. It is a 
<a title="static error" href="#dt-static-error">static error</a> if the name has no prefix.
				</p><blockquote><table width="90%"><tr><td width="10%" align="left" valign="top"><b>Note:</b></td><td align="left" valign="top"><p>To prevent the namespace declaration used for the function name appearing in the
result document, use the <code>exclude-result-prefixes</code>
						 attribute
on the <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> element: see <a href="#lre-namespaces"><b>11.1.3 Namespace Nodes for Literal Result Elements</b></a>.</p></td></tr></table></blockquote><div class="div3">
<h4><a name="d5e8663" id="d5e8663"></a>10.3.1 Defining a Stylesheet Function</h4><p class="element-syntax"><a name="element-function"></a><code>&lt;!-- Category: declaration --&gt;<br>&lt;xsl:function<br>&nbsp;&nbsp;<b>name</b> = <var>qname</var><br>&nbsp;&nbsp;override = "yes" | "no"&gt;<br>&nbsp;&nbsp;&lt;!-- Content: (<a href="#element-param">xsl:param</a>*, (<a href="#element-variable">xsl:variable</a> | <a href="#element-message">xsl:message</a>)*, <a href="#element-result">xsl:result</a>) --&gt;<br>&lt;/xsl:function&gt;</code></p><p>The <a href="#element-function"><code>xsl:function</code></a> declaration
 defines a <a title="stylesheet function" href="#dt-stylesheet-function">stylesheet function</a> that
can be called from any XPath <a title="expression" href="#dt-expression">expression</a> 
used in the stylesheet (including
an XPath expression used within a predicate in 
a <a title="pattern" href="#dt-pattern">pattern</a>).
  The <code>name</code> attribute specifies the name of the
function.  The value of the <code>name</code> attribute is a <a title="QName" href="#dt-qname">QName</a>, 
which is expanded as described
in <a href="#qname"><b>5.1 Qualified Names</b></a>
						<a name="d5e8708"><small>[ERR071] </small></a>The <code>name</code> attribute
 
  must be in a non-null namespace: that is,
 it must be written with a prefix..</p><p>An <a href="#element-function"><code>xsl:function</code></a> declaration can only
appear as a top-level element in the stylesheet.</p><p>The content of the <a href="#element-function"><code>xsl:function</code></a>
element consists of zero or more <a href="#element-param"><code>xsl:param</code></a> elements
that specify the formal arguments of the function, followed by
zero or more <a href="#element-variable"><code>xsl:variable</code></a> elements that can be used
to compute intermediate results, followed by a mandatory 
<a href="#element-result"><code>xsl:result</code></a> element that defines the value to be
returned by the function. It is also possible
to include <a href="#element-message"><code>xsl:message</code></a> elements after the
<a href="#element-param"><code>xsl:param</code></a> elements and before the <a href="#element-result"><code>xsl:result</code></a>, 
to provide diagnostic output.</p><p>When a stylesheet function is called, the number of arguments in the function
call must match the number of <a href="#element-param"><code>xsl:param</code></a> elements in the function definition.
Optional arguments are not allowed. <a name="d5e8753"><small>[ERR072] </small></a>Because arguments to a stylesheet
function call must all be specified, the <a href="#element-param"><code>xsl:param</code></a> elements within an
<a href="#element-function"><code>xsl:function</code></a> element must not specify a default value: this means they
must be empty, and must have no <code>select</code> attribute.
					</p><blockquote><table width="90%"><tr><td width="10%" align="left" valign="top"><b>Note:</b></td><td align="left" valign="top"><p>There are no special restrictions on what can appear within an
<a href="#element-variable"><code>xsl:variable</code></a> element. For example, the <a href="#element-variable"><code>xsl:variable</code></a> element
can contain <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> or
<a href="#element-call-template"><code>xsl:call-template</code></a> instructions.</p></td></tr></table></blockquote><p>If a stylesheet contains declarations of two or more
 <a title="stylesheet function" href="#dt-stylesheet-function">stylesheet functions</a> with the same <a title="expanded-QName" href="#dt-expanded-qname">expanded-QName</a>,
the one with highest <a title="import precedence" href="#dt-import-precedence">import precedence</a>
 is used. <a name="d5e8791"><small>[ERR073] </small></a>It is a <a title="static error" href="#dt-static-error">static error</a> for
a stylesheet to contain two or more functions with the same <a title="expanded-QName" href="#dt-expanded-qname">expanded-QName</a>
and the same import precedence, unless there is another function with the
same <a title="expanded-QName" href="#dt-expanded-qname">expanded-QName</a> and a higher import precedence.
					</p><p>If a <a title="stylesheet function" href="#dt-stylesheet-function">stylesheet function</a> has been defined with a particular <a title="expanded-QName" href="#dt-expanded-qname">expanded-QName</a>, then a call
on <a href="#function-function-available"><b>function-available</b></a> will return true when called with
an argument that is a <a title="QName" href="#dt-qname">QName</a> that expands to this same <a title="expanded-QName" href="#dt-expanded-qname">expanded-QName</a>.</p><blockquote><table width="90%"><tr><td width="10%" align="left" valign="top"><b>Note:</b></td><td align="left" valign="top"><p>Functions are not polymorphic. Although the XPath function call mechanism allows two
						functions to have the same name and different arity (number of arguments), XSLT does not
						allow two stylesheet functions to be declared with the same name.</p></td></tr></table></blockquote><p>The optional <code>override</code> attribute defines what happens if this function
has the same name as a function provided by the implementor or made available in the static context
using an implementation-defined mechanism. If the <code>override</code> attribute has the value <code>yes</code>,
then this function is used in preference; if it has the value <code>no</code>, then the other function
is used in preference. The default value is <code>yes</code>.</p><blockquote><table width="90%"><tr><td width="10%" align="left" valign="top"><b>Note:</b></td><td align="left" valign="top"><p>Specifying <code>override="yes"</code> ensures interoperable behavior: 
the same code will execute with all processors. Specifying <code>override="no"</code> is useful when writing
a fallback implementation of a function that is available with some processors but not others: it
allows the vendor's implementation of the function to be used in preference to the stylesheet
implementation, which is useful since the vendor's implementation will often be more efficient.</p></td></tr></table></blockquote><p>The <a href="#element-param"><code>xsl:param</code></a> elements define the formal arguments to the
function. These are interpreted positionally. When the function is called
using a function-call in an XPath <a title="expression" href="#dt-expression">expression</a>, the first argument supplied is
assigned to the first <a href="#element-param"><code>xsl:param</code></a> element, the second argument
supplied is assigned to the second <a href="#element-param"><code>xsl:param</code></a> element, and so on.
<a name="d5e8865"><small>[ERR074] </small></a>It is an <a title="static error" href="#dt-static-error">static error</a> if the
number of arguments supplied in the function call is different from the number of
							<a href="#element-param"><code>xsl:param</code></a> elements in the function definition.
						
					</p><p>The <code>as</code> attribute of the <a href="#element-param"><code>xsl:param</code></a> element defines the
required type of the parameter. The rules for converting the values of the actual arguments
supplied in the function call to the types required by each <a href="#element-param"><code>xsl:param</code></a> element
are defined in <a href="#XPATH20">[XPath 2.0]</a>. 
The rules that apply are those for the case where the "XPath 1.0 backwards compatibility flag"
is not set.
If the value cannot be converted to the required type,
a type exception is reported. If the <code>as</code> attribute is omitted, the effective
default is <code>item*</code>, which means that no conversion takes place and any value is accepted.</p><p>
						<a name="d5e8928"><small>[ERR075] </small></a>Within the body of a stylesheet function, the
<a title="focus" href="#dt-focus">focus</a>
 is initially undefined; this means that any attempt to reference the context item, context position,
 or context size is a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a>. The processor must signal the error.
						
It is not possible within the body of the stylesheet function to access the values of
local variables that were in scope in the place where the function call was written. Global
variables, however, remain available.</p><p>Any <a href="#element-variable"><code>xsl:variable</code></a> elements within the function are evaluated
 in the normal way: (see <a href="#variables"><b>9.1 Variables</b></a>).</p></div><div class="div3">
<h4><a name="d5e8948" id="d5e8948"></a>10.3.2 Returning the Result</h4><p class="element-syntax"><a name="element-result"></a><code>&lt;xsl:result<br>&nbsp;&nbsp;select = <var>expression</var><br>&nbsp;&nbsp;as = <var>sequence-type</var><br>&nbsp;&nbsp;type-information = "strict" | "lax" | "preserve" | "none"&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>content-constructor</var> --&gt;<br>&lt;/xsl:result&gt;</code></p><p>The <a href="#element-result"><code>xsl:result</code></a> element always appears (and only appears) as the last
child of an <a href="#element-function"><code>xsl:function</code></a> element. It defines the result that is returned
when the function is evaluated.</p><p>The value is established in the same way as for an <a href="#element-variable"><code>xsl:variable</code></a> element:
if there is a <code>select</code> attribute, the result is obtained by evaluating
the <a title="expression" href="#dt-expression">expression</a> contained in the <code>select</code> attribute; 
if the <a href="#element-result"><code>xsl:result</code></a> element is not empty, the result is the document node of
a <a title="" href="#dt-temporary-tree">temporary tree</a> constructed as described in 
<a href="#variable-values"><b>9.3 Values of Variables and Parameters</b></a>.
If there is no <code>select</code> attribute and no content constructor, the result
is a zero-length string; it is an <a title="static error" href="#dt-static-error">static error</a> if
 there is both a <code>select</code> attribute 
and a non-empty content constructor.</p><p>The optional <code>as</code> attribute indicates the 
<a title="required type" href="#dt-required-type">required type</a> of the result.
The value of the <code>as</code> attribute is a <u>SequenceType</u>, as defined in <a href="#XPATH20">[XPath 2.0]</a>.
<a name="d5e9019"><small>[ERR076] </small></a>If the <code>as</code> attribute 

is specified, then the calculated result is converted to the required type,
using the <a title="argument conversion rules" href="#dt-argument-conversion-rules">argument conversion rules</a>.
It is a <a title="type errors" href="#dt-type-error">type error</a>
if this conversion fails. 
If the <code>as</code> attribute is omitted, the calculated result is used
as supplied, and no conversion takes place.</p><p>The <code>type-information</code> attribute determines what
 type annotations will be present on the element and attribute nodes of the constructed
 tree. This attribute must be omitted if the content of the <a href="#element-result"><code>xsl:result</code></a>
 element is empty. The default value is <code>none</code>. For details, see <a href="#temporary-trees"><b>9.4 Temporary Trees</b></a>.</p><div class="example"><p>The following example creates a <a title="stylesheet function" href="#dt-stylesheet-function">stylesheet function</a>
 named
<code>str:reverse</code> that reverses the words in a supplied sentence, 
and then invokes this function from within a <a title="template rule" href="#dt-template-rule">template rule</a>. </p><div class="exampleInner"><pre>&lt;xsl:transform 
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:str="http://example.com/namespace"
  version="2.0"
  exclude-result-prefixes="str"&gt;

&lt;xsl:function name="str:reverse"&gt;
  &lt;xsl:param name="sentence" as="xs:string"/&gt;
  &lt;xsl:result  
     select="if (contains($sentence, ' '))
             then concat(str:reverse(substring-after($sentence, ' ')),
                         ' ',
                         substring-before($sentence, ' '))
             else $sentence"
     as="xs:string"/&gt;             
&lt;/xsl:function&gt;

&lt;xsl:template match="/"&gt;
&lt;output&gt;
  &lt;xsl:value-of select="str:reverse('DOG BITES MAN')"/&gt;
&lt;/output&gt;
&lt;/xsl:template&gt;

&lt;/xsl:transform&gt;</pre></div></div><p>&nbsp;</p><div class="example"><p>The following example illustrates the use of variables in a function
definition.
It returns a string containing the representation of its integer argument, expressed
as a roman numeral. For example, the function call <code>num:roman(7)</code> will return
the string <code>"vii"</code>. This example uses the <a href="#element-number"><code>xsl:number</code></a> instruction,
described in <a href="#number"><b>12 Numbering</b></a>.</p><div class="exampleInner"><pre>&lt;xsl:function name="num:roman"&gt;
  &lt;xsl:param name="value" as="xs:integer"/&gt;
  &lt;xsl:variable name="roman-number"&gt;
    &lt;xsl:number value="$value" format="i"/&gt;
  &lt;/xsl:variable&gt;
  &lt;xsl:result select="string($roman-number)" as="xs:string"/&gt;             
&lt;/xsl:function&gt;</pre></div></div></div></div></div><div class="div1">
<h2><a name="creating-new-nodes" id="creating-new-nodes"></a>11 Creating New Nodes</h2><p>This section describes instructions that directly create new nodes.
These nodes will typically be assembled to form the result tree.</p><div class="div2">
<h3><a name="literal-result-element" id="literal-result-element"></a>11.1 Literal Result Elements</h3><p>
					<a name="dt-literal-result-element" id="dt-literal-result-element" title="literal result element"></a>In 
a <a title="content constructor" href="#dt-content-constructor">content constructor</a>, an element in 
the stylesheet that does not belong to
the <a title="XSLT namespace" href="#dt-xslt-namespace">XSLT namespace</a> and 
that is not an <a title="extension instruction" href="#dt-extension-instruction">extension instruction</a> (see <a href="#extension-instruction"><b>18.2 Extension Instructions</b></a>) is classified as a 
<b>literal result element</b>.
A literal result element is evaluated to construct a new element node
with the same <a title="expanded-QName" href="#dt-expanded-qname">expanded-QName</a>.
The result of evaluating a literal result element
is a node sequence containing one element, the newly constructed element node.</p><p>The content
of the element is a <a title="content constructor" href="#dt-content-constructor">content constructor</a>, which is evaluated
 to return a sequence of nodes that define the attributes and
children of the created element node. 
This content constructor is evaluated with the newly created element
node as the <a title="current destination node" href="#dt-current-destination-node">current destination node</a>.
					
				</p><div class="div3">
<h4><a name="d5e9128" id="d5e9128"></a>11.1.1 Setting the Type Annotation for Literal Result Elements</h4><p>The attribute <code>xsl:type-annotation</code> may be used on a literal result element
to indicate the type of the new element node. The value of the attribute is a <a title="QName" href="#dt-qname">QName</a>
identifying either a global type definition that is present in a schema imported using an <a href="#element-import-schema"><code>xsl:import-schema</code></a>
declaration, or a built-in type definition. The type annotation of the new node will be set to this QName,
and the typed value of the new node will be the result of casting the string-value of the node to this
type. If the attribute is omitted, the new element node
will have a type annotation of <code>xs:anyType</code>, and a typed value that is the
same as the string value.</p><p>
						<a name="d5e9147"><small>[ERR077] </small></a>It is a <a title="static error" href="#dt-static-error">static error</a>
if the value of the <code>xsl:type-annotation</code> attribute

is not a <a title="QName" href="#dt-qname">QName</a>, or is a QName whose prefix cannot be resolved using the in-scope namespace
declarations, or is a QName that is not either the name of a built-in schema type, or
the name of a global type definition in a schema imported
using an <a href="#element-import-schema"><code>xsl:import-schema</code></a> declaration.
					</p><p>
						<a name="d5e9167"><small>[ERR078] </small></a>When the <code>xsl:type-annotation</code> attribute is used on a literal result
element, it is a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> to construct an element node
as a child of the new element. Type annotations can be added only to element nodes that have simple 
content. The processor must signal the error.
						
					</p><p>
						<a name="d5e9181"><small>[ERR079] </small></a>When the <code>xsl:type-annotation</code> attribute is used on a literal result
element, it is a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> if the string-value of the
new element cannot be converted to the named type under the rules of the XPath <code>cast</code>
expression. These rules are defined in <a href="#FANDO">[Functions and Operators]</a>.
The processor must signal the error.
						
					</p></div><div class="div3">
<h4><a name="d5e9200" id="d5e9200"></a>11.1.2 Attribute Nodes for Literal Result Elements</h4><p>The created element node will
have an attribute corresponding to each attribute node that is present on the element node in the
stylesheet tree, other than attributes with names in the XSLT
namespace.</p><p>The value of an attribute of a literal result element is
interpreted as an <a title="attribute value template" href="#dt-attribute-value-template">attribute
value template</a>: it can therefore contain <a title="expression" href="#dt-expression">expressions</a> contained
in curly braces (<code>{}</code>). The attribute node created in the result
tree will have the same name as the attribute in the source tree, and its
string-value will be the same as the <a title="effective value" href="#dt-effective-value">effective value</a>
of the attribute in the source tree. The type annotation on the
attribute node will be <code>xs:anySimpleType</code>, and the typed value of the node will be the
same as the string value..</p><p>Additional attributes may be generated by including <a href="#element-attribute"><code>xsl:attribute</code></a>
instructions in the content constructor, or by specifying the <code>xsl:use-attribute-sets</code>
attribute on the literal result element itself. The way in which conflicts among these
attributes are resolved is described in <a href="#attribute-sets"><b>10.2 Named Attribute Sets</b></a>.</p><blockquote><table width="90%"><tr><td width="10%" align="left" valign="top"><b>Note:</b></td><td align="left" valign="top"><p>The <code>xml:base</code>, 
<code>xml:lang</code> and <code>xml:space</code>
attributes have two effects in XSLT. They
behave as standard XSLT attributes, which means for example that if they appear on
a literal result element, they will be copied to the result tree in the same
way as any other attribute. In addition, they have their standard meaning
as defined in the core XML specifications. Thus, an <code>xml:base</code>
attribute in the stylesheet affects the base URI of the element on which it appears,
and an <code>xml:space</code> attribute affects the interpretation of whitespace
nodes within that element. One consequence of this is that these attributes
should not be written as attribute value templates: although an XSLT processor
will understand this notation, the XML parser will not.</p></td></tr></table></blockquote><blockquote><table width="90%"><tr><td width="10%" align="left" valign="top"><b>Note:</b></td><td align="left" valign="top"><p>The same is true of the schema-defined attributes
<code>xsi:type</code>, <code>xsi:nil</code>, and <code>xsi:schemaLocation</code>.
If the stylesheet is processed by a schema processor,
these attributes will be recognized and interpreted by the schema processor, but they have no
special meaning to the XSLT processor. The attributes are copied to the result
tree in the same way as any other attribute. If the result tree is validated, the copied
attributes will again be recognized and interpreted by the schema processor.</p><p>None of these attributes
will be generated in the result tree unless the stylesheet writes them to the result
tree explicitly.</p></td></tr></table></blockquote></div><div class="div3">
<h4><a name="lre-namespaces" id="lre-namespaces"></a>11.1.3 Namespace Nodes for Literal Result Elements</h4><p>The created element node will also have a copy of the namespace
nodes that were present on the element node in the stylesheet tree
with the exception of any namespace node whose string-value (before
the application of any namespace aliases: see <a href="#namespace-aliasing"><b>11.1.4 Namespace Aliasing</b></a>) is 
designated as an excluded namespace.</p><p>The following namespaces are designated as excluded namespaces:</p><ul><li><p>The <a title="XSLT namespace" href="#dt-xslt-namespace">XSLT namespace</a> URI
 (<code>http://www.w3.org/1999/XSL/Transform</code>)</p></li><li><p>A namespace URI declared as an extension namespace 
(see <a href="#extension-instruction"><b>18.2 Extension Instructions</b></a>)</p></li><li><p>A namespace URI designated by using an <code>[xsl:]exclude-result-prefixes</code>
								
attribute either on the literal result element itself or
on an ancestor element. The attribute must be in the XSLT namespace only
if its parent element is <em>not</em> in the XSLT namespace.</p><p>The value of the attribute is a whitespace-separated
list of tokens, each of which is either a namespace prefix,
or <code>#default</code>, or <code>#all</code>
								. The namespace bound to each of the
prefixes is designated as an excluded namespace.  It is a
 <a title="static error" href="#dt-static-error">static error</a> if
there is no namespace bound to the prefix on the element bearing the
<code>[xsl:]exclude-result-prefixes</code>
								
attribute.</p><p>The default namespace (as declared by <code>xmlns</code>) may be designated as an
excluded namespace by including <code>#default</code> in the list of
namespace prefixes.</p><p>The value <code>#all</code> indicates that all namespaces are designated as
excluded namespaces. In this case, any other prefixes are ignored.</p><p>The designation of a namespace as an excluded
namespace is effective within the subtree of the stylesheet rooted at
the element bearing the <code>[xsl:]exclude-result-prefixes</code>
								 attribute;
a subtree rooted at an <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> element
does not include any stylesheet modules imported or included by children
of that <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> element.</p></li></ul><p>The excluded namespaces, as described above, <em>only</em> affect namespace
 nodes copied from the stylesheet when processing a literal result element.
There is no guarantee that an excluded namespace will not appear on the result tree
for some other reason. Namespace nodes are also written to the result tree
as part of the process of namespace fixup (see <a href="#namespace-fixup"><b>4.4 Namespace Fixup</b></a>), 
or as the result of instructions such as 
<a href="#element-copy"><code>xsl:copy</code></a> and <a href="#element-element"><code>xsl:element</code></a>.</p><blockquote><table width="90%"><tr><td width="10%" align="left" valign="top"><b>Note:</b></td><td align="left" valign="top"><p>When a stylesheet uses a namespace declaration only for the
purposes of addressing the source tree, specifying the prefix in the
<code>[xsl:]exclude-result-prefixes</code>
							
attribute will avoid superfluous
namespace declarations in the result tree. The attribute is also useful
to prevent namespaces used solely for the naming of extension functions from
appearing in the result tree.</p></td></tr></table></blockquote></div><div class="div3">
<h4><a name="namespace-aliasing" id="namespace-aliasing"></a>11.1.4 Namespace Aliasing</h4><p>When a stylesheet is used to define a transformation
whose output is itself a stylesheet module, or in certain other cases where
the result document uses namespaces that it would be inconvenient to use
in the stylesheet, namespace aliasing can be used to declare a mapping
between a namespace URI used in the stylesheet and the corresponding
namespace URI to be used in the result document.</p><p>
						<a name="dt-literal-namespace-uri" id="dt-literal-namespace-uri" title="literal namespace URI"></a>A
 namespace URI in the stylesheet tree that is being used to
specify a namespace URI in the result tree is called a <b>literal
namespace URI</b>. This applies to:</p><ul><li><p>the namespace URI in the <a title="expanded-QName" href="#dt-expanded-qname">expanded-QName</a> of a literal
result element in the stylesheet</p></li><li><p>the namespace URI in the <a title="expanded-QName" href="#dt-expanded-qname">expanded-QName</a> of an attribute
specified on a literal result element in the stylesheet</p></li><li><p>the string-value of a namespace node on a literal result
element in the stylesheet.</p></li></ul><p class="element-syntax"><a name="element-namespace-alias"></a><code>&lt;!-- Category: declaration --&gt;<br>&lt;xsl:namespace-alias<br>&nbsp;&nbsp;<b>stylesheet-prefix</b> = <var>prefix</var> | "#default"<br>&nbsp;&nbsp;<b>result-prefix</b> = <var>prefix</var> | "#default"&nbsp;/&gt;</code></p><p>
						<a name="dt-alias" id="dt-alias" title="alias"></a>A stylesheet can use the
<a href="#element-namespace-alias"><code>xsl:namespace-alias</code></a> element to declare that one namespace
URI is an <b>alias</b> for another namespace URI. When
a <a title="literal namespace URI" href="#dt-literal-namespace-uri">literal namespace
URI</a> has been declared to be an alias for another namespace
URI, then the namespace URI in the result tree will be the namespace
URI that the literal namespace URI is an alias for, instead of the
literal namespace URI itself.</p><p>The <a href="#element-namespace-alias"><code>xsl:namespace-alias</code></a>
element declares that the namespace URI bound to the prefix specified
by the <code>stylesheet-prefix</code> attribute is an alias for the
namespace URI bound to the prefix specified by the
<code>result-prefix</code> attribute.  Thus, the
<code>stylesheet-prefix</code> attribute specifies the namespace URI
that will appear in the stylesheet, and the
<code>result-prefix</code> attribute specifies the corresponding
namespace URI that will appear in the result tree.  The
namespace prefix that will be used in the serialized output document is 
<a title="implementation-dependent" href="#dt-implementation-dependent">implementation-dependent</a>.
					</p><p>The default
namespace (as declared by <code>xmlns</code>) may be specified by
using <code>#default</code> instead of a prefix.</p><p>If a namespace URI
is declared to be an alias for multiple different namespace URIs, then
the declaration with the highest <a title="import precedence" href="#dt-import-precedence">import precedence</a> is used.
 <a name="d5e9491"><small>[ERR080] </small></a>It is
a <a title="static error" href="#dt-static-error">static error</a> if there is more
 than one such declaration 
 
 with the same <code>stylesheet-prefix</code> and the same 
 <a title="import precedence" href="#dt-import-precedence">import precedence</a>
							 and different values for <code>namespace-uri</code>.  
						
					</p><div class="example"><p>When literal result elements are being used to create element,
attribute, or namespace nodes that use 
the <a title="XSLT namespace" href="#dt-xslt-namespace">XSLT namespace</a> URI, the
stylesheet should use an alias. </p><p>For example, the stylesheet</p><div class="exampleInner"><pre>&lt;xsl:stylesheet
  version="2.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:fo="http://www.w3.org/1999/XSL/Format"
  xmlns:axsl="file://namespace.alias"&gt;

&lt;xsl:namespace-alias stylesheet-prefix="axsl" result-prefix="xsl"/&gt;

&lt;xsl:template match="/"&gt;
  &lt;axsl:stylesheet version="1.0"&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/axsl:stylesheet&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="block"&gt;
  &lt;axsl:template match="{.}"&gt;
     &lt;fo:block&gt;&lt;axsl:apply-templates/&gt;&lt;/fo:block&gt;
  &lt;/axsl:template&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre></div><p>will generate an XSLT stylesheet from a document of the form:</p><div class="exampleInner"><pre>&lt;elements&gt;
&lt;block&gt;p&lt;/block&gt;
&lt;block&gt;h1&lt;/block&gt;
&lt;block&gt;h2&lt;/block&gt;
&lt;block&gt;h3&lt;/block&gt;
&lt;block&gt;h4&lt;/block&gt;
&lt;/elements&gt;</pre></div><p>The output of the transformation will be a stylesheet such as the following.
Whitespace has been added for clarity. Note that an implementation may output different namespace prefixes from those 
appearing in this example.</p><div class="exampleInner"><pre>&lt;xsl:stylesheet
  version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform" 
  xmlns:fo="http://www.w3.org/1999/XSL/Format"&gt;
  
&lt;xsl:template match="p"&gt;
  &lt;fo:block&gt;&lt;xsl:apply-templates/&gt;&lt;/fo:block&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="h1"&gt;
  &lt;fo:block&gt;&lt;xsl:apply-templates/&gt;&lt;/fo:block&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="h2"&gt;
  &lt;fo:block&gt;&lt;xsl:apply-templates/&gt;&lt;/fo:block&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="h3"&gt;
  &lt;fo:block&gt;&lt;xsl:apply-templates/&gt;&lt;/fo:block&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="h4"&gt;
  &lt;fo:block&gt;&lt;xsl:apply-templates/&gt;&lt;/fo:block&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre></div></div><blockquote><table width="90%"><tr><td width="10%" align="left" valign="top"><b>Note:</b></td><td align="left" valign="top"><p>It may be necessary also to use aliases for namespaces other
than the XSLT namespace URI.  For example, literal result elements
belonging to a namespace dealing with digital signatures might cause
XSLT stylesheets to be mishandled by general-purpose security
software; using an alias for the namespace would avoid the possibility
of such mishandling.</p></td></tr></table></blockquote></div></div><div class="div2">
<h3><a name="d5e9537" id="d5e9537"></a>11.2 Creating Element Nodes using <code>xsl:element</code>
				</h3><p class="element-syntax"><a name="element-element"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:element<br>&nbsp;&nbsp;<b>name</b> = { <var>qname</var> }<br>&nbsp;&nbsp;namespace = { <var>uri-reference</var> }<br>&nbsp;&nbsp;use-attribute-sets = <var>qnames</var><br>&nbsp;&nbsp;type-annotation = <var>qname</var>&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>content-constructor</var> --&gt;<br>&lt;/xsl:element&gt;</code></p><p>The <a href="#element-element"><code>xsl:element</code></a> instruction allows an element to be
created with a computed name.  The <a title="expanded-QName" href="#dt-expanded-qname">expanded-QName</a> of the
element to be created is specified by a required <code>name</code>
attribute and an optional <code>namespace</code> attribute.</p><p>The
content of the <a href="#element-element"><code>xsl:element</code></a> instruction is a
 <a title="content constructor" href="#dt-content-constructor">content constructor</a> for the
children, attributes, and namespaces of the created element.
This content constructor is evaluated with the newly created element
node as the <a title="current destination node" href="#dt-current-destination-node">current destination node</a>.
				</p><p>The result of evaluating the 
<a href="#element-element"><code>xsl:element</code></a> instruction, except in error cases, is 
 the newly constructed element node.</p><p>The <code>name</code> attribute is interpreted as an
				 <a title="attribute value template" href="#dt-attribute-value-template">attribute value template</a>.</p><p><a name="d5e9603"><small>[ERR081] </small></a>It is an <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> if
 the <a title="effective value" href="#dt-effective-value">effective value</a>
						 is not a <a title="QName" href="#dt-qname">QName</a>.
  The <a title="processor" href="#dt-processor">processor</a> must either signal
the error, or must recover by making the result
 of evaluating the <a href="#element-element"><code>xsl:element</code></a>
element be the sequence of nodes created by evaluating
the content of the  <a href="#element-element"><code>xsl:element</code></a> element, excluding
any initial attribute nodes.
					</p><p><a name="d5e9636"><small>[ERR082] </small></a>In the case of an <a href="#element-element"><code>xsl:element</code></a> instruction
with no <code>namespace</code> attribute, 
it is a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> if
 the <a title="effective value" href="#dt-effective-value">effective value</a>
of the <code>name</code> attribute is a <a title="QName" href="#dt-qname">QName</a>
whose prefix is not declared in an in-scope namespace declaration for the <a href="#element-element"><code>xsl:element</code></a> instruction.
  The <a title="processor" href="#dt-processor">processor</a> must either signal
the error, or must recover by ignoring the prefix part of the QName.
					</p><p>If the <code>namespace</code> attribute is
not present then the <a title="QName" href="#dt-qname">QName</a> is
expanded into an <a title="expanded-QName" href="#dt-expanded-qname">expanded-QName</a> using the namespace declarations in
effect for the <a href="#element-element"><code>xsl:element</code></a> element, including any default
namespace declaration.</p><p>If the <code>namespace</code> attribute is present, then it too is
interpreted as an <a title="attribute value template" href="#dt-attribute-value-template">attribute
value template</a>. The <a title="effective value" href="#dt-effective-value">effective value</a>
 should be a URI reference.  It is not an
error if the string is not a syntactically legal URI reference.  If
the string is zero-length, then the <a title="expanded-QName" href="#dt-expanded-qname">expanded-QName</a> of the element has a null
namespace URI.  Otherwise, the string is used as the namespace URI of
the <a title="expanded-QName" href="#dt-expanded-qname">expanded-QName</a> of the element to be created. The local part of the
<a title="QName" href="#dt-qname">QName</a> specified by the
<code>name</code> attribute is used as the local part of the
<a title="expanded-QName" href="#dt-expanded-qname">expanded-QName</a> of the element to be created.</p><p>Implementations may make use of the prefix of the <a title="QName" href="#dt-qname">QName</a> specified in the
<code>name</code> attribute when selecting the prefix used for
outputting the created element as XML; however, they are not required
to do so.</p><p>For the effect of the <code>use-attribute-sets</code>
attribute, see <a href="#attribute-sets"><b>10.2 Named Attribute Sets</b></a>
				</p><div class="div3">
<h4><a name="d5e9721" id="d5e9721"></a>11.2.1 Setting the Type Annotation for a Constructed Element Node</h4><p>The attribute <code>type-annotation</code> may be used 
to indicate the type of the new element node. The value of the attribute is a <a title="QName" href="#dt-qname">QName</a>
identifying either a global type definition that is present in a schema imported using an <a href="#element-import-schema"><code>xsl:import-schema</code></a>
declaration, or a built-in type definition. The type annotation of the new node will be set to this QName,
and the typed value of the new node will be the result of casting the string-value of the node to this
type. If the attribute is omitted, the new element node
will have a type annotation of <code>xs:anyType</code>, and a typed value that is the
same as the string value.</p><div><blockquote><p><b><a href="#issue-annotate-complex-types">Issue 141 (annotate-complex-types)</a>: </b>Should the <code>type-annotation</code> attribute on <a href="#element-element"><code>xsl:element</code></a> (and
    <code>xsl:type-annotation</code> on literal result elements) be extended to support complex
    types?</p></blockquote></div><p>
						<a name="d5e9743"><small>[ERR083] </small></a>It is a <a title="static error" href="#dt-static-error">static error</a>
if the value of the <code>type-annotation</code> attribute

is not a <a title="QName" href="#dt-qname">QName</a>, or is a QName whose prefix cannot be resolved using the in-scope namespace
declarations, or is a QName that is not either the name of a built-in schema type, or
the name of a global type definition in a schema imported
using an <a href="#element-import-schema"><code>xsl:import-schema</code></a> declaration.
					</p><p>
						<a name="d5e9766"><small>[ERR084] </small></a>When the <code>type-annotation</code> attribute is used 

it is a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> to construct an element node
as a child of the new element. Type annotations can be added only to element nodes that have simple 
content. The processor must signal the error.
						
					</p><p>
						<a name="d5e9786"><small>[ERR085] </small></a>When the <code>type-annotation</code> attribute is used

it is a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> if the string-value of the
new element cannot be converted to the named type under the rules of the XPath <code>cast</code>
expression. These rules are defined in <a href="#FANDO">[Functions and Operators]</a>.
The processor must signal the error.
						
					</p></div></div><div class="div2">
<h3><a name="creating-attributes" id="creating-attributes"></a>11.3 Creating Attribute Nodes using <code>xsl:attribute</code>
				</h3><p class="element-syntax"><a name="element-attribute"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:attribute<br>&nbsp;&nbsp;<b>name</b> = { <var>qname</var> }<br>&nbsp;&nbsp;namespace = { <var>uri-reference</var> }<br>&nbsp;&nbsp;type-annotation = <var>qname</var><br>&nbsp;&nbsp;disable-output-escaping = "yes" | "no"&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>content-constructor</var> --&gt;<br>&lt;/xsl:attribute&gt;</code></p><div><blockquote><p><b><a href="#issue-creating-id-and-idref">Issue 131 (creating-id-and-idref)</a>: </b>What are the implications of creating attributes of type ID and IDREF[S] in a result tree?
    What guarantees of uniqueness or referential integrity are provided? Is there a need to create temporary
    trees containing IDREF values that are not resolved within the temporary tree, but will be resolved
    when the nodes are copied to a final result tree? What does the <u>fn:id</u> function do?</p></blockquote></div><p>The <a href="#element-attribute"><code>xsl:attribute</code></a> element can be used to add
attributes to result elements whether created by literal result
elements in the stylesheet or by instructions such as
<a href="#element-element"><code>xsl:element</code></a>. The <a title="expanded-QName" href="#dt-expanded-qname">expanded-QName</a> of the
attribute to be created is specified by a required <code>name</code>
attribute and an optional <code>namespace</code> attribute.
The result of evaluating an <a href="#element-attribute"><code>xsl:attribute</code></a> instruction
 is the newly constructed attribute node.</p><p>The content of the
<a href="#element-attribute"><code>xsl:attribute</code></a> element is a <a title="content constructor" href="#dt-content-constructor">content constructor</a> for the value of the
created attribute.</p><p>The <code>name</code> attribute is interpreted as
				 an <a title="attribute value template" href="#dt-attribute-value-template">attribute value template</a>.</p><p><a name="d5e9872"><small>[ERR086] </small></a>It is a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> if 
the <a title="effective value" href="#dt-effective-value">effective value</a>
						 
is not a <a title="QName" href="#dt-qname">QName</a> or is the string
<code>xmlns</code>.  The <a title="processor" href="#dt-processor">processor</a> must either signal the error, 
or must recover by not adding the attribute
to the result tree.
					
				</p><p><a name="d5e9903"><small>[ERR087] </small></a>In the case of an <a href="#element-attribute"><code>xsl:attribute</code></a> instruction
with no <code>namespace</code> attribute, 
it is a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> if
 the <a title="effective value" href="#dt-effective-value">effective value</a>
of the <code>name</code> attribute is a <a title="QName" href="#dt-qname">QName</a>
whose prefix is not declared in an in-scope namespace declaration for the <a href="#element-attribute"><code>xsl:attribute</code></a> instruction.
  The <a title="processor" href="#dt-processor">processor</a> must either signal
the error, or must recover by ignoring the prefix part of the QName.
					</p><p>If the <code>namespace</code> attribute is not
present, then the <a title="QName" href="#dt-qname">QName</a> is
expanded into an <a title="expanded-QName" href="#dt-expanded-qname">expanded-QName</a> using the namespace declarations in
effect for the <a href="#element-attribute"><code>xsl:attribute</code></a> element, <em>not</em>
including any default namespace declaration.</p><p>If the <code>namespace</code> attribute is present, then it too is
interpreted as an <a title="attribute value template" href="#dt-attribute-value-template">attribute
value template</a>. The <a title="effective value" href="#dt-effective-value">effective value</a>
 should be a URI reference.  It is not an error if the string is not
a syntactically legal URI reference.  If the string is zero-length, then the
<a title="expanded-QName" href="#dt-expanded-qname">expanded-QName</a> of the attribute has a null namespace URI.  Otherwise,
the string is used as the namespace URI of the <a title="expanded-QName" href="#dt-expanded-qname">expanded-QName</a> of the
attribute to be created. The local part of the <a title="QName" href="#dt-qname">QName</a> specified by the
<code>name</code> attribute is used as the local part of the
<a title="expanded-QName" href="#dt-expanded-qname">expanded-QName</a> of the attribute to be created.</p><p>Implementations may make use of the prefix of the
 <a title="QName" href="#dt-qname">QName</a> specified in the
<code>name</code> attribute when selecting the prefix used for
outputting the created attribute as XML; however, they are not
required to do so and, if the prefix is <code>xmlns</code>, they must
not do so.</p><div class="example"><p>Thus, although it is not an error to write:</p><div class="exampleInner"><pre>&lt;xsl:attribute name="xmlns:xsl" 
   namespace="file://some.namespace"&gt;http://www.w3.org/1999/XSL/Transform&lt;/xsl:attribute&gt;</pre></div><p>it will not result in the namespace declaration
<code>xmlns:xsl="http://www.w3.org/1999/XSL/Transform"</code> being output. Instead, it will 
produce an attribute node with local name <code>xsl</code>, and with a system-allocated namespace
prefix mapped to the namespace URI <code>file://some.namespace</code>.
					</p></div><p>As described in <a href="#content-constructors"><b>5.6 Content Constructors</b></a>,
any attribute nodes must appear in the result of evaluating a content constructor
before any element, text, comment, or processing instruction nodes. Where the result of the content constructor contains two
or more attribute nodes with the same <a title="expanded-QName" href="#dt-expanded-qname">expanded-QName</a>, the one that comes last
is the only one that takes effect.</p><p><a name="d5e10016"><small>[ERR088] </small></a>It is a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> to evaluate
the <a href="#element-attribute"><code>xsl:attribute</code></a> instruction when the
 <a title="current destination node" href="#dt-current-destination-node">current destination node</a>
 is not an element. The recovery action (if any) depends
on the instruction that makes use of the constructed node sequence.</p><p>For the effect of the <code>disable-output-escaping</code> attribute,
see <a href="#disable-output-escaping"><b>20.5 Disabling Output Escaping</b></a>
				</p><div class="div3">
<h4><a name="d5e10037" id="d5e10037"></a>11.3.1 Setting the Type Annotation for a Constructed Attribute Node</h4><p>The attribute <code>type-annotation</code> may be used 
to indicate the type of the new attribute node. The value of the attribute is a QName
identifying either a global type definition that is present in a schema imported using an <a href="#element-import-schema"><code>xsl:import-schema</code></a>
declaration, or a built-in type definition. The type annotation of the new node will be set to this QName,
and the typed value of the new node will be the result of casting the string-value of the node to this
type. If the attribute is omitted, the new attribute node
will have a type annotation of <code>xs:anySimpleType</code>, and a typed value that is the
same as the string value.</p><p>
						<a name="d5e10053"><small>[ERR089] </small></a>It is a <a title="static error" href="#dt-static-error">static error</a>
if the value of the <code>type-annotation</code> attribute

is not a QName, or is a QName whose prefix cannot be resolved using the in-scope namespace
declarations, or is a QName that is not either the name of a built-in schema type, or
the name of a global type definition in a schema imported
using an <a href="#element-import-schema"><code>xsl:import-schema</code></a> declaration.
					</p><p>
						<a name="d5e10073"><small>[ERR090] </small></a>When the <code>type-annotation</code> attribute is used

it is a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> if the string-value of the
new attribute cannot be converted to the named type under the rules of the XPath <code>cast</code>
expression. These rules are defined in <a href="#FANDO">[Functions and Operators]</a>.
The processor must signal the error.
						
					</p></div></div><div class="div2">
<h3><a name="d5e10096" id="d5e10096"></a>11.4 Creating Text Nodes</h3><div class="div3">
<h4><a name="d5e10099" id="d5e10099"></a>11.4.1 Literal Text Nodes</h4><p>A <a title="content constructor" href="#dt-content-constructor">content constructor</a> 
can also contain text nodes.  Each text node in a
content constructor remaining after whitespace has been stripped as specified in
<a href="#strip"><b>4.3 Whitespace Stripping</b></a> will construct a text node with the same
string-value.  The resulting text node is added to the result of the containing
content constructor.
 When the resulting content is added to a result tree, adjacent text nodes in the result
tree are automatically merged.</p><p>Note that text is processed at the tree level. Thus, markup of
<code>&amp;lt;</code> in a template will be represented in the
stylesheet tree by a text node that includes the character
<code>&lt;</code>. This will create a text node in the result tree
that contains a <code>&lt;</code> character, which will be represented
by the markup <code>&amp;lt;</code> (or an equivalent character
reference) when the result tree is serialized as an XML document
(unless output escaping is disabled as described in <a href="#disable-output-escaping"><b>20.5 Disabling Output Escaping</b></a>).</p></div><div class="div3">
<h4><a name="d5e10125" id="d5e10125"></a>11.4.2 Creating Text Nodes using <code>xsl:text</code>
					</h4><p class="element-syntax"><a name="element-text"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:text<br>&nbsp;&nbsp;disable-output-escaping = "yes" | "no"&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>content-constructor</var> --&gt;<br>&lt;/xsl:text&gt;</code></p><p>The <a href="#element-text"><code>xsl:text</code></a> element is evaluated to contruct a
new text node.  The content of the
<a href="#element-text"><code>xsl:text</code></a> element is a
 <a title="content constructor" href="#dt-content-constructor">content constructor</a> for the string-value of
the text node.</p><div><blockquote><p><b><a href="#issue-nested-xsl-text">Issue 139 (nested-xsl-text)</a>: </b>At XSLT 1.0 the <a href="#element-text"><code>xsl:text</code></a> element only allowed PCDATA content.
    It has been generalized largely for consistency with <a href="#element-comment"><code>xsl:comment</code></a> and
    <a href="#element-attribute"><code>xsl:attribute</code></a>, etc. Is this generalization actually useful?</p></blockquote></div><p>The result of evaluating the <a href="#element-text"><code>xsl:text</code></a> instruction is 
a single node, the newly constructed text node.</p><p>Text nodes that are immediate children of the <a href="#element-text"><code>xsl:text</code></a> instruction
will not be stripped from the stylesheet tree, even if they consist entirely of whitespace 
(see <a href="#strip"><b>4.3 Whitespace Stripping</b></a>).</p><p>For the effect of the <code>disable-output-escaping</code> attribute,
see <a href="#disable-output-escaping"><b>20.5 Disabling Output Escaping</b></a>
					</p><div><blockquote><p><b><a href="#issue-nested-d-o-e">Issue 132 (nested-d-o-e)</a>: </b>The <a href="#element-text"><code>xsl:text</code></a> element may now contain (or cause the evaluation of)
    nested <a href="#element-text"><code>xsl:text</code></a> and <a href="#element-value-of"><code>xsl:value-of</code></a> instructions. This makes it
    necessary to define the meaning of nested disable-output-escaping attributes. Should the
    default be that escaping is enabled, or should it be "no change from the previous setting"?</p></blockquote></div><p>
						<a name="d5e10173"><small>[ERR091] </small></a>It is a <a title="static error" href="#dt-static-error">static error</a>
to specify <code>disable-output-escaping="yes"</code> on an <a href="#element-text"><code>xsl:text</code></a> instruction that
has element node children.
					</p><blockquote><table width="90%"><tr><td width="10%" align="left" valign="top"><b>Note:</b></td><td align="left" valign="top"><p>It is not always necessary to use the <a href="#element-text"><code>xsl:text</code></a> instruction
to write text nodes to the result tree. Literal text can be written to the result tree by including
it anywhere in a <a title="content constructor" href="#dt-content-constructor">content constructor</a>, while
computed text can be output using the <a href="#element-value-of"><code>xsl:value-of</code></a> instruction. The principal reason
for using <a href="#element-text"><code>xsl:text</code></a> is that it offers improved control over whitespace handling.</p></td></tr></table></blockquote></div></div><div class="div2">
<h3><a name="d5e10200" id="d5e10200"></a>11.5 Creating Processing Instructions</h3><p class="element-syntax"><a name="element-processing-instruction"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:processing-instruction<br>&nbsp;&nbsp;<b>name</b> = { <var>ncname</var> }&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>content-constructor</var> --&gt;<br>&lt;/xsl:processing-instruction&gt;</code></p><p>The <a href="#element-processing-instruction"><code>xsl:processing-instruction</code></a> element is evaluated
to create a processing instruction node.  The content of the
<a href="#element-processing-instruction"><code>xsl:processing-instruction</code></a> element is a
 <a title="content constructor" href="#dt-content-constructor">content constructor</a> for the
string-value of the processing instruction node.  The
<a href="#element-processing-instruction"><code>xsl:processing-instruction</code></a> element has a required
<code>name</code> attribute that specifies the name of the processing
instruction node.  The value of the <code>name</code> attribute is
interpreted as an <a title="attribute value template" href="#dt-attribute-value-template">attribute
value template</a>.</p><p>Except in error situations, the result of evaluating the
 <a href="#element-processing-instruction"><code>xsl:processing-instruction</code></a> instruction is 
  a single node, the newly constructed processing instruction.</p><div class="example"><p>For example, this</p><div class="exampleInner"><pre>&lt;xsl:processing-instruction name="xml-stylesheet"&gt;
  &lt;xsl:text&gt;href="book.css" type="text/css"&lt;/xsl:text&gt;
&lt;/xsl:processing-instruction&gt;</pre></div><p>would create the processing instruction</p><div class="exampleInner"><pre>&lt;?xml-stylesheet href="book.css" type="text/css"?&gt;</pre></div></div><p>
					<a name="d5e10250"><small>[ERR092] </small></a>It is a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> if the
 <a title="effective value" href="#dt-effective-value">effective value</a> of the
<code>name</code> attribute  is not both an <u>NCName</u> and a <u>PITarget</u>.
  The <a title="processor" href="#dt-processor">processor</a> must either signal
the error, or must recover by
returning an empty sequence.
					
				</p><blockquote><table width="90%"><tr><td width="10%" align="left" valign="top"><b>Note:</b></td><td align="left" valign="top"><p>This means that <a href="#element-processing-instruction"><code>xsl:processing-instruction</code></a>
cannot be used to output an XML declaration.  The
<a href="#element-output"><code>xsl:output</code></a> declaration should be used to control this instead (see <a href="#serialization"><b>20 Serialization</b></a>).</p></td></tr></table></blockquote><p>
					<a name="d5e10293"><small>[ERR093] </small></a>It is a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> if
 the result of evaluating the content of the
<a href="#element-processing-instruction"><code>xsl:processing-instruction</code></a> contains the string
<code>?&gt;</code>.  The <a title="processor" href="#dt-processor">processor</a> must either signal the error, or
 must recover by inserting a space after any
occurrence of <code>?</code> that is followed by a <code>&gt;</code>
						
					
				</p></div><div class="div2">
<h3><a name="creating-namespace-nodes" id="creating-namespace-nodes"></a>11.6 Creating Namespace Nodes</h3><p class="element-syntax"><a name="element-namespace"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:namespace<br>&nbsp;&nbsp;<b>name</b> = { <var>ncname</var> }&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>content-constructor</var> --&gt;<br>&lt;/xsl:namespace&gt;</code></p><p>The <a href="#element-namespace"><code>xsl:namespace</code></a> element is evaluated
to create a namespace node.  The content of the
<a href="#element-namespace"><code>xsl:namespace</code></a> element is a
 <a title="content constructor" href="#dt-content-constructor">content constructor</a> for the
string-value of the namespace node (that is, the namespace URI).  The
<a href="#element-namespace"><code>xsl:namespace</code></a> element has a required
<code>name</code> attribute that specifies the name of the namespace node
(that is, the namespace prefix).  The value of the <code>name</code> attribute is
interpreted as an <a title="attribute value template" href="#dt-attribute-value-template">attribute
value template</a>.</p><p>Except in error situations, the result of evaluating the
 <a href="#element-namespace"><code>xsl:namespace</code></a> instruction is 
  a single node, the newly constructed namespace node.
  Note the restrictions described in <a href="#content-constructors"><b>5.6 Content Constructors</b></a>
  for the position of a namespace node relative to other nodes in the node sequence
  returned by a content constructor.</p><div class="example"><p>For example, this</p><div class="exampleInner"><pre>&lt;xsl:namespace name="xsd"&gt;http://www.w3.org/2001/XMLSchema&lt;/xsl:namespace&gt;</pre></div><p>would typically cause the output document to contain the namespace declaration:</p><div class="exampleInner"><pre>xmlns:xsd="http://www.w3.org/2001/XMLSchema"</pre></div></div><p>
					<a name="d5e10369"><small>[ERR094] </small></a>It is a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> if the
<a title="effective value" href="#dt-effective-value">effective value</a> of the
<code>name</code> attribute 
is neither a zero-length string  nor an <u>NCName</u>.  
The <a title="processor" href="#dt-processor">processor</a> must either signal the error,
or must recover by returning an empty sequence.
					
				</p><p>
					<a name="d5e10398"><small>[ERR095] </small></a>It is an <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> if
 evaluating the content of
<a href="#element-namespace"><code>xsl:namespace</code></a> results in a zero-length string .
The <a title="processor" href="#dt-processor">processor</a> must either signal the error, 
or must recover by returning an empty sequence.
					
				</p><p><a name="d5e10414"><small>[ERR096] </small></a>It is a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> to evaluate
the <a href="#element-namespace"><code>xsl:namespace</code></a> instruction when the
 <a title="current destination node" href="#dt-current-destination-node">current destination node</a>
 is not an element. The recovery action (if any) depends
on the instruction that makes use of the constructed node sequence.</p><blockquote><table width="90%"><tr><td width="10%" align="left" valign="top"><b>Note:</b></td><td align="left" valign="top"><p>It is rarely necessary to use <a href="#element-namespace"><code>xsl:namespace</code></a> to create
a namespace node in the result tree; in most circumstances, the required
namespace nodes will be created automatically, as a side-effect of writing
elements or attributes that use the namespace. An example where 
<a href="#element-namespace"><code>xsl:namespace</code></a> is needed is a situation where the required namespace
is used only within attribute values in the result document, not in element or
attribute names; especially where the required namespace prefix or 
namespace URI is computed
at run-time and is not present in either the source document or the 
stylesheet.</p></td></tr></table></blockquote><blockquote><table width="90%"><tr><td width="10%" align="left" valign="top"><b>Note:</b></td><td align="left" valign="top"><p>Namespace prefixes for element and attribute names are effectively established by
the namespace fixup process described in <a href="#namespace-fixup"><b>4.4 Namespace Fixup</b></a>. The fixup process ensures that an element
has in-scope namespace nodes for all the namespace URIs used in the element name and in its attribute names, and the 
serializer will typically use these namespace nodes to determine the prefix to use in the serialized output. The fixup
process does not take place until the construction of the tree is complete, and it cannot generate namespace nodes
that are inconsistent with those already present in the tree. This means that it is
not possible for the processor to decide the prefix to use for an element or for any of its attributes
until all the namespace nodes for the element have been added. If a namespace prefix is mapped to a particular
namespace URI using the <a href="#element-namespace"><code>xsl:namespace</code></a> instruction, or by using <a href="#element-copy"><code>xsl:copy</code></a> 
or <a href="#element-copy-of"><code>xsl:copy-of</code></a> to copy a namespace node, this prevents the namespace fixup process (and hence
the serializer) from using the same prefix for a different namespace URI.</p></td></tr></table></blockquote><blockquote><table width="90%"><tr><td width="10%" align="left" valign="top"><b>Note:</b></td><td align="left" valign="top"><p>The <a href="#element-namespace"><code>xsl:namespace</code></a> instruction cannot be used to generate a
<b>namespace undeclaration</b> of the form <code>xmlns=""</code> (nor the new forms of namespace undeclaration
permitted by XML Namespaces 1.1). Namespace undeclarations
are generated automatically be the serializer when a parent element has a namespace node
for the default namespace prefix, and a child element has no namespace node for that prefix.</p></td></tr></table></blockquote></div><div class="div2">
<h3><a name="d5e10462" id="d5e10462"></a>11.7 Creating Comments</h3><p class="element-syntax"><a name="element-comment"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:comment&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>content-constructor</var> --&gt;<br>&lt;/xsl:comment&gt;</code></p><p>The <a href="#element-comment"><code>xsl:comment</code></a> element is evaluated to contruct a
new comment node.  The content of the
<a href="#element-comment"><code>xsl:comment</code></a> element is a <a title="content constructor" href="#dt-content-constructor">content constructor</a> for the string-value of
the comment node.</p><p>The result of evaluating the <a href="#element-comment"><code>xsl:comment</code></a> instruction is 
a single node, the newly constructed comment node.</p><div class="example"><p>For example, this</p><div class="exampleInner"><pre>&lt;xsl:comment&gt;This file is automatically generated. Do not edit!&lt;/xsl:comment&gt;</pre></div><p>would create the comment</p><div class="exampleInner"><pre>&lt;!--This file is automatically generated. Do not edit!--&gt;</pre></div></div><p>
					<a name="d5e10497"><small>[ERR097] </small></a>It is a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> if
 the result of evaluating the content of the
<a href="#element-comment"><code>xsl:comment</code></a> contains the string <code>--</code> or ends
with <code>-</code>.  The <a title="processor" href="#dt-processor">processor</a> must either signal the error,
or must recover by inserting a space after
any occurrence of <code>-</code> that is followed by another
<code>-</code> or that ends the comment.
					
				</p></div><div class="div2">
<h3><a name="copying" id="copying"></a>11.8 Copying Nodes from a Source Tree to a Result Tree</h3><div class="div3">
<h4><a name="shallow-copy" id="shallow-copy"></a>11.8.1 Shallow Copy</h4><p class="element-syntax"><a name="element-copy"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:copy<br>&nbsp;&nbsp;copy-namespaces = "yes" | "no"<br>&nbsp;&nbsp;use-attribute-sets = <var>qnames</var>&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>content-constructor</var> --&gt;<br>&lt;/xsl:copy&gt;</code></p><p>The <a href="#element-copy"><code>xsl:copy</code></a> instruction provides an easy way of copying
the context item. If the
 <a title="context item" href="#dt-context-item">context item</a> is a node,
and is not a document node,
evaluating the <a href="#element-copy"><code>xsl:copy</code></a> instruction
constructs a copy of the context node, and the result of the
<a href="#element-copy"><code>xsl:copy</code></a> instruction is this newly constructed node.
By default, the namespace nodes of the
context node are automatically copied as well, but the attributes and
children of the node are not automatically copied.  The content of the
<a href="#element-copy"><code>xsl:copy</code></a> element is a
 <a title="content constructor" href="#dt-content-constructor">content constructor</a> for the 
children, attributes, and namespaces of the created node;
 the content constructor is evaluated only for
nodes of types that can have children (that is, document nodes and element nodes).
In this case the content constructor is evaluated with the newly created 
document or element
node as the <a title="current destination node" href="#dt-current-destination-node">current destination node</a>.
					</p><p>The <a href="#element-copy"><code>xsl:copy</code></a> element may have a <code>copy-namespaces</code>
attribute, with the value <code>yes</code> or <code>no</code>. The default value is <code>yes</code>.
The attribute is used only when copying element nodes. If the value is set to <code>yes</code>, or
is omitted, then all the namespace nodes of the source element are copied as namespace nodes for
the result element. If the value is set to <code>no</code>, then the namespace nodes are not copied.
However, namespace nodes will still be added to the result element as required by the namespace
fixup process: see <a href="#namespace-fixup"><b>4.4 Namespace Fixup</b></a>.</p><p>The <a href="#element-copy"><code>xsl:copy</code></a> element may have a
<code>use-attribute-sets</code> attribute (see <a href="#attribute-sets"><b>10.2 Named Attribute Sets</b></a>). 
This is used only when copying element nodes.</p><p>The document node is treated specially because the document node of a
result tree is created implicitly.  When the context item is a document
node, <a href="#element-copy"><code>xsl:copy</code></a> will not create a document node, but will just
evaluate the content constructor, and return the
resulting node sequence as the result of the <a href="#element-copy"><code>xsl:copy</code></a>
instruction.</p><div class="example"><p>For example, the identity transformation can be written using
<a href="#element-copy"><code>xsl:copy</code></a> as follows:</p><div class="exampleInner"><pre>&lt;xsl:template match="@*|node()"&gt;
  &lt;xsl:copy&gt;
    &lt;xsl:apply-templates select="@*|node()"/&gt;
  &lt;/xsl:copy&gt;
&lt;/xsl:template&gt;</pre></div></div><p>
						<a name="d5e10626"><small>[ERR098] </small></a>When the context item is an attribute node, then if it would be a
 <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a>
to use <a href="#element-attribute"><code>xsl:attribute</code></a> to create an attribute with the same
name as the context item, then it is also a
 <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> to use
<a href="#element-copy"><code>xsl:copy</code></a> (see <a href="#creating-attributes"><b>11.3 Creating Attribute Nodes using xsl:attribute
				</b></a>).
The <a title="processor" href="#dt-processor">processor</a> must either signal the error, or must recover by
returning an empty sequence.
						
					</p><p>When the context item is a namespace node,
then <a href="#element-copy"><code>xsl:copy</code></a> constructs a new namespace node as a copy
of the context node (that is, a namespace node with the same <a title="expanded-QName" href="#dt-expanded-qname">expanded-QName</a>
and string-value. As described
in detail in <a href="#content-constructors"><b>5.6 Content Constructors</b></a>, it will generally be an error
if this namespace node is preceded in the constructed node sequence by
any node other than another namespace or attribute node, 
or if the namespace node cannot
be added to a containing element without a conflict arising.</p><p>When the context item is not a node, the effect of the
<a href="#element-copy"><code>xsl:copy</code></a> instruction is the same as evaluating the instruction
<code>&lt;xsl:value-of select="."/&gt;</code>.</p><blockquote><table width="90%"><tr><td width="10%" align="left" valign="top"><b>Note:</b></td><td align="left" valign="top"><p>The <a href="#element-copy"><code>xsl:copy</code></a> instruction is most useful when copying
element nodes. In other cases, the <a href="#element-copy-of"><code>xsl:copy-of</code></a> instruction is
more flexible, because it has a <code>select</code> attribute allowing selection of the
nodes or values to be copied.</p></td></tr></table></blockquote></div><div class="div3">
<h4><a name="copy-of" id="copy-of"></a>11.8.2 Deep Copy</h4><p class="element-syntax"><a name="element-copy-of"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:copy-of<br>&nbsp;&nbsp;<b>select</b> = <var>expression</var><br>&nbsp;&nbsp;separator = { <var>string</var> }<br>&nbsp;&nbsp;copy-namespaces = "yes" | "no"<br>&nbsp;&nbsp;copy-type-annotations = "yes" | "no"&nbsp;/&gt;</code></p><p>The <a href="#element-copy-of"><code>xsl:copy-of</code></a> instruction can be used to 
construct a copy of a sequence of nodes, with each new node containing
copies of all the children, attributes, and (by default) 
namespaces of the original node,
recursively. The result of evaluating the instruction is a sequence
of new nodes corresponding one-to-one with the supplied node sequence, 
and retaining its order. (This correspondence does not apply when copying
a document node: see below).</p><p>The <a href="#element-copy-of"><code>xsl:copy-of</code></a> instruction can also be used to
copy atomic values.</p><p>The mandatory <code>select</code>
attribute contains an <a title="expression" href="#dt-expression">expression</a>,
whose value may be any sequence of nodes or atomic values. 

The items in this sequence are processed as follows:</p><ul><li><p>If the item is an element node, a new element is constructed
and appended to the result sequence. The new element will have the
same <a title="expanded-QName" href="#dt-expanded-qname">expanded-QName</a> as the original, and it will have 
copies of the attribute nodes and children of the element node.</p><p>The new element will also have namespace nodes copied from 
the original element node, unless they are excluded by specifying
 <code>copy-namespaces="no"</code>. If this attribute is omitted, or takes the value
  <code>yes</code>, then all the namespace nodes of the original element are copied to the
  new element. If it takes the value <code>no</code>, then none of the namespace nodes are
  copied: however, namespace nodes will still be created in the result tree as required
  by the namespace fixup process: see <a href="#namespace-fixup"><b>4.4 Namespace Fixup</b></a>. This attribute affects
  all elements copied by this instruction: both elements selected directly by the <code>select</code>
  <a title="expression" href="#dt-expression">expression</a>, 
  and elements that are descendants of nodes selected by the <code>select</code> expression.
</p></li><li><p>If the item is a document node, the instruction copies the
children of the document node (each according to the rules for its own node type)
and adds the copies, in order, to the result sequence.</p></li><li><p>If the item is an attribute or namespace node, or
a text node, a comment, or a processing instruction, the same
rules apply as with <a href="#element-copy"><code>xsl:copy</code></a> (see <a href="#shallow-copy"><b>11.8.1 Shallow Copy</b></a>).</p></li><li><p>If the item is an atomic
value, the result is converted to a string, a new text node is constructed with
this string as its string-value, and the new text node is
appended to the result sequence, as with <a href="#element-value-of"><code>xsl:value-of</code></a>.</p></li></ul><p>If the <code>copy-type-annotations</code> attribute is present
and has the value <code>yes</code>, then all element and attribute nodes created using this
instruction (including nodes copied as a result of the recursive action of the instruction)
will have the same type annotations and the same typed value as the nodes from which they
 were copied. If the attribute
is omitted, or has the value <code>no</code>, then the new nodes will be annotated as <code>xs:anyType</code>
(for elements) or <code>xs:anySimpleType</code> (for attributes), and will have a typed value that is the
same as the string value (but of type <code>xs:anySimpleType</code>).</p><div><blockquote><p><b><a href="#issue-modified-copy">Issue 140 (modified-copy)</a>: </b>Should we try to provide options for <a href="#element-copy-of"><code>xsl:copy-of</code></a> to produce
    a modified copy, for example, a copy omitting certain attributes? One possibility would be
    to define copy in terms of <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> with a special mode, so that
    template rules for that mode could override the standard action.</p></blockquote></div><div><blockquote><p><b><a href="#issue-copy-types-default">Issue 142 (copy-types-default)</a>: </b>What should the default be for the <code>copy-type-annotation</code> attribute on
    the <a href="#element-copy-of"><code>xsl:copy-of</code></a> element?</p></blockquote></div><p>If the <code>separator</code> attribute is present,
then its <a title="effective value" href="#dt-effective-value">effective value</a> (a string)
 is inserted as a text node into the result sequence
after the result of processing each item in the input sequence, other than the last. If the
<code>separator</code> attribute is absent, the effect is the same as supplying
a zero-length string .</p><div class="example"><p>For example, the instruction:</p><div class="exampleInner"><pre>&lt;x&gt;&lt;xsl:copy-of select="(1,2,3,4)" separator="|"/&gt;&lt;/x&gt;</pre></div><p>produces the output:</p><div class="exampleInner"><pre>&lt;x&gt;1|2|3|4&lt;/x&gt;</pre></div></div></div></div><div class="div2">
<h3><a name="value-of" id="value-of"></a>11.9 Generating Text with <a href="#element-value-of"><code>xsl:value-of</code></a>
				</h3><p>Within a <a title="content constructor" href="#dt-content-constructor">content constructor</a>, 
the <a href="#element-value-of"><code>xsl:value-of</code></a> instruction can be
used to compute generated text, for example by extracting text from
the source tree or by inserting the value of a variable.  The
<a href="#element-value-of"><code>xsl:value-of</code></a> instruction computes this text using an <a title="expression" href="#dt-expression">expression</a> that is specified as the
value of the <code>select</code> attribute.</p><blockquote><table width="90%"><tr><td width="10%" align="left" valign="top"><b>Note:</b></td><td align="left" valign="top"><p>An alternative way of computing a string value, 
applicable only when the resulting
text is to be used within a generated attribute node, is to use an
<a title="attribute value template" href="#dt-attribute-value-template">attribute value template</a>,
enclosing the expression in curly braces (<code>{}</code>) within an
attribute of a <a title="literal result element" href="#dt-literal-result-element">literal result element</a>.</p></td></tr></table></blockquote><p class="element-syntax"><a name="element-value-of"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:value-of<br>&nbsp;&nbsp;<b>select</b> = <var>expression</var><br>&nbsp;&nbsp;separator = { <var>string</var> }<br>&nbsp;&nbsp;disable-output-escaping = "yes" | "no"&nbsp;/&gt;</code></p><p>The <a href="#element-value-of"><code>xsl:value-of</code></a> instruction is evaluated to construct a
new text node; the result of the instruction is the newly constructed text node.
But if the rules below produce a text node whose string
value is the zero-length string, the result of the instruction is an empty sequence.
  The required <code>select</code>
attribute is an <a title="expression" href="#dt-expression">expression</a>
whose value may be any sequence of nodes or atomic values.
</p><p>If the sequence is empty, no text node will be created.</p><p>Otherwise, the sequence is first <b>atomized</b>, as defined in <a href="#XPATH20">[XPath 2.0]</a>. 
The result of atomization is a sequence of atomic values.</p><p>If the atomized sequence contains a single item, the resulting text node will have
a string-value that is the same as the string-value of this item.
If the atomized sequence contains more than one item, the effect depends on whether
the <code>separator</code> attribute is present.</p><p>If the <code>separator</code> attribute is present,
then the string-value of the newly constructed text node will be the
concatenation of the string-values of the items in the atomized sequence 
 with each
of these string-values except the last being followed by the
string that is the <a title="effective value" href="#dt-effective-value">effective value</a> of 
the <code>separator</code> attribute. If the
<code>separator</code> attribute is absent, then (for backwards compatibility with XSLT 1.0)
all items in the atomized sequence other than the first are ignored. 
If the effective value of the <code>separator</code> attribute is a zero-length string, then 
all items in the atomized sequence are processed and the results are concatenated
with no separator.
</p><div class="example"><p>For example, the instruction:</p><div class="exampleInner"><pre>&lt;x&gt;&lt;xsl:value-of select="(1,2,3,4)" separator="|"/&gt;&lt;/x&gt;</pre></div><p>produces the output:</p><div class="exampleInner"><pre>&lt;x&gt;1|2|3|4&lt;/x&gt;</pre></div></div><blockquote><table width="90%"><tr><td width="10%" align="left" valign="top"><b>Note:</b></td><td align="left" valign="top"><p>The <a href="#element-copy-of"><code>xsl:copy-of</code></a> element can be used to copy
 a sequence of nodes
 to the result tree without converting to a string. See <a href="#copy-of"><b>11.8.2 Deep Copy</b></a>.</p></td></tr></table></blockquote><div class="example"><p>For example, the following creates an HTML paragraph from a
<code>person</code> element with <code>given-name</code> and
<code>family-name</code> attributes.  The paragraph will contain the value
of the <code>given-name</code> attribute of the context node followed
by a space and the value of the <code>family-name</code> attribute of the
context node.</p><div class="exampleInner"><pre>&lt;xsl:template match="person"&gt;
  &lt;p&gt;
   &lt;xsl:value-of select="@given-name"/&gt;
   &lt;xsl:text&gt; &lt;/xsl:text&gt;
   &lt;xsl:value-of select="@family-name"/&gt;
  &lt;/p&gt;
&lt;/xsl:template&gt;</pre></div></div><p>&nbsp;</p><div class="example"><p>For another example, the following creates an HTML paragraph from a
<code>person</code> element with <code>given-name</code> and
<code>family-name</code> children elements.  The paragraph will
contain the string-value of the first <code>given-name</code> child
element of the context node followed by a space and the string-value
of the first <code>family-name</code> child element of the context
node.</p><div class="exampleInner"><pre>&lt;xsl:template match="person"&gt;
  &lt;p&gt;
   &lt;xsl:value-of select="given-name"/&gt;
   &lt;xsl:text&gt; &lt;/xsl:text&gt;
   &lt;xsl:value-of select="family-name"/&gt;
  &lt;/p&gt;
&lt;/xsl:template&gt;</pre></div></div><p>&nbsp;</p><div class="example"><p>The following precedes each <code>procedure</code> element with a
paragraph containing the security level of the procedure.  It assumes
that the security level that applies to a procedure is determined by a
<code>security</code> attribute on the procedure element or on an
ancestor element of the procedure. It also assumes that if more than
one such element has a <code>security</code> attribute then the
security level is determined by the element that is closest to the
procedure.</p><div class="exampleInner"><pre>&lt;xsl:template match="procedure"&gt;
  &lt;fo:block&gt;
    &lt;xsl:value-of select="ancestor-or-self::*[@security][1]/@security"/&gt;
  &lt;/fo:block&gt;
  &lt;xsl:apply-templates/&gt;
&lt;/xsl:template&gt;</pre></div></div><p>For the effect of the <code>disable-output-escaping</code> attribute,
see <a href="#disable-output-escaping"><b>20.5 Disabling Output Escaping</b></a>
				</p></div></div><div class="div1">
<h2><a name="number" id="number"></a>12 Numbering</h2><p class="element-syntax"><a name="element-number"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:number<br>&nbsp;&nbsp;level = "single" | "multiple" | "any"<br>&nbsp;&nbsp;count = <var>pattern</var><br>&nbsp;&nbsp;from = <var>pattern</var><br>&nbsp;&nbsp;value = <var>number-expression</var><br>&nbsp;&nbsp;format = { <var>string</var> }<br>&nbsp;&nbsp;lang = { <var>nmtoken</var> }<br>&nbsp;&nbsp;letter-value = { "alphabetic" | "traditional" }<br>&nbsp;&nbsp;grouping-separator = { <var>char</var> }<br>&nbsp;&nbsp;grouping-size = { <var>number</var> }&nbsp;/&gt;</code></p><p>The <a href="#element-number"><code>xsl:number</code></a> instruction is used to create a formatted
number. The result of the instruction is a newly constructed
text node containing the formatted number as its string-value.</p><p>
				<a name="dt-place-marker" id="dt-place-marker" title="place marker"></a>The
 <a href="#element-number"><code>xsl:number</code></a> instruction performs
two tasks: firstly, determining a <b>place marker</b> (this is 
a sequence of integers, to allow for hierarchic numbering schemes such as
<code>1.12.2</code> or <code>3(c)ii</code>), and secondly, 
formatting the place marker for output as a text node in the result tree.
 The place marker to be formatted
can either be supplied directly, in the <code>value</code> attribute, or
it can be computed based on the position of the context node within the tree
that contains it.</p><blockquote><table width="90%"><tr><td width="10%" align="left" valign="top"><b>Note:</b></td><td align="left" valign="top"><p>The facilities described in this section are specifically designed
to enable the calculation and formatting of section numbers, paragraph numbers, 
and the like.
For formatting of other numeric quantities, the <a href="#function-format-number"><b>format-number</b></a>
function may be more suitable: see <a href="#format-number"><b>16.4 Number Formatting</b></a>.</p></td></tr></table></blockquote><div class="div2">
<h3><a name="d5e11136" id="d5e11136"></a>12.1 Formatting a Supplied Number</h3><p>The <a title="place marker" href="#dt-place-marker">place marker</a> 
to be formatted may be
specified by an expression. The <code>value</code> attribute contains
the <a title="expression" href="#dt-expression">expression</a>.
The value of this expression is <b>atomized</b> using the procedure defined
in <a href="#XPATH20">[XPath 2.0]</a>, and each value in the atomized sequence is then
cast to an integer using the rules
 of the XPath <code>cast</code> construct. The resulting sequence of integers is used
 as the place marker to be formatted.  
</p><p>
					<a name="d5e11171"><small>[ERR099] </small></a>It is a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> 
if any item in the sequence 
 cannot be converted to an integer, or if the resulting integer is less than 1 (one). 
The <a title="processor" href="#dt-processor">processor</a> must either signal the error,
or must recover by converting that member to a
string as if by a call to the <u>fn:string</u> function
and inserting the resulting string into the formatted result string in
 its proper position.
					
				</p><p>Otherwise, the sequence is
formatted as a string using the <a title="effective value" href="#dt-effective-value">effective values</a>
of the attributes specified in <a href="#convert"><b>12.3 Number to String Conversion Attributes</b></a>; each of these attributes is
interpreted as an <a title="attribute value template" href="#dt-attribute-value-template">attribute
value template</a>.  After conversion, the <a href="#element-number"><code>xsl:number</code></a>
element constructs a new text node containing the resulting string, and returns this node.</p><div class="example"><p>The following example numbers a sorted list:</p><div class="exampleInner"><pre>&lt;xsl:template match="items"&gt;
  &lt;xsl:for-each select="item"&gt;
    &lt;xsl:sort select="."/&gt;
    &lt;p&gt;
      &lt;xsl:number value="fn:position()" format="1. "/&gt;
      &lt;xsl:value-of select="."/&gt;
    &lt;/p&gt;
  &lt;/xsl:for-each&gt;
&lt;/xsl:template&gt;</pre></div></div></div><div class="div2">
<h3><a name="d5e11213" id="d5e11213"></a>12.2 Numbering based on Position in a Document
				</h3><p>If no <code>value</code> attribute is specified, then the
<a href="#element-number"><code>xsl:number</code></a> instruction returns a new text
node containing a formatted
 <a title="place marker" href="#dt-place-marker">place marker</a> that is based on the position
of the <a title="context node" href="#dt-context-node">context node</a> within 
its containing document.</p><p>
					<a name="d5e11238"><small>[ERR100] </small></a>It is a
<a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> if the
<a href="#element-number"><code>xsl:number</code></a> instruction is evaluated, with no <code>value</code> attribute,
when the <a title="context item" href="#dt-context-item">context item</a> is not a node. 
The <a title="processor" href="#dt-processor">processor</a> must either signal the error,
or must recover by returning an empty sequence.
					
				</p><p> The following attributes control how the context node is to be numbered:</p><ul><li><p>The <code>level</code> attribute specifies rules for
selecting the nodes that are taken into account in allocating a number; 
it has the values
<code>single</code>, <code>multiple</code> or <code>any</code>. The
default is <code>single</code>.</p></li><li><p>The <code>count</code> attribute is 
a <a title="pattern" href="#dt-pattern">pattern</a> that specifies
which nodes should be counted at those levels.  If <code>count</code>
attribute is not specified, then it defaults to the pattern that
matches any node with the same node type as the context node and, if
the context node has an <a title="expanded-QName" href="#dt-expanded-qname">expanded-QName</a>, with the same <a title="expanded-QName" href="#dt-expanded-qname">expanded-QName</a> as
the context node.</p></li><li><p>The <code>from</code> attribute is 
a <a title="pattern" href="#dt-pattern">pattern</a> that specifies
where counting starts.</p></li></ul><p>In addition, the attributes specified in <a href="#convert"><b>12.3 Number to String Conversion Attributes</b></a>
are used for number to string conversion, as in the case when the
<code>value</code> attribute is specified.</p><p>The <a href="#element-number"><code>xsl:number</code></a> element first constructs a sequence of
positive integers using the <code>level</code>, <code>count</code> and
<code>from</code> attributes. Where <code>level</code> is <code>single</code>
or <code>any</code>, this sequence will either be empty or contain a single
number; where <code>level</code> is <code>multiple</code>, the sequence may
be of any length. The sequence is constructed as follows:</p><p>Let <code>matches-count($node)</code> be a function that returns true if the given
node matches the pattern given in the <code>count</code> attribute, or the implied
pattern (according to the rules given above) if the <code>count</code> attribute is omitted.</p><p>Let <code>matches-from($node)</code> be a function that returns true if the given
node matches the pattern given in the <code>from</code> attribute (this function
is not used if the <code>from</code> attribute is omitted).</p><p>When <code>level="single"</code>: </p><ul><li><p>Let <code>$A</code> be the node sequence selected by the expression</p><p>
							<code>&nbsp;&nbsp;&nbsp;ancestor-or-self::node()[matches-count(.)][fn:last()]</code>
						</p></li><li><p>If the <code>from</code> pattern is specified, let 
<code>$F</code> be the node sequence selected by the expression</p><p>
							<code>&nbsp;&nbsp;&nbsp;ancestor::node()[matches-from(.)][fn:last()]</code>
						</p><p>otherwise let <code>$F</code> be the root node, <code>/</code>
						</p></li><li><p>Let <code>$AF</code> be the value of</p><p>
							<code>&nbsp;&nbsp;&nbsp;$A intersect ($F/descendant::node())</code>
						</p></li><li><p>If <code>$AF</code> is empty, return the empty sequence, <code>()</code>
						</p></li><li><p>Otherwise return the value of</p><p>
							<code>&nbsp;&nbsp;&nbsp;1 + count($AF/preceding-sibling::node()[matches-count(.)])</code>
						</p></li></ul><p>When <code>level="multiple"</code>: </p><ul><li><p>Let <code>$A</code> be the node sequence selected by the expression</p><p>
							<code>&nbsp;&nbsp;&nbsp;ancestor-or-self::node()[matches-count(.)]</code>
						</p></li><li><p>If the <code>from</code> pattern is specified, let 
<code>$F</code> be the node sequence selected by the expression</p><p>
							<code>&nbsp;&nbsp;&nbsp;ancestor::node()[matches-from(.)][fn:last()]</code>
						</p><p>otherwise let <code>$F</code> be the root node, <code>/</code>
						</p></li><li><p>Let <code>$AF</code> be the value of</p><p>
							<code>&nbsp;&nbsp;&nbsp;$A intersect ($F/descendant::node())</code>
						</p></li><li><p>Return the result of the expression </p><p>
							<code>&nbsp;&nbsp;&nbsp;for $af in $AF return 1+count($af/preceding-sibling::node()[matches-count(.)])</code>
						</p></li></ul><p>When <code>level="any"</code>: </p><ul><li><p>Let <code>$A</code> be the node sequence selected by the expression</p><p>
							<code>&nbsp;&nbsp;&nbsp;(preceding::node()|ancestor-or-self::node())[matches-count(.)]</code>
						</p></li><li><p>If the <code>from</code> pattern is specified, let 
 <code>$F</code> be the node sequence selected by the expression</p><p>
							<code>&nbsp;&nbsp;&nbsp;(preceding::node()|ancestor::node())[matches-from(.)][fn:last()]</code>
						</p><p>and let <code>$AF</code> be
the node sequence <code>$A[. &gt;&gt; $F]</code>. Otherwise, let <code>$AF</code> be the
sequence <code>$A</code>.</p></li><li><p>If <code>$AF</code> is empty, return the empty sequence, <code>()</code>
						</p></li><li><p>Otherwise return the value of the expression <code>count($AF)</code>
						</p></li></ul><p>The sequence of numbers 
(the <a title="place marker" href="#dt-place-marker">place marker</a>)
is then converted into a string using the <a title="effective value" href="#dt-effective-value">effective values</a>
of the attributes specified in <a href="#convert"><b>12.3 Number to String Conversion Attributes</b></a>; each of these attributes is
interpreted as an <a title="attribute value template" href="#dt-attribute-value-template">attribute
value template</a>.  After conversion, the resulting string is
inserted in the result tree.</p><div class="example"><p>For example, the following will number the items in an ordered list:</p><div class="exampleInner"><pre>&lt;xsl:template match="ol/item"&gt;
  &lt;fo:block&gt;
    &lt;xsl:number/&gt;&lt;xsl:text&gt;. &lt;/xsl:text&gt;&lt;xsl:apply-templates/&gt;
  &lt;/fo:block&gt;
&lt;xsl:template&gt;</pre></div></div><p>&nbsp;</p><div class="example"><p>The following two rules will number <code>title</code> elements.
This is intended for a document that contains a sequence of chapters
followed by a sequence of appendices, where both chapters and
appendices contain sections, which in turn contain subsections.
Chapters are numbered 1, 2, 3; appendices are numbered A, B, C;
sections in chapters are numbered 1.1, 1.2, 1.3; sections in
appendices are numbered A.1, A.2, A.3.</p><div class="exampleInner"><pre>&lt;xsl:template match="title"&gt;
  &lt;fo:block&gt;
     &lt;xsl:number level="multiple"
                 count="chapter|section|subsection"
                 format="1.1 "/&gt;
     &lt;xsl:apply-templates/&gt;
  &lt;/fo:block&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="appendix//title" priority="1"&gt;
  &lt;fo:block&gt;
     &lt;xsl:number level="multiple"
                 count="appendix|section|subsection"
                 format="A.1 "/&gt;
     &lt;xsl:apply-templates/&gt;
  &lt;/fo:block&gt;
&lt;/xsl:template&gt;</pre></div></div><p>&nbsp;</p><div class="example"><p>The following example numbers notes sequentially within a
chapter:</p><div class="exampleInner"><pre>&lt;xsl:template match="note"&gt;
  &lt;fo:block&gt;
     &lt;xsl:number level="any" from="chapter" format="(1) "/&gt;
     &lt;xsl:apply-templates/&gt;
  &lt;/fo:block&gt;
&lt;/xsl:template&gt;</pre></div></div><p>&nbsp;</p><div class="example"><p>The following example will number <code>H4</code> elements in HTML
with a three-part label:</p><div class="exampleInner"><pre>&lt;xsl:template match="H4"&gt;
 &lt;fo:block&gt;
   &lt;xsl:number level="any" from="H1" count="H2"/&gt;
   &lt;xsl:text&gt;.&lt;/xsl:text&gt;
   &lt;xsl:number level="any" from="H2" count="H3"/&gt;
   &lt;xsl:text&gt;.&lt;/xsl:text&gt;
   &lt;xsl:number level="any" from="H3" count="H4"/&gt;
   &lt;xsl:text&gt; &lt;/xsl:text&gt;
   &lt;xsl:apply-templates/&gt;
 &lt;/fo:block&gt;
&lt;/xsl:template&gt;</pre></div></div></div><div class="div2">
<h3><a name="convert" id="convert"></a>12.3 Number to String Conversion Attributes</h3><p>The following attributes are used to control conversion of a
sequence of numbers into a string. The numbers are integers greater than
0. The attributes are all optional.</p><p>The main attribute is <code>format</code>.  The default value for
the <code>format</code> attribute is <code>1</code>.  The
<code>format</code> attribute is split into a sequence of tokens where
each token is a maximal sequence of alphanumeric characters or a
maximal sequence of non-alphanumeric characters.  <em>Alphanumeric</em> means
any character that has a Unicode category of Nd, Nl, No, Lu, Ll, Lt,
Lm or Lo.  The alphanumeric tokens (format tokens) specify the format
to be used for each number in the sequence.  If the first token is a
non-alphanumeric token, then the constructed string will start with
that token; if the last token is non-alphanumeric token, then the
constructed string will end with that token.  Non-alphanumeric tokens
that occur between two format tokens are separator tokens that are
used to join numbers in the sequence.  The <var>n</var>th format token
will be used to format the <var>n</var>th number in the sequence.  If
there are more numbers than format tokens, then the last format token
will be used to format remaining numbers.  If there are no format
tokens, then a format token of <code>1</code> is used to format all
numbers.  The format token specifies the string to be used to
represent the number 1.  Each number after the first will be separated
from the preceding number by the separator token preceding the format
token used to format that number, or, if there are no separator
tokens, then by <code>.</code> (a period character).</p><p>Format tokens are a superset of the allowed values for the
<code>type</code> attribute for the <code>OL</code> element in HTML
4.0 and are interpreted as follows:</p><ul><li><p>Any token where the last character has a decimal digit value
of 1 (as specified in the Unicode character property database),
and the Unicode value of preceding characters is one less than the
Unicode value of the last character generates a decimal
representation of the number where each number is at least as long as
the format token.  Thus, a format token <code>1</code> generates the
sequence <code>1 2 ... 10 11 12 ...</code>, and a format token
<code>01</code> generates the sequence <code>01 02 ... 09 10 11 12
... 99 100 101</code>.</p></li><li><p>A format token <code>A</code> generates the sequence <code>A
B C ... Z AA AB AC...</code>.</p></li><li><p>A format token <code>a</code> generates the sequence <code>a
b c ... z aa ab ac...</code>.</p></li><li><p>A format token <code>i</code> generates the sequence <code>i
ii iii iv v vi vii viii ix x ...</code>.</p></li><li><p>A format token <code>I</code> generates the sequence <code>I
II III IV V VI VII VIII IX X ...</code>.</p></li><li><p>Any other format token indicates a numbering sequence that
starts with that token.  It is
<a title="implementation-defined" href="#dt-implementation-defined">implementation-defined</a>
which numbering sequences, additional to those listed above, are supported.
If an implementation does not support a
numbering sequence that starts with the given token, it must use a format
token of <code>1</code>.</p></li></ul><p>For all format tokens other than the first kind above
(one that consists of decimal digits), there may be an
<a title="implementation-defined" href="#dt-implementation-defined">implementation-defined</a>
upper bound on the range of numbers that can be formatted using this format
token; indeed, for some numbering sequences there may be an
intrinsic limit. For the numbering sequences described above, the upper bound must not be
less than 1000 (one thousand). Numbers that exceed the upper bound
must be formatted using the format token <code>1</code>.</p><p>When numbering with an alphabetic sequence, the <code>lang</code>
attribute specifies which language's alphabet is to be used; it has
the same range of values as <code>xml:lang</code>
					<a href="#XML">[XML]</a>;
if no <code>lang</code> value is specified, the language should be
determined from the system environment.  The set of
languages for which numbering is supported is 
<a title="implementation-defined" href="#dt-implementation-defined">implementation-defined</a>.</p><p>The <code>letter-value</code> attribute disambiguates between
numbering sequences that use letters.  In many languages there are two
commonly used numbering sequences that use letters.  One numbering
sequence assigns numeric values to letters in alphabetic sequence, and
the other assigns numeric values to each letter in some other manner
traditional in that language.  In English, these would correspond to
the numbering sequences specified by the format tokens <code>a</code>
and <code>i</code>.  In some languages, the first member of each
sequence is the same, and so the format token alone would be
ambiguous.  A value of <code>alphabetic</code> specifies the
alphabetic sequence; a value of <code>traditional</code> specifies the
other sequence.  If the <code>letter-value</code> attribute is not
specified, then it is <a title="implementation-dependent" href="#dt-implementation-dependent">implementation-dependent</a> how any ambiguity is
resolved.</p><blockquote><table width="90%"><tr><td width="10%" align="left" valign="top"><b>Note:</b></td><td align="left" valign="top"><p>It is possible for two conforming implementations not to
convert a number to exactly the same string.  Some implementations might not
support some languages.  Furthermore, there may be variations possible
in the way conversions are performed for any particular language that
are not specifiable by the attributes on <a href="#element-number"><code>xsl:number</code></a>.
Future versions of XSLT may provide additional attributes to provide
control over these variations.  Implementations may also use
<a title="implementation-dependent" href="#dt-implementation-dependent">implementation-defined</a> namespaced attributes on
<a href="#element-number"><code>xsl:number</code></a> for this.</p></td></tr></table></blockquote><p>The <code>grouping-separator</code> attribute gives the separator
used as a grouping (e.g. thousands) separator in decimal numbering
sequences, and the optional <code>grouping-size</code> specifies the
size (normally 3) of the grouping.  For example,
<code>grouping-separator=","</code> and <code>grouping-size="3"</code>
would produce numbers of the form <code>1,000,000</code>.  If only one
of the <code>grouping-separator</code> and <code>grouping-size</code>
attributes is specified, then it is ignored.</p><p>Here are some examples of conversion specifications:</p><ul><li><p>
							<code>format="&amp;#x30A2;"</code> specifies Katakana
numbering</p></li><li><p>
							<code>format="&amp;#x30A4;"</code> specifies Katakana
numbering in the "iroha" order</p></li><li><p>
							<code>format="&amp;#x0E51;"</code> specifies numbering with
Thai digits</p></li><li><p>
							<code>format="&amp;#x05D0;" letter-value="traditional"</code>
specifies "traditional" Hebrew numbering</p></li><li><p>
							<code>format="&amp;#x10D0;" letter-value="traditional"</code>
specifies Georgian numbering</p></li><li><p>
							<code>format="&amp;#x03B1;" letter-value="traditional"</code>
specifies "classical" Greek numbering</p></li><li><p>
							<code>format="&amp;#x0430;" letter-value="traditional"</code>
specifies Old Slavic numbering</p></li></ul></div></div><div class="div1">
<h2><a name="sorting" id="sorting"></a>13 Sorting</h2><p>
				<a name="dt-sort-specification" id="dt-sort-specification" title="sort specification"></a>A 
<b>sort specification</b>
is a sequence of one or more adjacent <a href="#element-sort"><code>xsl:sort</code></a> elements which together define rules
for sorting the items in an input sequence to form a sorted sequence.
				<a name="dt-sort-key-definition" id="dt-sort-key-definition" title="sort key definition"></a>Within a
<a title="sort specification" href="#dt-sort-specification">sort specification</a>, each
<a href="#element-sort"><code>xsl:sort</code></a> element provides one <b>sort key definition</b>.
The first <a href="#element-sort"><code>xsl:sort</code></a>
element specifies the primary part of the sort specification, the second <a href="#element-sort"><code>xsl:sort</code></a>
element specifies the secondary part of the sort specification and so on.</p><p>A sort specification may occur as the content of 
an <a href="#element-sort-key"><code>xsl:sort-key</code></a>
declaration at the top level of a stylesheet module, or it may occur
immediately within an <a href="#element-apply-templates"><code>xsl:apply-templates</code></a>, 
<a href="#element-for-each"><code>xsl:for-each</code></a>, or <a href="#element-for-each-group"><code>xsl:for-each-group</code></a> element.</p><p>
				<a name="d5e11897"><small>[ERR101] </small></a>When used within <a href="#element-for-each"><code>xsl:for-each</code></a> or
<a href="#element-for-each-group"><code>xsl:for-each-group</code></a>, <a href="#element-sort"><code>xsl:sort</code></a>
elements must occur before any other children.
			</p><div class="div2">
<h3><a name="collating-sequences" id="collating-sequences"></a>13.1 Collating Sequences</h3><p><a name="dt-collation" id="dt-collation" title="collation"></a>Facilities in
 XSLT 2.0 and XPath 2.0 that require strings to be ordered rely on the concept of a named
<b>collation</b>. A collation is a set of rules that determine
whether two strings are equal, and if not, which of them should be sorted before the other.
 A collation is
identified by a URI, but the manner in which this URI is associated with an actual rule or algorithm
 is <a title="implementation-defined" href="#dt-implementation-defined">implementation-defined</a>.</p><blockquote><table width="90%"><tr><td width="10%" align="left" valign="top"><b>Note:</b></td><td align="left" valign="top"><p>The reason XSLT does not provide detailed mechanisms for defining collating sequences
is that many implementations will re-use collating mechanisms available from the underlying
implementation platform (for example, from the operating system or from the run-time library
of a chosen programming language). These will inevitably differ from one XSLT implementation
to another.</p></td></tr></table></blockquote></div><div class="div2">
<h3><a name="d5e11928" id="d5e11928"></a>13.2 The <a href="#element-sort"><code>xsl:sort</code></a> Element</h3><p class="element-syntax"><a name="element-sort"></a><code>&lt;xsl:sort<br>&nbsp;&nbsp;select = <var>expression</var><br>&nbsp;&nbsp;lang = { <var>nmtoken</var> }<br>&nbsp;&nbsp;as = { <var>qname</var> }<br>&nbsp;&nbsp;order = { "ascending" | "descending" }<br>&nbsp;&nbsp;collation = { <var>uri</var> }<br>&nbsp;&nbsp;case-order = { "upper-first" | "lower-first" }<br>&nbsp;&nbsp;data-type = { "text" | "number" | <var>qname-but-not-ncname</var> }&nbsp;/&gt;</code></p><p>Those attributes of the <a href="#element-sort"><code>xsl:sort</code></a> elements whose values
 are <a title="attribute value template" href="#dt-attribute-value-template">attribute value templates</a>
are evaluated using the <em>outer focus</em>. 
If the element that contains the <a href="#element-sort"><code>xsl:sort</code></a> elements is an <a href="#element-sort-key"><code>xsl:sort-key</code></a>
declaration, then the outer focus is a <a title="singleton focus" href="#dt-singleton-focus">singleton
focus</a> based on the document node of the document containing the
  <a title="initial context node" href="#dt-initial-context-node">initial context node</a>
					.
   Otherwise, the <em>outer focus</em> is the focus used to evaluate the
<code>select</code> attribute of the containing instruction
 (for example, <a href="#element-for-each"><code>xsl:for-each</code></a> or <a href="#element-apply-templates"><code>xsl:apply-templates</code></a>).</p><p>
					<a name="dt-initial-sequence" id="dt-initial-sequence" title="initial sequence"></a>The sequence to be sorted
is referred to as the <b>initial sequence</b>.
					<a name="dt-sorted-sequence" id="dt-sorted-sequence" title="sorted sequence"></a>The sequence after sorting 
as defined by the <a href="#element-sort"><code>xsl:sort</code></a> elements
is referred to as the <b>sorted sequence</b>.
				</p><p>
					<a name="dt-sort-key" id="dt-sort-key" title="sort key"></a>
For each item in the <a title="initial sequence" href="#dt-initial-sequence">initial sequence</a>,
a value is computed
for each <a title="sort key definition" href="#dt-sort-key-definition">sort key definition</a>
within the <a title="sort specification" href="#dt-sort-specification">sort specification</a>.
The value computed for an item by using the <var>N</var>th sort key definition
is referred to as the <var>N</var>th <b>sort key</b> of that item. 
Specifically, the 
<var>N</var>th sort key is computed by evaluating the <a title="expression" href="#dt-expression">expression</a> contained in the
<code>select</code> attribute of the <var>N</var>th <a href="#element-sort"><code>xsl:sort</code></a> element,
if there is such an attribute.
 If there is no <code>select</code> attribute, 
 the <a title="sort key" href="#dt-sort-key">sort key</a> is computed by taking the actual item
  in the initial sequence if it is an atomic value, or the typed-value of this
 item if it is a node.</p><p>The expression in the <code>select</code> attribute of the <a href="#element-sort"><code>xsl:sort</code></a> element
 is evaluated with the <a title="focus" href="#dt-focus">focus</a> set as follows:</p><ul><li><p>The <a title="context item" href="#dt-context-item">context item</a> is the item in the
 <a title="initial sequence" href="#dt-initial-sequence">initial sequence</a> whose sort key is
 being computed.</p></li><li><p>The <a title="context position" href="#dt-context-position">context position</a>
is the position of that item in the initial sequence.</p></li><li><p>The <a title="context size" href="#dt-context-size">context size</a> 
is the size of the initial sequence.</p></li><li></li></ul><p>If the <a href="#element-sort"><code>xsl:sort</code></a> element has an <code>as</code>
attribute, then the sort key is converted to the required type before comparing
it with other items, 
using the <a title="argument conversion rules" href="#dt-argument-conversion-rules">argument conversion rules</a>.</p><p>
					<a name="d5e12124"><small>[ERR102] </small></a>The target  type for each <a href="#element-sort"><code>xsl:sort</code></a> element is determined
 by the <a title="effective value" href="#dt-effective-value">effective value</a> of its
 <code>as</code> attribute. 

This must be the name of an atomic data type that is available
in the static context: that is, either the name of a built-in atomic type defined in <a href="#XMLSCHEMA">[XML Schema]</a>,
or the name of a type derived from such a type by restriction, defined in an imported schema. 
It is a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> if any other value is
supplied. The <a title="processor" href="#dt-processor">processor</a> must either signal the error, 
or must recover
by continuing as if the <code>as</code> attribute were not specified.
					
				</p><p>For backwards compatibility with XSLT 1.0, the attribute <code>data-type</code> is
available as an alternative to <code>as</code>. If 
 this has the value <code>text</code>, the required type is <code>xs:string</code>. 
 If it has the value <code>number</code>, the required type is <code>xs:double</code>. If it has
 any other value, the effect is implementation-defined. If this attribute is
 used, the value returned by the <code>select</code> <a title="expression" href="#dt-expression">expression</a> is converted to the required type
 by using the <u>fn:string</u> or <u>fn:number</u> function as appropriate.</p><p>If the <code>as</code> and <code>data-type</code> attributes are both present,
the <code>data-type</code> attribute is ignored. The implementation may check that its value is valid,
but is not required to do so.</p><p>Each <a title="sort key" href="#dt-sort-key">sort key</a> 
				(unless it is the empty sequence: see below)
				is converted to the target  type using the rules for the
 XPath <code>cast</code> <a title="expression" href="#dt-expression">expression</a>. <a name="d5e12232"><small>[ERR103] </small></a>It
 is a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> if any value 
 (other than the empty sequence) obtained by
 evaluating the <code>select</code> attribute of an <a href="#element-sort"><code>xsl:sort</code></a> element
 cannot be converted to the target  type. 
 The <a title="processor" href="#dt-processor">processor</a> must either signal the error, 
 or must recover by treating the value as 
 an exception value.
 
					
				</p><p>The values of the sort keys (after any conversion) are first divided into three
categories: empty values, exception values, and ordinary values. The empty values represent those
items where the sort key evaluates to an empty sequence. These values are considered for sorting
purposes to be equal to each other, but less than any other value. The exception values represent
those items where the sort key cannot be converted to the target data type, together with the
<code>xs:double</code> and <code>xs:float</code> value <code>NaN</code>. Exception values are considered
for sorting purposes to be equal to each other, greater than any empty value, but less than any ordinary
value. The remaining values are classified as ordinary values.</p><p>In general, comparison of two ordinary values is
 performed according to the rules of the
 XPath <code>lt</code> operator. However, special rules
  apply to the <code>xs:string</code> type, as described below. </p><p> <a name="d5e12283"><small>[ERR104] </small></a>It is a
 <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> if, for any
  <a title="sort key definition" href="#dt-sort-key-definition">sort key definition</a>,
 the set of <a title="sort key" href="#dt-sort-key">sort keys</a> evaluated for all the items in the
 <a title="initial sequence" href="#dt-initial-sequence">initial sequence</a>, after any type conversion requested,
 contains a pair of ordinary values for which the result of the
 XPath <code>lt</code> operator is an error or an empty sequence. 
 The <a title="processor" href="#dt-processor">processor</a> must either signal the error, 
 or must recover by assigning an arbitrary ordering to any such
 pair of values.
					</p><p>If there is no 
						<code>as</code> or <code>data-type</code> attribute, 
then the computed <a title="sort key" href="#dt-sort-key">sort key</a>s are not converted
before comparison, except in the case where the  type of a computed sort key is a complex
type, in which case it is converted to a string as if by the XPath <u>fn:string</u> function.</p><p>The items in the <a title="initial sequence" href="#dt-initial-sequence">initial sequence</a>
 are ordered into a <a title="sorted sequence" href="#dt-sorted-sequence">sorted sequence</a> by comparing their
<a title="sort key" href="#dt-sort-key">sort key</a>s. The relative position of two items <var>A</var> and <var>B</var> in the sorted
 sequence is determined as follows. The first sort key of <var>A</var> is compared
 with the first sort key of <var>B</var>, according to the rules of the first
  <a title="sort key definition" href="#dt-sort-key-definition">sort key definition</a>. If, under these rules,
   <var>A</var> is less than <var>B</var>, then <var>A</var> will precede <var>B</var>
 in the sorted sequence, unless the <code>order</code> attribute of this sort key definition specifies
 <code>descending</code>, in which case <var>B</var> will precede <var>A</var>
 in the sorted sequence. If, however, the relevant sort keys compare equal,
 then the second sort key of <var>A</var> is compared
 with the second sort key of <var>B</var>, according to the rules of the second sort key definition.
 This continues until two sort keys are found that compare unequal. If all 
 the sort keys compare equal, then <var>A</var> will precede <var>B</var> in the
  <a title="sorted sequence" href="#dt-sorted-sequence">sorted sequence</a> if
 <var>A</var> preceded <var>B</var> in the <a title="initial sequence" href="#dt-initial-sequence">initial sequence</a>,
  and vice versa.</p><p>
					<a name="d5e12406"><small>[ERR105] </small></a>It is a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> if
  the <a title="effective value" href="#dt-effective-value">effective value</a>
 of the <code>as</code> attribute of the <a href="#element-sort"><code>xsl:sort</code></a> element is
  a  type for which no ordering
 relation is defined
						The <a title="processor" href="#dt-processor">processor</a> must signal the error, or must recover by
  continuing as if the <code>as</code> attribute were omitted.
					
				</p><p>For comparison of string values, special rules apply. If the <a href="#element-sort"><code>xsl:sort</code></a> element has a
 <code>collation</code> attribute, then the strings are compared according to the rules for the named
 <a title="collation" href="#dt-collation">collation</a>: that is, they are compared using the XPath 
 function call <code>fn:compare($a, $b, $collation)</code>.</p><blockquote><table width="90%"><tr><td width="10%" align="left" valign="top"><b>Note:</b></td><td align="left" valign="top"><p>XSLT provides no facilities to declare or define collations: such mechanisms
 are expected to be provided by implementors. Equally, this specification does not define what happens
 if the collation name is not recognized: the implementation may signal an error, or it may use the default
 collation.</p></td></tr></table></blockquote><p>The <code>lang</code> and <code>case-order</code> attributes are 
 ignored if a <code>collation</code> attribute
 is present. But in the absence of a <code>collation</code> 
 attribute, these attributes provide input to an 
 <a title="implementation-defined" href="#dt-implementation-defined">implementation-defined</a>
  algorithm to identify a suitable collation:</p><ul><li><p>The <code>lang</code> attribute indicates that a collation
 suitable for a particular natural language is required. The 
 <a title="effective value" href="#dt-effective-value">effective value</a> of
 the attribute must be a value that would be valid for the
 <code>xml:lang</code> attribute (see <a href="#XML">[XML]</a>).</p></li><li><p>The <code>case-order</code> attribute indicates whether
 the desired collation should sort upper-case letters before 
 lower case or vice versa. The 
 <a title="effective value" href="#dt-effective-value">effective value</a> of
 the attribute must be either <code>lower-first</code> (indicating
 that lower-case letters precede upper-case letters in the collating
 sequence) or <code>upper-first</code> (indicating that upper-case
 letters precede lower-case).</p></li></ul><p>In the absence of any of these attributes, the default collation is used.</p><blockquote><table width="90%"><tr><td width="10%" align="left" valign="top"><b>Note:</b></td><td align="left" valign="top"><p>The exact results of sorting are
<a title="implementation-dependent" href="#dt-implementation-dependent">implementation-dependent</a>.
Some implementations might not support some
languages.  Furthermore, there may be variations possible in the
sorting of any particular language that are not specified by the
attributes on <a href="#element-sort"><code>xsl:sort</code></a>, for example, whether Hiragana or
Katakana is sorted first in Japanese.  
Implementations may also use <a title="implementation-defined" href="#dt-implementation-defined">implementation-defined</a>
namespaced attributes on <a href="#element-sort"><code>xsl:sort</code></a> for this.</p></td></tr></table></blockquote><blockquote><table width="90%"><tr><td width="10%" align="left" valign="top"><b>Note:</b></td><td align="left" valign="top"><p>It is recommended that implementors consult <a href="#UNICODE-TR10">[UNICODE TR10]</a> for information on internationalized
sorting.</p></td></tr></table></blockquote></div><div class="div2">
<h3><a name="d5e12548" id="d5e12548"></a>13.3 Using Unnamed Sort Specifications</h3><p>When used within <a href="#element-for-each"><code>xsl:for-each</code></a> or
<a href="#element-apply-templates"><code>xsl:apply-templates</code></a>, a
<a title="sort specification" href="#dt-sort-specification">sort specification</a> indicates that
the sequence of items selected by that instruction should be processed
in sorted order, not in the order of the supplied sequence.</p><div class="example"><p>For example, suppose an employee database has the form</p><div class="exampleInner"><pre>&lt;employees&gt;
  &lt;employee&gt;
    &lt;name&gt;
      &lt;given&gt;James&lt;/given&gt;
      &lt;family&gt;Clark&lt;/family&gt;
    &lt;/name&gt;
    ...
  &lt;/employee&gt;
&lt;/employees&gt;
</pre></div><p>Then a list of employees sorted by name could be generated
using:</p><div class="exampleInner"><pre>&lt;xsl:template match="employees"&gt;
  &lt;ul&gt;
    &lt;xsl:apply-templates select="employee"&gt;
      &lt;xsl:sort select="name/family"/&gt;
      &lt;xsl:sort select="name/given"/&gt;
    &lt;/xsl:apply-templates&gt;
  &lt;/ul&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="employee"&gt;
  &lt;li&gt;
    &lt;xsl:value-of select="name/given"/&gt;
    &lt;xsl:text&gt; &lt;/xsl:text&gt;
    &lt;xsl:value-of select="name/family"/&gt;
  &lt;/li&gt;
&lt;/xsl:template&gt;</pre></div></div><p>When used within <a href="#element-for-each-group"><code>xsl:for-each-group</code></a>, a
<a title="sort specification" href="#dt-sort-specification">sort specification</a>
indicates the order in which the groups should be processed.
For the effect of <a href="#element-for-each-group"><code>xsl:for-each-group</code></a>, see
 <a href="#grouping"><b>14 Grouping</b></a>
				</p></div><div class="div2">
<h3><a name="named-sort-key" id="named-sort-key"></a>13.4 Using Named Sort Specifications</h3><div class="div3">
<h4><a name="d5e12587" id="d5e12587"></a>13.4.1 Declaring a Named Sort Specification</h4><p class="element-syntax"><a name="element-sort-key"></a><code>&lt;!-- Category: declaration --&gt;<br>&lt;xsl:sort-key<br>&nbsp;&nbsp;<b>name</b> = <var>qname</var>&gt;<br>&nbsp;&nbsp;&lt;!-- Content: (<a href="#element-sort">xsl:sort</a>+) --&gt;<br>&lt;/xsl:sort-key&gt;</code></p><p>
						<a name="dt-named-sort-key" id="dt-named-sort-key" title="named sort specification"></a>A 
<b>named sort specification</b> is defined
 by an <a href="#element-sort-key"><code>xsl:sort-key</code></a> declaration. This is a top-level
element in the stylesheet. The <code>name</code> attribute is mandatory.
The value of the <code>name</code> attribute is a <a title="QName" href="#dt-qname">QName</a>, which is expanded as described
in <a href="#qname"><b>5.1 Qualified Names</b></a>: it need not have a prefix.</p><p>The content of the <a href="#element-sort-key"><code>xsl:sort-key</code></a>
element consists of one or more <a href="#element-sort"><code>xsl:sort</code></a> elements
that define the components of the 
<a title="sort specification" href="#dt-sort-specification">sort specification</a>, 
in major to minor order.</p><p>If a stylesheet contains declarations of two or more
 <a title="named sort specification" href="#dt-named-sort-key">named sort specifications</a> with the same <a title="expanded-QName" href="#dt-expanded-qname">expanded-QName</a>,
the one with highest <a title="import precedence" href="#dt-import-precedence">import precedence</a>
 is used. <a name="d5e12644"><small>[ERR106] </small></a>It is a <a title="static error" href="#dt-static-error">static error</a> for
a stylesheet to contain two or more named sort specifications with the same <a title="expanded-QName" href="#dt-expanded-qname">expanded-QName</a>
and the same import precedence, unless there is another named sort specification with the
same <a title="expanded-QName" href="#dt-expanded-qname">expanded-QName</a> and a higher import precedence.
					</p></div><div class="div3">
<h4><a name="d5e12656" id="d5e12656"></a>13.4.2 Sorting Using a Named Sort Specification</h4><a name="function-sort" id="function-sort"></a><div class="proto"><code class="function">sort</code>(<code class="arg">$sort-spec-name</code><code class="as">&nbsp;as&nbsp;</code><code class="type">xs:string</code>, <code class="arg">$input-sequence</code><code class="as">&nbsp;as&nbsp;</code><code class="type">(item)*</code>)<code class="as">&nbsp;as&nbsp;</code><code class="return-type">item*</code></div><p>In an XPath <a title="expression" href="#dt-expression">expression</a> used within an XSLT stylesheet, an additional function <a href="#function-sort"><b>sort</b></a>
is available, which sorts a sequence using a named sort specification.</p><p>The <code>$sort-spec-name</code> argument is evaluated as a string; its value must be a <a title="QName" href="#dt-qname">QName</a> whose <a title="expanded-QName" href="#dt-expanded-qname">expanded-QName</a> is the
same as the name of a <a title="named sort specification" href="#dt-named-sort-key">named sort specification</a> defined in
the stylesheet. <a name="d5e12684"><small>[ERR107] </small></a>It is a 
<a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> if the first argument of the <a href="#function-sort"><b>sort</b></a>
function does not match the name of any <a title="named sort specification" href="#dt-named-sort-key">named sort specification</a> in the stylesheet.
The <a title="processor" href="#dt-processor">processor</a> must signal the error.
						
					</p><p>The value of the <code>$input-sequence</code> argument forms the
 <a title="initial sequence" href="#dt-initial-sequence">initial sequence</a>
for the sort. The sequence is sorted according to the rules for the named sort specification, and the
result of the function call is the resulting
 <a title="sorted sequence" href="#dt-sorted-sequence">sorted sequence</a>.</p></div></div></div><div class="div1">
<h2><a name="grouping" id="grouping"></a>14 Grouping</h2><p>The facilities described in this section are designed to allow
 users to group nodes in a document based on common string values,
 common names, or commmon values for any other <a title="expression" href="#dt-expression">expression</a>. Since
 grouping identifies items with duplicate values, the
 same facilities also allow selection of the distinct values in
 a sequence of items, that is, the elimination of duplicates.</p><p>In addition these facilities allow grouping based on sequential position, e.g.
selecting groups of adjacent <code>PARA</code> elements. The facilities also provide an easy
way to do fixed-size grouping, for example identifying groups of three adjacent nodes, 
which is useful when arranging data in multiple columns.</p><p>For each group of items identified, it is possible to evaluate
 a <a title="content constructor" href="#dt-content-constructor">content constructor</a>
 for the group.
 Grouping is nestable to multiple levels so that groups of distinct items can be
  identified, then from among the distinct groups selected, further sub-grouping of 
  distinct items in the current group can be done. </p><div class="div2">
<h3><a name="current-group" id="current-group"></a>14.1 The Current Group</h3><a name="function-current-group" id="function-current-group"></a><div class="proto"><code class="function">current-group</code>()<code class="as">&nbsp;as&nbsp;</code><code class="return-type">item*</code></div><p>
					<a name="dt-current-group" id="dt-current-group" title="current group"></a>The evaluation context for 
XPath <a title="expression" href="#dt-expression">expressions</a> includes an additional value
called the <b>current group</b>, which is a sequence. The current group is the collection of
related items that are processed collectively in one iteration of the <a href="#element-for-each-group"><code>xsl:for-each-group</code></a> element.
				</p><p>While an <a href="#element-for-each-group"><code>xsl:for-each-group</code></a> instruction is being evaluated,
the current group will be non-empty. At other times, it will be an empty sequence.</p><p>The function <a href="#function-current-group"><b>current-group</b></a> returns the current group.</p><p>The function takes no arguments.</p><p>
					<a name="d5e12763"><small>[ERR108] </small></a>The <a href="#function-current-group"><b>current-group</b></a> function must not be used
within a <a title="pattern" href="#dt-pattern">pattern</a>.
				</p></div><div class="div2">
<h3><a name="d5e12772" id="d5e12772"></a>14.2 The <code>xsl:for-each-group</code> Element</h3><p class="element-syntax"><a name="element-for-each-group"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:for-each-group<br>&nbsp;&nbsp;<b>select</b> = <var>expression</var><br>&nbsp;&nbsp;group-by = <var>expression</var><br>&nbsp;&nbsp;group-adjacent = <var>expression</var><br>&nbsp;&nbsp;group-starting-with = <var>pattern</var><br>&nbsp;&nbsp;group-ending-with = <var>pattern</var><br>&nbsp;&nbsp;collation = { <var>uri</var> }<br>&nbsp;&nbsp;as = <var>qname</var>&gt;<br>&nbsp;&nbsp;&lt;!-- Content: (<a href="#element-sort">xsl:sort</a>*, <var>content-constructor</var>) --&gt;<br>&lt;/xsl:for-each-group&gt;</code></p><p>This element is an <a title="instruction" href="#dt-instruction">instruction</a> that
 may be used anywhere within a <a title="content constructor" href="#dt-content-constructor">content constructor</a>.</p><p>
					<a name="dt-group" id="dt-group" title="group"></a>The <a href="#element-for-each-group"><code>xsl:for-each-group</code></a> instruction partitions a sequence into
<b>group</b>s of items (that is, it establishes a set of sequences) based either on common
values of a grouping key, or on 
a <a title="pattern" href="#dt-pattern">pattern</a> that the initial node in a group must match.
The <a title="content constructor" href="#dt-content-constructor">content constructor</a> that forms the content of the
<a href="#element-for-each-group"><code>xsl:for-each-group</code></a> instruction is evaluated once
for each of these groups. A group is never empty.</p><p>
					<a name="dt-population" id="dt-population" title="population"></a>The sequence of items
 to be grouped, which
 is referred to as the <b>population</b>,
is determined by evaluating the XPath <a title="expression" href="#dt-expression">expression</a> contained in the
<code>select</code> attribute.

<a name="dt-population-order" id="dt-population-order" title="population order"></a>The population is treated as a sequence; 
the order of
items in this sequence is referred to as <b>population order</b>
					. If the
population is empty, the number of groups will be zero. Each item 
in the population is assigned to exactly one group: the assignment 
of items to groups depends on the <code>group-by</code>,  
<code>group-adjacent</code>, <code>group-starting-with</code>
					, 
and <code>group-ending-with</code>
					 attributes.
<a name="d5e12872"><small>[ERR109] </small></a>These four attributes 

are mutually exclusive: exactly one of the four attributes must be present.
				</p><p>
					<a name="d5e12895"><small>[ERR110] </small></a>The <code>as</code> attribute,
if specified, must be the name of an atomic type (either a built-in type, or a type defined in an
imported schema).
				</p><p>
					<a name="d5e12903"><small>[ERR111] </small></a>It is an error to specify either the
 <code>as</code> attribute or the <code>collation</code> attribute if neither the
<code>group-by</code> attribute nor <code>group-adjacent</code> attribute is specified.
				</p><p><a name="dt-grouping-key" id="dt-grouping-key" title="grouping key"></a>If either of the
<code>group-by</code> attribute nor <code>group-adjacent</code> attributes is present, then
a <b>grouping key</b> is calculated for each item in the <a title="population" href="#dt-population">population</a>.
The <a title="expression" href="#dt-expression">expression</a> contained in the <code>group-by</code> or <code>group-adjacent</code> attribute is
evaluated with that item as the <a title="context item" href="#dt-context-item">context item</a>, with its position 
in <a title="population order" href="#dt-population-order">population order</a> as the 
<a title="context position" href="#dt-context-position">context position</a>, and with the size of the 
population as the <a title="context size" href="#dt-context-size">context size</a>.
If the <code>as</code> attribute is present, the result 
of evaluating the <code>group-by</code> expression is converted to the specified type
using the <a title="argument conversion rules" href="#dt-argument-conversion-rules">argument conversion rules</a>;
otherwise, it is converted as if the <code>as</code> attribute were <code>xs:string</code>. The 
resulting value is known as the <b>grouping key</b> for that item.</p><p><a name="d5e12974"><small>[ERR112] </small></a>It is a <a title="type errors" href="#dt-type-error">type error</a>
if the result of evaluating the <code>group-by</code> or <code>group-adjacent</code> attribute,
for any item in the population, cannot be converted to the required type using the
 <a title="argument conversion rules" href="#dt-argument-conversion-rules">argument conversion rules</a>.
 This includes the case where the result is an empty sequence, or a sequence containing
more than one item. The processor must signal the error.</p><p><a title="grouping key" href="#dt-grouping-key">Grouping keys</a> are compared using the rules for the <code>eq</code> operator
appropriate to the required type. 
If the the required type is <code>xs:string</code> or a type
 derived from <code>xs:string</code> by restriction, they are compared using the collation specified
in the <code>collation</code> attribute if present, or the default collation otherwise.
For the purposes of grouping, the value <code>NaN</code> is considered equal to itself.</p><ul><li><p>If the <code>group-by</code> attribute is present, then  
all items that have the same value for the <a title="grouping key" href="#dt-grouping-key">grouping key</a> are assigned to 
the same group, and the number of groups is the same as the number of 
distinct grouping key values present in the <a title="population" href="#dt-population">population</a>.
</p><div><blockquote><p><b><a href="#issue-item-in-multiple-groups">Issue 127 (item-in-multiple-groups)</a>: </b>If the <code>group-by</code> attribute evaluates to a sequence, we could interpret
    this as meaning that the item is to be included in several groups. This would be consistent with
    the treatment of <a href="#element-key"><code>xsl:key</code></a>. A new function <code>current-group-value()</code> might
    be needed to determine which group is being processed. See email from Jeni Tennison on public-qt-editors.
    </p></blockquote></div></li><li><p>If the <code>group-adjacent</code> attribute is present, the 
items in the <a title="population" href="#dt-population">population</a> are examined, in population order. 
If an item 
has the same value for the <a title="grouping key" href="#dt-grouping-key">grouping key</a> as its preceding item within 
the <a title="population" href="#dt-population">population</a>
(in <a title="population order" href="#dt-population-order">population order</a>), then it is assigned to the same group as its 
preceding item; otherwise a new group is created and the item 
becomes its first member.</p></li><li><p>If the <code>group-starting-with</code> attribute is present, then its value must be
a <a href="#NT-Pattern">pattern</a>. In this case, the items in the population must all be nodes.
<a name="d5e13060"><small>[ERR113] </small></a>It is a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> if the
result of evaluating the <code>select</code> expression  
contains an item that is not a node.
The <a title="processor" href="#dt-processor">processor</a> must signal the error.
							
						</p><p>The nodes in the <a title="population" href="#dt-population">population</a> are
examined in <a title="population order" href="#dt-population-order">population order</a>. If a node matches
the pattern, or is the first node in the population, then a new group is created and the
node becomes its first member. Otherwise, the node is assigned to the same group as its
preceding node within the population.</p></li><li><p>If the <code>group-ending-with</code> attribute is present, then its value must be
a <a href="#NT-Pattern">pattern</a>. In this case, the items in the population must all be nodes.
<a name="d5e13101"><small>[ERR114] </small></a>It is a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> if the
result of evaluating the <code>select</code> expression  
contains an item that is not a node.
The <a title="processor" href="#dt-processor">processor</a> must signal the error.
							
						</p><p>The nodes in the <a title="population" href="#dt-population">population</a> are
examined in <a title="population order" href="#dt-population-order">population order</a>. 
If a node is the first node in the population, or if the previous node in the population matches
the pattern, then a new group is created and the
node becomes its first member. Otherwise, the node is assigned to the same group as its
preceding node within the population.</p></li></ul><p>For each <a title="group" href="#dt-group">group</a>, the item within the group that is first in
<a title="population order" href="#dt-population-order">population order</a> 
is known as the initial item of the group. </p><p>
					<a name="dt-first-appearance" id="dt-first-appearance" title="order of first appearance"></a>There is an ordering
among <a title="group" href="#dt-group">groups</a> referred to as the <b>order of first
appearance</b>. A group <var>G</var> is defined to precede a group <var>H</var> in order of first
appearance if the initial item of <var>G</var> precedes the initial item of <var>H</var> 
in population order.
				</p><p>There is another ordering among groups referred to as processing order.</p><p>If there are no <a href="#element-sort"><code>xsl:sort</code></a> elements immediately within
the <a href="#element-for-each-group"><code>xsl:for-each-group</code></a> element, the processing order of
the <a title="group" href="#dt-group">groups</a> is the <a title="order of first appearance" href="#dt-first-appearance">order of first appearance</a>.</p><p>Otherwise, the <a href="#element-sort"><code>xsl:sort</code></a> elements immediately within
the <a href="#element-for-each-group"><code>xsl:for-each-group</code></a> element define the processing
order of the <a title="group" href="#dt-group">groups</a> (see <a href="#sorting"><b>13 Sorting</b></a>). 
They do not affect the order of items within each group. 
Multiple sort keys are allowed, and are evaluated in major-to-minor 
order. If two groups have the same values for all their sort keys, 
they are processed in order of first appearance.</p><p>The <code>select</code> <a title="expression" href="#dt-expression">expression</a>
				 of an <a href="#element-sort"><code>xsl:sort</code></a> element is 
evaluated once for each <a title="group" href="#dt-group">group</a>. During this evaluation, the <a title="context item" href="#dt-context-item">context item</a> is the initial item of the group,
the <a title="context position" href="#dt-context-position">context position</a> is the position
of this item within the 
set of initial items (that is, one item for each group in the 
<a title="population" href="#dt-population">population</a>) in
<a title="population order" href="#dt-population-order">population order</a>, 
the <a title="context size" href="#dt-context-size">context size</a>
is the number of groups,
and the
<a title="current group" href="#dt-current-group">current group</a> is the group 
whose sort key is being determined.</p><div class="example"><p>This means that if 
the <a title="grouping key" href="#dt-grouping-key">grouping key</a> is 
<code>"@category"</code>, you can sort the groups in order of 
their grouping key by writing <code>&lt;xsl:sort select="@category"/&gt;</code>; 
or you can sort the groups in order of size by writing 
<code>&lt;xsl:sort select="count(current-group())" as="xs:integer"&gt;</code>
					</p></div><p>If there are <a title="attribute value template" href="#dt-attribute-value-template">attribute value templates</a> present in the 
<a href="#element-sort"><code>xsl:sort</code></a> element, the <a title="focus" href="#dt-focus">focus</a> for evaluation 
of the contained <a title="expression" href="#dt-expression">expressions</a> is the same as the focus 
for evaluation of the <code>select</code> attribute of 
the containing <a href="#element-for-each-group"><code>xsl:for-each-group</code></a> instruction.</p><p>The <a title="content constructor" href="#dt-content-constructor">content constructor</a> contained 
by the <a href="#element-for-each-group"><code>xsl:for-each-group</code></a> 
element is evaluated once for each of the <a title="group" href="#dt-group">groups</a>, in 
processing order. The node sequences that result are concatenated,
in processing order, to form the result of the <a href="#element-for-each-group"><code>xsl:for-each-group</code></a> 
element. Within the <a title="content constructor" href="#dt-content-constructor">content constructor</a>, the
<a title="context item" href="#dt-context-item">context item</a> is 
the initial item of the relevant group, the 
<a title="context position" href="#dt-context-position">context position</a> is
the position of this item among
the set of initial items (one item for each group) 
arranged in processing order of the groups, 
the <a title="context size" href="#dt-context-size">context size</a> is the number of groups,
and the <a title="current group" href="#dt-current-group">current group</a>
is the <a title="group" href="#dt-group">group</a> being processed. This has the effect that 
within the the <a title="content constructor" href="#dt-content-constructor">content constructor</a>, a call on <code>fn:position()</code> takes 
successive values <code>1, 2, ... fn:last()</code>.</p><p>On completion of the evaluation of the <a href="#element-for-each-group"><code>xsl:for-each-group</code></a>, the
<a title="current group" href="#dt-current-group">current group</a> reverts to its previous value.</p></div><div class="div2">
<h3><a name="d5e13310" id="d5e13310"></a>14.3 Examples of Grouping</h3><div class="example"><p>The following example groups a list of nodes based on common values. The resulting
groups are numbered but unsorted, and a total is calculated for each group. </p><p>Source XML document:</p><div class="exampleInner"><pre>&lt;cities&gt;
  &lt;city name="Milano"  country="Italia"      pop="5"/&gt;
  &lt;city name="Paris"   country="France"      pop="7"/&gt;
  &lt;city name="M&uuml;nchen" country="Deutschland" pop="4"/&gt;
  &lt;city name="Lyon"    country="France"      pop="2"/&gt;
  &lt;city name="Venezia" country="Italia"      pop="1"/&gt;
&lt;/cities&gt;</pre></div><p>More specifically, the aim is to produce a four-column table,
    containing one row for each distinct country. The four columns are to contain
    first, a sequence number giving the number of the row;
    second, the name of the country, third, a comma-separated 
    alphabetical list of the city names within that
    country, and fourth, the sum of the <code>pop</code> attribute for
    the cities in that country.</p><p>Desired output:</p><div class="exampleInner"><pre>&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;Position&lt;/th&gt;
    &lt;th&gt;Country&lt;/th&gt;
    &lt;th&gt;List of Cities&lt;/th&gt;
    &lt;th&gt;Population&lt;/th&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;1&lt;/td&gt;
    &lt;td&gt;Italia&lt;/td&gt;
    &lt;td&gt;Milano, Venezia&lt;/td&gt;
    &lt;td&gt;6&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;2&lt;/td&gt;
    &lt;td&gt;France&lt;/td&gt;
    &lt;td&gt;Lyon, Paris&lt;/td&gt;
    &lt;td&gt;9&lt;/td&gt;
  &lt;/tr&gt;  
  &lt;tr&gt;
    &lt;td&gt;3&lt;/td&gt;
    &lt;td&gt;Deutschland&lt;/td&gt;
    &lt;td&gt;M&uuml;nchen&lt;/td&gt;
    &lt;td&gt;4&lt;/td&gt;
  &lt;/tr&gt;  
&lt;/table&gt;</pre></div><p>Solution:</p><div class="exampleInner"><pre>&lt;table xsl:version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
  &lt;tr&gt;
    &lt;th&gt;Position&lt;/th&gt;
    &lt;th&gt;Country&lt;/th&gt;
    &lt;th&gt;City List&lt;/th&gt;
    &lt;th&gt;Population&lt;/th&gt;
  &lt;/tr&gt;
  &lt;xsl:for-each-group select="cities/city" group-by="@country"&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;xsl:value-of select="fn:position()"/&gt;&lt;/td&gt;
      &lt;td&gt;&lt;xsl:value-of select="@country"/&gt;&lt;/td&gt;
      &lt;td&gt;
        &lt;xsl:value-of select="current-group()/@name" separator=","/&gt;
      &lt;/td&gt;
      &lt;td&gt;&lt;xsl:value-of select="sum(current-group()/@pop)"/&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/xsl:for-each-group&gt;
&lt;/table&gt;</pre></div></div><p>&nbsp;</p><div class="example"><p>The following example uses the same source document, this time
	 grouping the cities according to the initial letter of the city name. The groups
	 are sorted, and the result includes a count of the nodes within the group.
	 The heading contains a count of the number of groups:</p><p>Desired output:</p><div class="exampleInner"><pre>&lt;html&gt;
  &lt;body&gt;
    &lt;h2&gt;L (1)&lt;/h2&gt;&lt;p&gt;Lyon&lt;/p&gt;
    &lt;h2&gt;M (2)&lt;/h2&gt;&lt;p&gt;Milano&lt;/p&gt;&lt;p&gt;M&uuml;nchen&lt;/p&gt;
    &lt;h2&gt;P (1)&lt;/h2&gt;&lt;p&gt;Paris&lt;/p&gt;
    &lt;h2&gt;V (1)&lt;/h2&gt;&lt;p&gt;Venezia&lt;/p&gt;
  &lt;/body&gt;
    &lt;/html&gt;</pre></div><p>Solution:</p><div class="exampleInner"><pre>&lt;html xsl:version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
  &lt;body&gt;
    &lt;xsl:for-each-group select="cities/city" group-by="substring(@name,1,1)"&gt;
      &lt;xsl:sort select="substring(@name,1,1)"/&gt;
      &lt;h2&gt;
        &lt;xsl:value-of select="upper-case(substring(@name,1,1))"/&gt;
        &lt;xsl:text&gt; (&lt;/xsl:text&gt;
        &lt;xsl:value-of select="count(current-group())"/&gt;
        &lt;xsl:text&gt;)&lt;/xsl:text&gt;
      &lt;/h2&gt;
      &lt;xsl:for-each select="current-group()"&gt;
        &lt;p&gt;&lt;xsl:value-of select="@name"/&gt;&lt;/p&gt;
      &lt;/xsl:for-each&gt;
    &lt;/xsl:for-each-group&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre></div></div><p>&nbsp;</p><div class="example"><p>The next example identifies a group not by the presence of a common value, but rather 
 by adjacency in document order. A group consists of an <code>h2</code> element,
 followed by all the <code>p</code> elements up to the next <code>h2</code> element.</p><p>Source XML document:</p><div class="exampleInner"><pre>&lt;body&gt;
  &lt;h2&gt;Introduction&lt;/h2&gt;
  &lt;p&gt;XSLT is used to write stylesheets.&lt;/p&gt;
  &lt;p&gt;XQuery is used to query XML databases.&lt;/p&gt;
  &lt;h2&gt;What is a stylesheet?&lt;/h2&gt;
  &lt;p&gt;A stylesheet is an XML document used to define a transformation.&lt;/p&gt;
  &lt;p&gt;Stylesheets may be written in XSLT.&lt;/p&gt;
  &lt;p&gt;XSLT 2.0 introduces new grouping constructs.&lt;/p&gt;
&lt;/body&gt;</pre></div><p>Desired output:</p><div class="exampleInner"><pre>&lt;chapter&gt;
  &lt;section title="Introduction"&gt;
    &lt;para&gt;XSLT is used to write stylesheets.&lt;/para&gt;
    &lt;para&gt;XQuery is used to query XML databases.&lt;/para&gt;
  &lt;/section&gt; 
  &lt;section title="What is a stylesheet?"&gt;
    &lt;para&gt;A stylesheet is an XML document used to define a transformation.&lt;/para&gt;
    &lt;para&gt;Stylesheets may be written in XSLT.&lt;/para&gt;
    &lt;para&gt;XSLT 2.0 introduces new grouping constructs.&lt;/para&gt;
  &lt;/section&gt;
&lt;/chapter&gt;</pre></div><p>Solution:</p><div class="exampleInner"><pre>&lt;xsl:template match="body"&gt;
  &lt;chapter&gt;
	&lt;xsl:for-each-group select="*" group-starting-with="h2"	&gt;
	  &lt;section title="{self::h2}"&gt;
	    &lt;xsl:for-each select="current-group()[self::p]"&gt;
	      &lt;para&gt;&lt;xsl:value-of select="."/&gt;&lt;/para&gt;
	    &lt;/xsl:for-each&gt; 
	  &lt;/section&gt;
	&lt;/xsl:for-each-group&gt;
  &lt;/chapter&gt;
&lt;/xsl:template&gt;</pre></div><p>The use of <code>title="{self::h2}"</code> rather than <code>title="{.}"</code> is
 to handle the case where the first element is not an <code>h2</code> element.</p></div><p>&nbsp;</p><div class="example"><p>The next example illustrates how a group of related elements can be identified
by the last element in the group, rather than the first. Here the absence of the attribute
<code>continued="yes"</code> indicates the end of the group.</p><p>Source XML document:</p><div class="exampleInner"><pre>&lt;doc&gt;
  &lt;page continued="yes"&gt;Some text&lt;/page&gt;
  &lt;page continued="yes"&gt;More text&lt;/page&gt;    
  &lt;page&gt;Yet more text&lt;/page&gt;
  &lt;page continued="yes"&gt;Some words&lt;/page&gt;
  &lt;page continued="yes"&gt;More words&lt;/page&gt;    
  &lt;page&gt;Yet more words&lt;/page&gt;        
&lt;/doc&gt;</pre></div><p>Desired output:</p><div class="exampleInner"><pre>&lt;doc&gt;
  &lt;pageset&gt;
    &lt;page&gt;Some text&lt;/page&gt;
    &lt;page&gt;More text&lt;/page&gt;    
    &lt;page&gt;Yet more text&lt;/page&gt;
  &lt;/pageset&gt;
  &lt;pageset&gt;
    &lt;page&gt;Some words&lt;/page&gt;
    &lt;page&gt;More words&lt;/page&gt;    
    &lt;page&gt;Yet more words&lt;/page&gt;
  &lt;/pageset&gt;
&lt;/doc&gt;</pre></div><p>Solution:</p><div class="exampleInner"><pre>&lt;xsl:template match="doc"&gt;
&lt;doc&gt;
  &lt;xsl:for-each-group select="*" 
                      group-ending-with="page[not(@continued='yes')]"&gt;
    &lt;pageset&gt;
      &lt;xsl:for-each select="current-group()"&gt;
        &lt;page&gt;&lt;xsl:value-of select="."/&gt;&lt;/page&gt;
      &lt;/xsl:for-each&gt; 
    &lt;/pageset&gt;
  &lt;/xsl:for-each-group&gt;
&lt;/doc&gt;
&lt;/xsl:template&gt;</pre></div></div><p>&nbsp;</p><div class="example"><p>In the final example, the membership of a node within a group is based both on adjacency
 of the nodes in document order, and on common values. In this case, the grouping key
  is a boolean condition, true or false, so the effect is that a grouping
 establishes a maximal sequence of nodes for which the condition is true, followed by a maximal
 sequence for which it is false, and so on.</p><p>Source XML document:</p><div class="exampleInner"><pre>&lt;p&gt;Do &lt;em&gt;not&lt;/em&gt;:
    &lt;ul&gt;
    &lt;li&gt;talk,&lt;/li&gt;
    &lt;li&gt;eat, or&lt;/li&gt;
    &lt;li&gt;use your mobile telephone&lt;/li&gt;
    &lt;/ul&gt;
    while you are in the cinema.&lt;/p&gt;</pre></div><p>Desired output:</p><div class="exampleInner"><pre>&lt;p&gt;Do &lt;em&gt;not&lt;/em&gt;:&lt;/p&gt;
    &lt;ul&gt;
    &lt;li&gt;talk,&lt;/li&gt;
    &lt;li&gt;eat, or&lt;/li&gt;
    &lt;li&gt;use your mobile telephone&lt;/li&gt;
    &lt;/ul&gt;
    &lt;p&gt;while you are in the cinema.&lt;/p&gt;</pre></div><p>Solution:</p><p>This requires creating a <code>p</code> element around the maximal sequence
    of sibling nodes that does not include a <code>ul</code> or <code>ol</code> element.</p><p>This can be done by using <code>group-adjacent</code>, with a grouping key that is true
    if the element is a <code>ul</code> or <code>ol</code> element, and false otherwise:</p><div class="exampleInner"><pre>&lt;xsl:template match="p"&gt;
    &lt;xsl:for-each-group select="node()" 
            group-adjacent="self::ul or self::ol"&gt;
        &lt;xsl:choose&gt;
            &lt;xsl:when test="self::ul or self::ol"&gt;
                &lt;xsl:copy-of select="current-group()"/&gt;  
            &lt;/xsl:when&gt;
            &lt;xsl:otherwise&gt;
                &lt;p&gt;
                    &lt;xsl:copy-of select="current-group()"&gt;
                &lt;/p&gt;
            &lt;/xsl:otherwise&gt;  
        &lt;/xsl:choose&gt;
    &lt;/xsl:for-each-group&gt;
&lt;/xsl:template&gt;</pre></div></div></div></div><div class="div1">
<h2><a name="regular-expressions" id="regular-expressions"></a>15 Regular Expressions</h2><p>The core function library for XPath 2.0 defines three functions that make use of
regular expressions:</p><ul><li><p>
						<u>fn:matches</u> returns a boolean result that indicates whether or not a
string matches a given regular expression.</p></li><li><p>
						<u>fn:replace</u> takes a string as input and returns a string obtained by 
replacing all substrings that match a given regular expression with a replacement string.</p></li><li><p>
						<u>fn:tokenize</u> returns a sequence of strings formed by breaking a supplied
input string at any separator that matches a given regular expression.</p></li></ul><p>These functions are described in <a href="#FANDO">[Functions and Operators]</a>.</p><p>For more complex string processing than is possible using these functions, XSLT provides an
instruction <a href="#element-analyze-string"><code>xsl:analyze-string</code></a>, which is defined in this section.</p><p>The regular expressions used by this instruction, and the flags that control the interpretation
of these regular expressions, must conform to the syntax defined in <a href="#FANDO">[Functions and Operators]</a>, which is itself
based on the syntax defined in <a href="#XMLSCHEMA">[XML Schema]</a>.</p><p class="element-syntax"><a name="element-analyze-string"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:analyze-string<br>&nbsp;&nbsp;<b>select</b> = <var>expression</var><br>&nbsp;&nbsp;<b>regex</b> = { <var>string</var> }<br>&nbsp;&nbsp;flags = { <var>string</var> }&gt;<br>&nbsp;&nbsp;&lt;!-- Content: (<a href="#element-matching-substring">xsl:matching-substring</a>?, <a href="#element-non-matching-substring">xsl:non-matching-substring</a>?, <a href="#element-fallback">xsl:fallback</a>*) --&gt;<br>&lt;/xsl:analyze-string&gt;</code></p><p class="element-syntax"><a name="element-matching-substring"></a><code>&lt;xsl:matching-substring&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>content-constructor</var> --&gt;<br>&lt;/xsl:matching-substring&gt;</code></p><p class="element-syntax"><a name="element-non-matching-substring"></a><code>&lt;xsl:non-matching-substring&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>content-constructor</var> --&gt;<br>&lt;/xsl:non-matching-substring&gt;</code></p><p>The <a href="#element-analyze-string"><code>xsl:analyze-string</code></a> instruction takes as input a string (the value of the <code>select</code>
attribute) and a regular expression (the effective value of the <code>regex</code> attribute).</p><p>The <code>flags</code> attribute may be used to control the interpretation of the regular expression.
If the attribute is omitted, the effect is the same as supplying a zero-length string . 
The mode is set using the <code>$flags</code> argument. If this is set to <code>m</code>, 
the match operates in multiline mode. Otherwise, it operates in string mode.</p><p>The <a href="#element-analyze-string"><code>xsl:analyze-string</code></a> instruction may have two child elements: <a href="#element-matching-substring"><code>xsl:matching-substring</code></a>
and <a href="#element-non-matching-substring"><code>xsl:non-matching-substring</code></a>. Both elements are optional, and neither may appear more than once.</p><p>The <a href="#element-analyze-string"><code>xsl:analyze-string</code></a> instruction may also have zero or more <a href="#element-fallback"><code>xsl:fallback</code></a> child
elements. These are ignored by an XSLT 2.0 processor, but allow fallback behavior to be defined when the stylesheet
is used with an XSLT 1.0 processor operating in forwards-compatible mode.</p><p>This instruction is designed to process all the non-overlapping substrings of the input string that
match the regular expression supplied.</p><p>
				<a name="d5e13542"><small>[ERR115] </small></a>It is a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> if the 
<a title="effective value" href="#dt-effective-value">effective value</a> of the <code>regex</code> attribute 

does not conform to the required syntax for
regular expressions, as specified in <a href="#FANDO">[Functions and Operators]</a>, or if the effective value of the <code>flags</code> attribute 
has a value other than the values defined in <a href="#FANDO">[Functions and Operators]</a>.
The processor must signal the error. If the regular expression and/or flags are known
statically (for example, if the attributes do not contain any <a title="expression" href="#dt-expression">expressions</a> enclosed in curly braces)
then the processor may signal the error as a <a title="static error" href="#dt-static-error">static error</a>.
				
			</p><p>
				<a name="d5e13578"><small>[ERR116] </small></a>It is a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> if the 
<a title="effective value" href="#dt-effective-value">effective value</a> of the <code>regex</code> attribute 

is a regular expression that matches a zero-length string .
The processor must signal the error. If the regular expression is known
statically (for example, if the attribute does not contain any <a title="expression" href="#dt-expression">expressions</a> enclosed in curly braces)
then the processor may signal the error as a <a title="static error" href="#dt-static-error">static error</a>.
				
			</p><p>The <a href="#element-analyze-string"><code>xsl:analyze-string</code></a> instruction
 starts at the beginning of the input string and attempts to find
the first substring that matches the regular expression. If there are
several matches, the first match is defined to be the one whose starting
position comes first in the string. Having found the first match, the method proceeds to find the
second and subsequent matches by repeating the search, starting at the first
character that was not included in the previous match.</p><p>The input string is thus partitioned into a sequence of non-empty substrings, some of which 
match the regular expression, others which do not match it. This sequence of substrings is
processed using the <a href="#element-matching-substring"><code>xsl:matching-substring</code></a>
and <a href="#element-non-matching-substring"><code>xsl:non-matching-substring</code></a> child instructions. A matching substring is
processed using the <a href="#element-matching-substring"><code>xsl:matching-substring</code></a> element, a non-matching substring
using the <a href="#element-non-matching-substring"><code>xsl:non-matching-substring</code></a> element. Each of these elements
takes a content constructor as its content. If the element is absent, the effect is the same 
as if it were present with empty content. In processing each substring, the contents of the substring 
will be the context item (as a value of type <code>xs:string</code>); the position of the substring within the
sequence of matching and non-matching substrings will be the context position; and the number of
matching and non-matching substrings will be the context size.</p><p>If the input is a zero-length string , neither the <a href="#element-matching-substring"><code>xsl:matching-substring</code></a>
nor <a href="#element-non-matching-substring"><code>xsl:non-matching-substring</code></a> elements will be evaluated.</p><a name="function-regex-group" id="function-regex-group"></a><div class="proto"><code class="function">regex-group</code>(<code class="arg">$group-number</code><code class="as">&nbsp;as&nbsp;</code><code class="type">integer</code>)<code class="as">&nbsp;as&nbsp;</code><code class="return-type">string</code></div><p>While the <a href="#element-matching-substring"><code>xsl:matching-substring</code></a> instruction is active, a set of captured substrings is
available, corresponding to the parenthized sub-expressions of the regular expression. These captured
substrings are accessible using the function <a href="#function-regex-group"><b>regex-group</b></a>. This function takes an
integer argument to identify the group, and returns a string representing the captured substring. In the absence 
of a captured substring with the relevant number, it returns the zero-length string .</p><blockquote><table width="90%"><tr><td width="10%" align="left" valign="top"><b>Note:</b></td><td align="left" valign="top"><p>The function also returns a zero-length string  in the case of a group that matched a zero-length string ,
and in the case of a group that exists in the regular expression but did not match any part of the
input string.</p></td></tr></table></blockquote><p>While no <a href="#element-matching-substring"><code>xsl:matching-substring</code></a> instruction is active the <a href="#function-regex-group"><b>regex-group</b></a>
returns an empty sequence. The function also returns an empty sequence if an <a href="#element-non-matching-substring"><code>xsl:non-matching-substring</code></a> instruction
has been activated more recently than an <a href="#element-matching-substring"><code>xsl:matching-substring</code></a> instruction.</p><div class="div2">
<h3><a name="d5e13662" id="d5e13662"></a>15.1 Examples of Regular Expression Matching</h3><div class="example"><p>Problem: replace all newline characters in the &lt;abstract&gt; by &lt;br/&gt; elements:</p><p>Solution:</p><div class="exampleInner"><pre>&lt;xsl:analyze-string select="abstract" regex="\n"&gt;
  &lt;xsl:non-matching-substring&gt;
    &lt;xsl:value-of select="."/&gt;
  &lt;/xsl:non-matching-substring&gt;
  &lt;xsl:matching-substring&gt;
    &lt;br/&gt;
  &lt;/xsl:matching-substring&gt;
&lt;/xsl:for-each&gt;</pre></div></div><p>&nbsp;</p><div class="example"><p>Problem: replace all occurrences of "[...]" in the &lt;body&gt; by &lt;cite&gt;...&lt;/cite&gt;
elements:</p><p>Solution:</p><div class="exampleInner"><pre>&lt;xsl:analyze-string select="body" regex="\[(.*?)\]"&gt;
  &lt;xsl:matching-substring&gt;
    &lt;cite&gt;&lt;xsl:value-of select="regex-group(1)"/&gt;&lt;/cite&gt;
  &lt;/xsl:matching-substring&gt;
  &lt;xsl:non-matching-substring&gt;
    &lt;xsl:value-of select="."/&gt;
  &lt;/xsl:non-matching-substring&gt;
&lt;/xsl:analyze-string&gt;
</pre></div></div><p>&nbsp;</p><div class="example"><p>Problem: the input string contains a date such as "23 March 2002".
Convert it to the form 2002-03-23.</p><p>Solution (with no error handling if the input format is incorrect):</p><div class="exampleInner"><pre>&lt;xsl:variable name="months" select="('January', 'February', 'March', ...)"/&gt;

&lt;xsl:analyze-string select="$input" regex="\s*([0-9]+)\s+([A-Z](a-z)+)\s+([0-9]+)\s*"&gt;
    &lt;xsl:matching-substring&gt;
        &lt;xsl:number value="regex-group(3)" format="0001"/&gt;          
        &lt;xsl:text&gt;-&lt;/xsl:text&gt;
        &lt;xsl:number value="index-of($months, regex-group(2))" format="01"/&gt;
        &lt;xsl:text&gt;-&lt;/xsl:text&gt;
        &lt;xsl:number value="regex-group(1)" format="01"/&gt;
    &lt;/xsl:matching-substring&gt;
&lt;/xsl:analyze-string&gt;</pre></div></div></div></div><div class="div1">
<h2><a name="add-func" id="add-func"></a>16 Additional Functions</h2><p>This section describes XSLT-specific additions to the core XPath
function library.  Some of these additional functions also make use of
information specified by <a title="declaration" href="#dt-declaration">declarations</a>
in the stylesheet; this section also describes these
declarations.</p><div class="div2">
<h3><a name="document" id="document"></a>16.1 Multiple Source Documents</h3><p>The <u>fn:document</u> function, which in XSLT 1.0 was an additional
function defined in the XSLT specification, is now a core function defined in XPath 2.0: see
<a href="#FANDO">[Functions and Operators]</a>. Details of the function have therefore been removed from this specification.</p></div><div class="div2">
<h3><a name="unparsed-text" id="unparsed-text"></a>16.2 Reading Text Files</h3><a name="function-unparsed-text" id="function-unparsed-text"></a><div class="proto"><code class="function">unparsed-text</code>(<code class="arg">$href</code><code class="as">&nbsp;as&nbsp;</code><code class="type">(item)*</code>)<code class="as">&nbsp;as&nbsp;</code><code class="return-type">item*</code></div><div class="proto"><code class="function">unparsed-text</code>(<code class="arg">$href</code><code class="as">&nbsp;as&nbsp;</code><code class="type">(item)*</code>, <code class="arg">$encoding</code><code class="as">&nbsp;as&nbsp;</code><code class="type">xs:string</code>)<code class="as">&nbsp;as&nbsp;</code><code class="return-type">item*</code></div><p>The <a href="#function-unparsed-text"><b>unparsed-text</b></a>
					function reads one or more external 
					resources (for example, files) and returns
the contents of each one as a string.</p><p>The <code>$href</code> argument is treated as a sequence. Each item in the sequence, when converted
to a string, must be a URI. The URI must contain no fragment identifier, and must
identify a resource that can be read as text. If the URI is a relative URI, then:</p><ul><li><p>If the item containing the URI is a node, the relative URI is resolved relative
to the base URI of that node;</p></li><li><p>If the item containing the URI is an atomic value, the relative URI is resolved
relative to the base URI of the stylesheet element containing the <a title="expression" href="#dt-expression">expression</a> that includes
the call to the <a href="#function-unparsed-text"><b>unparsed-text</b></a> function.</p></li></ul><p>The <code>$encoding</code> argument, if present, is the name of an encoding. 
				This encoding is used to
translate the contents of the file into a string. The values for this attribute follow
the same rules as for the encoding attribute in an XML declaration. The only values which
every <a title="implementation" href="#dt-implementation">implementation</a> is obliged to recognize are
 <code>utf-8</code> and <code>utf-16</code>.</p><p>The encoding of the external resource is determined as follows:</p><ol type="1"><li><p>external encoding information, if available, otherwise</p></li><li><p>if the media type of the resource is <code>text/xml</code>, <code>application/xml</code>,
 or matches the conventions <code>text/*+xml</code> or <code>application/*+xml</code> as described in 
<a href="#RFC3023">[RFC3023]</a>, the encoding is recognized as specified in <a href="#XML">[XML]</a>, otherwise</p></li><li><p>the value of the <code>$encoding</code> argument if present, otherwise</p></li><li><p>UTF-8.</p></li></ol><blockquote><table width="90%"><tr><td width="10%" align="left" valign="top"><b>Note:</b></td><td align="left" valign="top"><p>The above rules are chosen for consistency with <a href="#XINCLUDE">[XInclude]</a>.</p></td></tr></table></blockquote><p>
					<a name="d5e13802"><small>[ERR117] </small></a>It is a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a>
if a URI 

cannot be used to retrieve a resource containing text.
The <a title="processor" href="#dt-processor">processor</a> must either signal the error,
or must recover by treating the URI
as if it referenced a resource containing a zero-length string.
					
				</p><p>
					<a name="d5e13822"><small>[ERR118] </small></a>It is a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a>
if a resource 

contains characters that are not permitted XML characters. 
The <a title="processor" href="#dt-processor">processor</a> must either signal the error,
or must recover in a <a title="implementation-defined" href="#dt-implementation-defined">implementation-defined</a> way; one possible outcome is that
the <a title="processor" href="#dt-processor">processor</a> will produce an output file that is
not well-formed XML.
					
				</p><p>
					<a name="d5e13853"><small>[ERR119] </small></a>It is a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a>
if a resource 

contains bytes that cannot be decoded into permitted XML characters
using the specified encoding. This includes the case where the
 <a title="processor" href="#dt-processor">processor</a> does not support
the requested encoding.
The <a title="processor" href="#dt-processor">processor</a> must signal the error.
					
				</p><p>
					<a name="d5e13876"><small>[ERR120] </small></a>It is a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a>
if the second argument of the <a href="#function-unparsed-text"><b>unparsed-text</b></a> function is omitted and the
 <a title="processor" href="#dt-processor">processor</a> cannot infer the encoding using
external information.The <a title="processor" href="#dt-processor">processor</a> must signal the error.
					
				</p><p>The result is a sequence of strings, containing one string for each URI in the
sequence supplied as the first argument; each string holds the text of the resource
retrieved using the URI in the corresponding position of the sequence.</p><blockquote><table width="90%"><tr><td width="10%" align="left" valign="top"><b>Note:</b></td><td align="left" valign="top"><p>If the text file contains characters such as <code>&lt;</code> and <code>&amp;</code>, 
these will typically be output as <code>&amp;lt;</code> and <code>&amp;amp;</code> when the string is
written to the result tree and serialized as XML or HTML. If these characters actually
represent markup (for example, if the text file contains HTML), then the stylesheet can 
attempt to write them as markup to the output file using the <code>disable-output-escaping</code>
attribute of the <a href="#element-value-of"><code>xsl:value-of</code></a> instruction (see <a href="#disable-output-escaping"><b>20.5 Disabling Output Escaping</b></a>. 
Note, however, that implementations are not required to support this feature.</p></td></tr></table></blockquote><div class="example"><p>The following example attempts to read an HTML file and copy it, as HTML, to the serialized
output file:</p><div class="exampleInner"><pre>&lt;xsl:output method="html"/&gt;

&lt;xsl:template match="/"&gt;
  &lt;xsl:value-of select="unparsed-text('header.html', 'iso-8859-1')"
                disable-output-escaping="yes"/&gt;
  &lt;xsl:apply-templates/&gt;
  &lt;xsl:value-of select="unparsed-text('footer.html', 'iso-8859-1')"
                disable-output-escaping="yes"/&gt;
&lt;/xsl:template&gt;
</pre></div></div></div><div class="div2">
<h3><a name="key" id="key"></a>16.3 Keys</h3><p>Keys provide a way to work with documents that contain an implicit
cross-reference structure. They make it easier to locate the nodes within a document
that have a given value for a given attribute or child element, and they provide
a hint to the implementation that certain access paths in the document need to
be efficient.</p><div class="div3">
<h4><a name="d5e13929" id="d5e13929"></a>16.3.1 The <a href="#element-key"><code>xsl:key</code></a> Declaration</h4><p class="element-syntax"><a name="element-key"></a><code>&lt;!-- Category: declaration --&gt;<br>&lt;xsl:key<br>&nbsp;&nbsp;<b>name</b> = <var>qname</var><br>&nbsp;&nbsp;<b>match</b> = <var>pattern</var><br>&nbsp;&nbsp;<b>use</b> = <var>expression</var><br>&nbsp;&nbsp;as = <var>qname</var><br>&nbsp;&nbsp;collation = <var>uri</var>&nbsp;/&gt;</code></p><p>The <a href="#element-key"><code>xsl:key</code></a>
						<a title="declaration" href="#dt-declaration">declaration</a> 
is used to declare <a title="" href="#key">keys</a>.  The
<code>name</code> attribute specifies the name of the key.  The value
of the <code>name</code> attribute is a <a title="QName" href="#dt-qname">QName</a>, which is expanded as described
in <a href="#qname"><b>5.1 Qualified Names</b></a>. The <code>match</code> attribute is a <a href="#NT-Pattern">Pattern</a>; an <a href="#element-key"><code>xsl:key</code></a> element 
applies to all nodes that match the pattern
specified in the <code>match</code> attribute.  The <code>use</code> attribute is
an <a title="expression" href="#dt-expression">expression</a> specifying the
values of the key; the expression will be evaluated with the node that
matches the pattern as the context node.</p><p>The presence of an <a href="#element-key"><code>xsl:key</code></a> declaration makes it
easy to find a node that matches the <code>match</code> pattern if any of the values
of the <code>use</code> expression (when applied to that node) are known. It also provides
a hint to the implementation that access to the nodes by means of these values needs
to be efficient (many implementations are likely to
construct an index or hash table to achieve this.)
Note that the <code>use</code> expression in general returns a sequence of values, and any one
of these may be used to locate the node.</p><p>The <code>as</code> attribute defines the required type of the result
of the <code>use</code> expression, and it also defines the rules that determine whether two
key values are considered equal. The default value is <code>xs:string*</code>, which means that
the result of evaluating the expression is treated as a sequence of strings, by invoking
the <em>atomization</em> procedure defined in <a href="#XPATH20">[XPath 2.0]</a>. 
In general, the result of evaluating the <code>use</code> expression
is converted to the required type, 
by invoking the <a title="argument conversion rules" href="#dt-argument-conversion-rules">argument conversion rules</a>.
 The type
must be either a built-in type defined in <a href="#XMLSCHEMA">[XML Schema]</a> (Part 2),
or an atomic type defined in a schema imported using an <a href="#element-import-schema"><code>xsl:import-schema</code></a> declaration,
with an optional occurrence indicator.</p><p>The <code>collation</code> attribute is used only when the
item type of the required type is <code>xs:string</code> or a type
derived by restriction from <code>xs:string</code>, 
and it identifies a <a title="collation" href="#dt-collation">collation</a> that is used to decide
 whether two strings are equal for the purposes of key matching. Specifically, two values <code>$a</code>
 and <code>$b</code> are considered equal if the result of the function call
  <code>fn:compare($a, $b, $collation)</code> is zero. 
  In the absence of a <code>collation</code> attribute, the default collation is used.</p><p>It is possible to have:</p><ul><li><p>multiple <a href="#element-key"><code>xsl:key</code></a> declarations with the same name;</p></li><li><p>a node that matches the <code>match</code> patterns of several different
							 <a href="#element-key"><code>xsl:key</code></a> declarations, whether these have the
							 same key name or different key names;</p></li><li><p>a node that returns more than one value from its <code>use</code> expression;</p></li><li><p>a key value that identifies more than one node (the key values for different nodes do not need
to be unique).</p></li></ul><p><a name="dt-key" id="dt-key" title="key"></a>A <b>key</b> is defined as
					a set of <a href="#element-key"><code>xsl:key</code></a> declarations in the stylesheet that share the same name.</p><p>An <a href="#element-key"><code>xsl:key</code></a> declaration with higher 
<a title="import precedence" href="#dt-import-precedence">import precedence</a> does
not override another of lower import precedence; all the <a href="#element-key"><code>xsl:key</code></a> declarations
in the stylesheet are effective regardless of their import precedence.</p><p>
						<a name="d5e14132"><small>[ERR121] </small></a>It is a static error if there are several <a href="#element-key"><code>xsl:key</code></a> declarations
in the stylesheet with the same key name and different  types, or if the  type is specified
in one of these declarations and omitted in another. The key names and  types are the same
if their expanded names match.</p><p>
						<a name="d5e14149"><small>[ERR122] </small></a>It is a static error if there are several <a href="#element-key"><code>xsl:key</code></a> declarations
in the stylesheet with the same key name and different collation sequences, or if the collation is specified
in one of these declarations and omitted in another. The collation names are the same if their
URIs consist of the same sequence of Unicode code-points.</p><p>
						<a name="d5e14157"><small>[ERR123] </small></a>It is a static error if the value of the <code>as</code> attribute
 is not an atomic type (optionally
followed by an occurrence count).
					</p><p>
						<a name="d5e14171"><small>[ERR124] </small></a>It is a static error if a value is specified for the <code>collation</code> attribute

unless the <code>as</code> attribute is defaulted or set to <code>xs:string</code>.
					</p><p>
						<a name="d5e14191"><small>[ERR125] </small></a>It is a dynamic error if the result of evaluating the <code>use</code> expression
,
for any node that matches the pattern specified in the <code>match</code> attribute, cannot be converted
to the  type specified by the <code>as</code> attribute.
The processor may signal the error, or may recover by ignoring the existence of the value
that cannot be converted.
						
					</p></div><div class="div3">
<h4><a name="keys" id="keys"></a>16.3.2 The <a href="#function-key"><b>key</b></a> Function</h4><a name="function-key" id="function-key"></a><div class="proto"><code class="function">key</code>(<code class="arg">$key-name</code><code class="as">&nbsp;as&nbsp;</code><code class="type">xs:string</code>, <code class="arg">$key-value</code><code class="as">&nbsp;as&nbsp;</code><code class="type">(item)+</code>)<code class="as">&nbsp;as&nbsp;</code><code class="return-type">node*</code></div><p>The <a href="#function-key"><b>key</b></a> function does for keys what the
<u>fn:id</u> function does for IDs.</p><p>The <code>$key-name</code> argument
specifies the name of the <a title="key" href="#dt-key">key</a>. The value of the argument must be a
<a title="QName" href="#dt-qname">QName</a>, which is expanded as
described in <a href="#qname"><b>5.1 Qualified Names</b></a>. <a name="d5e14248"><small>[ERR126] </small></a>It is a 
<a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> if the value 
 is
not a valid QName, or if there is no
 namespace declaration in scope for the prefix of the QName, or if the
 name obtained by expanding the QName is not the same as the expanded
 name of any <a href="#element-key"><code>xsl:key</code></a> declaration in the stylesheet. The <a title="processor" href="#dt-processor">processor</a> must
 signal these errors.
						
					</p><div><blockquote><p><b><a href="#issue-qname-for-key-etc">Issue 133 (qname-for-key-etc)</a>: </b>Some XSLT functions such as <a href="#function-key"><b>key</b></a> take an argument whose value is 
    a string containing a lexical QName. Should we allow this argument to have 
    type <code>xs:QName</code>?</p></blockquote></div><p>The <code>$key-value</code> argument to the
<a href="#function-key"><b>key</b></a> function is considered as a sequence. The set of requested
key values is formed by casting each item in the supplied
value of the argument to the type specified in the as attribute of the key declaration. 
In general the result
is a sequence of atomic values, each of which is considered as a requested key value.
The result of the function is
a sequence of nodes, in document order and with duplicates removed, 
comprising those nodes in the
same document as the context node that
are matched by an <a href="#element-key"><code>xsl:key</code></a> declaration whose name is the same as the
supplied key name, and whose value is equal to one of these requested key values,
under the rules appropriate to the as and <a title="collation" href="#dt-collation">collation</a>
attributes of in the key declaration.</p><p>More formally, if the result of evaluating the <code>$key-value</code> argument of 
the <a href="#function-key"><b>key</b></a> function
is denoted by <var>$V</var>, the result returned by the <a href="#function-key"><b>key</b></a> 
function is the union of the node sequences selected by the <a title="expression" href="#dt-expression">expression</a></p><div class="exampleInner"><pre>//(<em>MATCH</em>)/self::node()
   [some $k in (for $kk in <em>USE</em> return cast as <em>TYPE</em> ($kk)),
         $v in (for $vv in $V return cast as <em>TYPE</em> ($vv))
         satisfies key-equal($k, $v)]</pre></div><p>applied to all <a href="#element-key"><code>xsl:key</code></a> declarations whose <code>name</code> matches the
name given as the first argument to the <a href="#function-key"><b>key</b></a> function,
where <var>MATCH</var> is the pattern given in the <code>match</code> attribute of the
<a href="#element-key"><code>xsl:key</code></a> declaration, <var>USE</var> is the expression 
given in its <code>use</code> attribute, and <var>TYPE</var> is the expression 
given in its <code>as</code> attribute, 
or <code>xs:string</code> if the attribute is omitted. 
The values of the <code>match</code> and
<code>use</code> and <code>as</code> attributes are textually substituted
 into the above expression.</p><p>In the above expression, the internal function <code>key-equal</code> is defined
as follows:</p><ul><li><p>If <var>TYPE</var> is <code>xs:string</code> or a type derived from <code>xs:string</code> by restriction,
then <code>key-equal($k, $v)</code> is true if and only if 
<code>fn:compare($k, $v, 'COLLATION') eq 0</code>, where <var>COLLATION</var> is the
collation specified in the <code>collation</code> attribute of the key declaration if present, or
the default collation otherwise.</p></li><li><p>If <var>TYPE</var> is <code>xs:float</code> or <code>xs:double</code>, or a type derived from
 <code>xs:float</code> or <code>xs:double</code> by restriction, then <code>key-equal($k, $v)</code> is true
 if <code>$k eq $v</code> or if <code>xf:string($k) eq 'NaN' and xf:string($v) eq 'NaN'</code>; otherwise
 if is false. That is, the values match if they are equal, or if both are NaN.</p></li><li><p>Otherwise <code>key-equal($k, $v)</code> is true if and only if <code>$k eq $v</code>.</p></li></ul><blockquote><table width="90%"><tr><td width="10%" align="left" valign="top"><b>Note:</b></td><td align="left" valign="top"><p>The reason that <code>/self::node()</code> appears in the above expression
is to ensure that any calls of <code>fn:position()</code> or <code>fn:last()</code> within
the <var>USE</var> expression evaluate to 1 (one). This is necessary to retain 
compatibility with the XSLT 1.0 specification.</p></td></tr></table></blockquote><div class="example"><p>For example, given a declaration</p><div class="exampleInner"><pre>&lt;xsl:key name="idkey" match="div" use="@id"/&gt;</pre></div><p>an expression <code>key("idkey",@ref)</code> will return the same
nodes as <code>fn:id(@ref)</code>, assuming that the only ID attribute
declared in the XML source document is:</p><div class="exampleInner"><pre>&lt;!ATTLIST div id ID #IMPLIED&gt;</pre></div><p>and that the <code>ref</code> attribute of the context node
contains no whitespace.</p><p>Suppose a document describing a function library uses a
<code>prototype</code> element to define functions</p><div class="exampleInner"><pre>&lt;prototype name="key" return-type="node-set"&gt;
&lt;arg type="string"/&gt;
&lt;arg type="object"/&gt;
&lt;/prototype&gt;</pre></div><p>and a <code>function</code> element to refer to function names</p><div class="exampleInner"><pre>&lt;function&gt;key&lt;/function&gt;</pre></div><p>Then the stylesheet could generate hyperlinks between the
references and definitions as follows:</p><div class="exampleInner"><pre>&lt;xsl:key name="func" match="prototype" use="@name"/&gt;

&lt;xsl:template match="function"&gt;
&lt;b&gt;
  &lt;a href="#{generate-id(key('func',.))}"&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/a&gt;
&lt;/b&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="prototype"&gt;
&lt;p&gt;&lt;a name="{generate-id()}"&gt;
&lt;b&gt;Function: &lt;/b&gt;
...
&lt;/a&gt;&lt;/p&gt;
&lt;/xsl:template&gt;</pre></div></div><p>The <a href="#function-key"><b>key</b></a> always
returns nodes that are in the same document as the context node; to
retrieve a node from any other document, it is necessary first to
change the context node.</p><div class="example"><p>For example, suppose a document contains bibliographic references in the
form <code>&lt;bibref&gt;XSLT&lt;/bibref&gt;</code>, and there is a
separate XML document <code>bib.xml</code> containing a bibliographic
database with entries in the form:</p><div class="exampleInner"><pre>&lt;entry name="XSLT"&gt;...&lt;/entry&gt;</pre></div><p>Then the stylesheet could use the following to transform the
<code>bibref</code> elements:</p><div class="exampleInner"><pre>&lt;xsl:key name="bib" match="entry" use="@name"/&gt;

&lt;xsl:template match="bibref"&gt;
  &lt;xsl:variable name="name" select="."/&gt;
  &lt;xsl:apply-templates select="document('bib.xml')/key('bib',$name)"/&gt;
&lt;/xsl:template&gt;</pre></div><blockquote><table width="90%"><tr><td width="10%" align="left" valign="top"><b>Note:</b></td><td align="left" valign="top"><p>This relies on the ability in XPath 2.0 to have a function call
on the right-hand side of the <code>/</code> operator in a path expression.</p></td></tr></table></blockquote></div><p><a name="d5e14524"><small>[ERR127] </small></a>It is a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a>
					to call the <a href="#function-key"><b>key</b></a> function if there is no <a title="context node" href="#dt-context-node">context node</a>.
					The <a title="processor" href="#dt-processor">processor</a> must signal the error.</p></div></div><div class="div2">
<h3><a name="format-number" id="format-number"></a>16.4 Number Formatting</h3><a name="function-format-number" id="function-format-number"></a><div class="proto"><code class="function">format-number</code>(<code class="arg">$value</code><code class="as">&nbsp;as&nbsp;</code><code class="type">xs:double</code>, <code class="arg">$picture</code><code class="as">&nbsp;as&nbsp;</code><code class="type">xs:string</code>)<code class="as">&nbsp;as&nbsp;</code><code class="return-type">xs:string</code></div><div class="proto"><table border="0" cellpadding="0" cellspacing="0"><tr><td valign="baseline" rowspan="3"><code class="function">format-number</code>(</td><td valign="baseline"><code class="arg">$value</code></td><td valign="baseline"><code class="as">&nbsp;as&nbsp;</code><code class="type">xs:double</code>,</td></tr><tr><td valign="baseline"><code class="arg">$picture</code></td><td valign="baseline"><code class="as">&nbsp;as&nbsp;</code><code class="type">xs:string</code>,</td></tr><tr><td valign="baseline"><code class="arg">$decimal-format-name</code></td><td valign="baseline"><code class="as">&nbsp;as&nbsp;</code><code class="type">xs:string</code>)<code class="as">&nbsp;as&nbsp;</code><code class="return-type">xs:string</code></td></tr></table></div><p>The <a href="#function-format-number"><b>format-number</b></a> function formats
<code>$value</code> as a string using the <a title="picture string" href="#dt-picture-string">picture string</a>
 specified by the
<code>$picture</code> argument and the decimal-format named by the <code>$decimal-format-name</code> argument, or
the default decimal-format, if there is no <code>$decimal-format-name</code> argument.

The value of <code>$decimal-format-name</code> must be a <a title="QName" href="#dt-qname">QName</a>, which is expanded as
described in <a href="#qname"><b>5.1 Qualified Names</b></a>. The result of the function is the formatted string
representation of the supplied number.</p><p>
					<a name="d5e14589"><small>[ERR128] </small></a>It is a 
<a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> if the stylesheet
does not contain a declaration of the decimal-format with the 
<a title="expanded-QName" href="#dt-expanded-qname">expanded-QName</a> specified as the
<code>$decimal-format-name</code> argument.
The <a title="processor" href="#dt-processor">processor</a> must either signal the error,
 or must recover by ignoring the <code>$decimal-format-name</code> argument.
					
				</p><div class="div3">
<h4><a name="d5e14618" id="d5e14618"></a>16.4.1 Defining a Decimal Format</h4><p class="element-syntax"><a name="element-decimal-format"></a><code>&lt;!-- Category: declaration --&gt;<br>&lt;xsl:decimal-format<br>&nbsp;&nbsp;name = <var>qname</var><br>&nbsp;&nbsp;decimal-separator = <var>char</var><br>&nbsp;&nbsp;grouping-separator = <var>char</var><br>&nbsp;&nbsp;infinity = <var>string</var><br>&nbsp;&nbsp;minus-sign = <var>char</var><br>&nbsp;&nbsp;NaN = <var>string</var><br>&nbsp;&nbsp;percent = <var>char</var><br>&nbsp;&nbsp;per-mille = <var>char</var><br>&nbsp;&nbsp;zero-digit = <var>char</var><br>&nbsp;&nbsp;digit = <var>char</var><br>&nbsp;&nbsp;pattern-separator = <var>char</var>&nbsp;/&gt;</code></p><p>
						<a name="dt-decimal-format" id="dt-decimal-format" title="decimal-format"></a>The <a href="#element-decimal-format"><code>xsl:decimal-format</code></a> 
element declares a
decimal-format, which controls the interpretation of a <a title="picture string" href="#dt-picture-string">picture string</a>
used by the <a href="#function-format-number"><b>format-number</b></a> function.  If there is
a <code>name</code> attribute, then the element declares a named
decimal-format; otherwise, it declares the default decimal-format.
The value of the <code>name</code> attribute is a <a title="QName" href="#dt-qname">QName</a>, which is expanded as described
in <a href="#qname"><b>5.1 Qualified Names</b></a>.  
<a name="d5e14674"><small>[ERR129] </small></a>It is a <a title="static error" href="#dt-static-error">static error</a>
 to declare either the
default decimal-format or a decimal-format with a given name more than
once (even with different <a title="import precedence" href="#dt-import-precedence">import
precedence</a>), unless it is declared every time with the same
value for all attributes (taking into account any default values).
If a stylesheet does not contain a declaration of
the default decimal format, a declaration equivalent to
an <a href="#element-decimal-format"><code>xsl:decimal-format</code></a> element with no attributes
is implied.</p><p>The attributes of the <a href="#element-decimal-format"><code>xsl:decimal-format</code></a>
declaration establish values for a number of variables used as input to
the algorithm followed by the <a href="#function-format-number"><b>format-number</b></a> function.
An outline of the purpose of each attribute is given below; however, the definitive
explanations are given later, as part of the description of this algorithm.</p><p>The following attributes both control the interpretation of
characters in the <a title="picture string" href="#dt-picture-string">picture string</a> supplied to the <a href="#function-format-number"><b>format-number</b></a>
function, and also specify characters that may
appear in the result of formatting the number. In each case the value must
be a single character.</p><ul><li><p>
								<code>decimal-separator</code> specifies the character used
for the <var>decimal-separator-sign</var>; the default value is the period character
(<code>.</code>)</p></li><li><p>
								<code>grouping-separator</code> specifies the character used
for the <var>grouping-sign</var>, which is typically used as a thousands
 separator; the default value is the
comma character (<code>,</code>)</p></li><li><p>
								<code>percent</code> specifies the character used for the
<var>percent-sign</var>; the default value is the percent character
(<code>%</code>)</p></li><li><p>
								<code>per-mille</code> specifies the character used for the
<var>per-mille-sign</var>; the default value is the Unicode per-mille character
(#x2030)</p></li><li><p>
								<code>zero-digit</code> specifies the character used for the
<var>digit-zero-sign</var>; the default value is the digit zero
(<code>0</code>). This character must be a digit (category Nd in 
the Unicode property database), and it must have the numeric value zero.
This attribute implicitly allocates the corresponding set of Unicode
digit characters to represent the values 0 to 9.</p></li></ul><p>The following attributes control the interpretation of characters
in the <a title="picture string" href="#dt-picture-string">picture string</a> supplied to the <a href="#function-format-number"><b>format-number</b></a>
function. In each case the value must be a single character.</p><ul><li><p>
								<code>digit</code> specifies the character used for the <var>digit-sign</var>
in the <a title="picture string" href="#dt-picture-string">picture string</a>; the default value is the number sign character
(<code>#</code>)</p></li><li><p>
								<code>pattern-separator</code> specifies the character used
for the <var>pattern-separator-sign</var>, which
separates positive and negative sub-pictures in a <a title="picture string" href="#dt-picture-string">picture string</a>; the
default value is the semi-colon character (<code>;</code>)</p></li></ul><p>The following attributes specify characters or strings that may
appear in the result of formatting the number:</p><ul><li><p>
								<code>infinity</code> specifies the string used for the
<var>infinity-symbol</var>; the default value is the string
<code>Infinity</code>
							</p></li><li><p>
								<code>NaN</code> specifies the string used for the
<var>NaN-symbol</var>, which is used to represent the value NaN (not-a-number);
the default value is the string <code>NaN</code>
							</p></li><li><p>
								<code>minus-sign</code> specifies the character used for the
<var>minus-symbol</var>; the default value is the hyphen-minus character
(<code>-</code>, #x2D). The value must be a single character.</p></li></ul><p>
						<a name="d5e14840"><small>[ERR130] </small></a>It is a <a title="static error" href="#dt-static-error">static error</a> if,
 for any named or unnamed decimal format, the variables
representing characters used in a <a title="picture string" href="#dt-picture-string">picture string</a>
do not each have distinct values. These variables are <var>decimal-separator-sign</var>,
<var>grouping-sign</var>, <var>percent-sign</var>, <var>per-mille-sign</var>,
<var>digit-zero-sign</var>, <var>digit-sign</var>, and <var>pattern-separator-sign</var>.

					</p></div><div class="div3">
<h4><a name="d5e14870" id="d5e14870"></a>16.4.2 Processing the Picture String</h4><p>The behavior of the <a href="#function-format-number"><b>format-number</b></a> function
is described here by means of an algorithm; an implementation may
use any algorithm that delivers the same result.</p><p>
						<a name="dt-picture-string" id="dt-picture-string" title="picture string"></a>The formatting of a 
number is controlled by a <b>picture string</b>. The
picture string is a sequence of characters, in which the characters
assigned to the variables <var>decimal-separator-sign</var>, <var>grouping-sign</var>,

							<var>zero-digit-sign</var>,
<var>digit-sign</var> and <var>pattern-separator-sign</var> are classified as
active characters, and all other characters 
(including the <var>percent-sign</var> and <var>per-mille-sign</var>)
are classified as passive characters.
					</p><p>Formatting is centered around the 
<var>decimal-separator-sign</var>, which can have a <var>whole-part</var> before and 
<var>fractional-part</var> after. The passive characters in the 
pattern string define a <var>prefix</var> and <var>suffix</var> portion.</p><p>The evaluation of the <a href="#function-format-number"><b>format-number</b></a> function
is described below in two phases, an anaysis phase and a formatting
phase. The analysis phase takes as its inputs the <a title="picture string" href="#dt-picture-string">picture string</a>
and the variables derived from the relevant <a href="#element-decimal-format"><code>xsl:decimal-format</code></a> declaration,
and produces as its output a number of variables with defined values.
The formatting phase takes as its inputs the number to be formatted
and the variables produced by the analysis phase, and produces as
its output a string containing a formatted representation of the number.</p><blockquote><table width="90%"><tr><td width="10%" align="left" valign="top"><b>Note:</b></td><td align="left" valign="top"><p>Numbers will always be formatted with the most significant
 digit on the left.</p></td></tr></table></blockquote></div><div class="div3">
<h4><a name="d5e14953" id="d5e14953"></a>16.4.3 Analysing the Picture String</h4><p>This phase of the algorithm analyses 
the <a title="picture string" href="#dt-picture-string">picture string</a> and the attribute settings of
the <a href="#element-decimal-format"><code>xsl:decimal-format</code></a> declaration, and has the effect
of setting the values of various variables, which are used in the
subsequent formatting phase. These variables are listed below.
Each is shown with its initial setting and its data type.

					</p><p>
						<a name="d5e14969"><small>[ERR131] </small></a>The <a title="picture string" href="#dt-picture-string">picture string</a>
							
must  conform to the following rules.
It is a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> if the picture string
does not satisfy these rules. The <a title="processor" href="#dt-processor">processor</a> must either signal the error,
or must recover by ignoring those characters in the
supplied picture string that make the picture string invalid. If a valid picture
string cannot be constructed, the <a title="processor" href="#dt-processor">processor</a> may recover by returning
the string obtained by applying the <u>fn:string</u> function to the supplied
number.
						
					</p><p>Note that in these
rules "preceded" and "followed" refer to characters anywhere in the string, they
are not to be read as "immediately preceded" and "immediately followed".</p><ul><li><p>A picture-string consists either of a sub-picture, or of
two sub-pictures separated by a <var>pattern-separator-sign</var>. A sub-picture
must not contain a <var>pattern-separator-sign</var>. If the picture-string contains two
sub-pictures, the first is used for positive values and the second for negative values.</p></li><li><p>A sub-picture must not contain more than one <var>decimal-separator-sign</var>.</p></li><li><p>A sub-picture must not contain more than one <var>percent-sign</var> or
 <var>per-mille-sign</var>, and it must not contain one of each.</p></li><li><p>A sub-picture must contain at least one <var>digit-sign</var> or <var>zero-digit-sign</var>.</p></li><li><p>A sub-picture must not contain a passive character that is preceded by
a <var>zero-digit-sign</var> or <var>digit-sign</var> and that is followed by
another <var>zero-digit-sign</var> or <var>digit-sign</var>.</p></li><li><p>A sub-picture must not contain a <var>grouping-separator-sign</var> adjacent to a
<var>decimal-separator-sign</var>.</p></li><li><p>A sub-picture must not contain a <var>digit-sign</var> that is preceded by
a <var>decimal-separator-sign</var> and followed by a <var>zero-digit-sign</var>, or one that is
preceded by a <var>zero-digit-sign</var> and followed by a <var>decimal-separator-sign</var>.</p></li></ul><p>The following variables apply to the picture string as a whole:</p><ul><li><p>
								<var>digit-range-mapping</var> (boolean, initially false): Indicates
 whether the standard ASCII digits (0-9) have been replaced by another set of digits.
 This property applies to the picture string as a whole, and is derived from the 
 <a href="#element-decimal-format"><code>xsl:decimal-format</code></a> declaration rather than the pattern string.
 If <var>zero-digit</var> is not "0", set <var>digit-range-mapping</var>
to true and populate a mapping table for digits 0-9
(output characters for digits 1-9 must bear the same 
relationship to Basic Latin digits 1-9 as the requested
<var>zero-digit</var> bears to Basic Latin digit 0).</p></li><li><p>
								<var>two-sub-pictures</var> (boolean initially false): Indicates whether separate
 positive and negative sub-pictures exist. It is true if the <a title="picture string" href="#dt-picture-string">picture string</a> includes a
 <var>pattern-separator-sign</var>. </p></li></ul><p>The following variables each have two instances, one that
applies to positive numbers, and one that applies to negative numbers:</p><ul><li><p>
								<var>integer-mode</var> (boolean, initially true): Indicates whether the 
pattern lacks a decimal-separator and hence forces output as an integer.</p></li><li><p>
								<var>is-percent</var> (boolean, initially false). Indicates
whether the number is to be processed as a percentage.</p></li><li><p>
								<var>is-per-mille</var> (boolean, initially false). Indicates
whether the number is to be processed as a per-mille.</p></li><li><p>
								<var>maximum-fractional-part-size</var> (integer, initially zero): 
Indicates the largest number of digits possible for the
<var>fractional-part</var>.</p></li><li><p>
								<var>maximum-whole-part-size</var> (integer, initially one).
Indicates the largest number of digits possible for the <var>whole-part</var>.</p></li><li><p>
								<var>minimum-fractional-part-size</var> (integer, initially zero).
Indicates the smallest number of digits possible 
for the <var>fractional-part</var>.</p></li><li><p>
								<var>minimum-whole-part-size</var> (integer, initially one).
Indicates the smallest number of digits possible for the whole
 part.</p></li><li><p>
								<var>overflow-threshold</var> (integer, initially 10).
The value is always a power of 10; it indicates the smallest 
number that is too large to fit the <var>whole-part</var>.</p></li><li><p>
								<var>prefix</var> (string, initially empty). Indicates
the string of passive characters to appear before the number.</p></li><li><p>
								<var>suffix</var> (string, initially empty). Indicates the string
 of passive characters to appear after the number.</p></li><li><p>
								<var>whole-part-grouping-positions</var> (sequence of integers, initially empty):
Indicates the positions at which grouping separators will be output in the <var>whole-part</var>.</p></li></ul><p>These variables are set using the following algorithm. If there are
two sub-pictures, then the algorithm is applied to one sub-picture to obtain the values
that apply to positive numbers, and to the other to obtain the values that apply
to negative numbers. If there is only one sub-picture, then the values for both cases
are derived from this sub-picture.</p><ol type="1"><li><p>Look for a <var>decimal-separator-sign</var> within the sub-picture.
If one is found, set <var>integer-mode</var> to false. 
If none is found, leave <var>integer-mode</var> 
set to true; add an implicit <var>decimal-separator-sign</var>
just after the last (least significant) <var>digit-sign</var> or 
<var>zero-digit-sign</var> in the sub-picture; and leave the
 <var>minimum-fractional-part-size</var> 
and <var>maximum-fractional-part-size</var> set to zero. </p></li><li><p>From the <var>decimal-separator-sign</var>, step through characters 
in order of increasing significance (that is, to the left) looking 
for occurrences of the <var>grouping-separator-sign</var>. 
								When one is found, 
append an integer to the <var>whole-part-grouping-positions</var> list; the value of
this integer is the number of <var>digit-sign</var> and <var>zero-digit-sign</var> 
characters between the <var>grouping-separator-sign</var> and the
<var>decimal-separator-sign</var>.
							</p></li><li><p>If there is a <var>digit-sign</var> 
immediately to the left of the
 (actual or implied) <var>decimal-separator-sign</var>, set the 
 <var>minimum-whole-part-size</var> to zero (unless <var>integer-mode</var> is 
 true, in which case leave it at one) and step 
 through the characters in order of increasing 
 significance (that is, to the left) looking for a 
 passive character. If there is a <var>zero-digit-sign</var> 
 immediately to the left of the <var>decimal-separator</var>, 
 step through the characters in order of 
 increasing significance (that is, to the left) 
 looking for either a <var>digit-sign</var> or 
 passive character. As soon as a character 
 other than a <var>zero-digit-sign</var> or <var>grouping-separator-sign</var> 
 is found, set <var>minimum-whole-part-size</var> to 
 the number of <var>zero-digit-sign</var>s found on this side 
 of the <var>decimal-separator</var>. When a passive 
 character is encountered, set the 
 <var>maximum-whole-part-size</var> to the total number of 
 <var>digit-sign</var> and <var>zero-digit-sign</var> characters found on this 
 side of the <var>decimal-separator</var>. Set  
 <var>overflow-threshold</var> to  
 ten raised to the power of <var>maximum-whole-part-size</var>. </p></li><li><p>Take all characters from the 
beginning of the sub-picture 
to the just-encountered passive character as the <var>prefix</var>. 
If <var>two-sub-pictures</var> is false, set the <var>prefix</var> 
for negative numbers by copying the <var>prefix</var> for positive numbers (if any) 
and then appending the <var>minus-sign</var> 
character (that is, making it the character that will be adjacent to 
the following number).</p></li><li><p>From the (actual) <var>decimal-separator-sign</var>, step through characters 
in order of decreasing significance (that is, to the right) looking for 
an occurrence of the <var>grouping-separator-sign</var>. 
								When one is found, 
append an integer to the <var>fractional-part-grouping-positions</var> list; the value of
this integer is the number of <var>digit-sign</var> and <var>zero-digit-sign</var> 
characters between the <var>grouping-separator-sign</var> and the
<var>decimal-separator-sign</var>.
							</p></li><li><p>If there is a <var>digit-sign</var> adjacent to the <var>decimal-separator-sign</var> 
on the fractional side, leave the <var>minimum-fractional-part-size</var> set 
to zero and step through the characters in order of decreasing significance 
(that is, to the right) looking for a passive character . If there is a <var>zero-digit-sign</var> adjacent to the 
<var>decimal-separator-sign</var>, step through the characters in order of decreasing 
significance (that is, to the right) looking for an either a <var>digit-sign</var>
								or a
passive character. 
As soon as a character other than <var>zero-digit-sign</var> or <var>grouping-separator-sign</var> 
is found, set <var>minimum-fractional-part-size</var> to the number of 
<var>zero-digit-sign</var>s found on this side of the <var>decimal-separator-sign</var>. When 
a passive character is encountered, 
set <var>maximum-fractional-part-size</var> to the total number of 
<var>digit-sign</var> and <var>zero-digit-sign</var> characters found on this side of the 
<var>decimal-separator</var>. </p></li><li><p>If a <var>percent-sign</var>
								 is present anywhere in the sub-picture,
 set <var>is-percent</var> to true. 
If a <var>per-mille-sign</var>
								 is present anywhere in the sub-picture, 
set <var>is-per-mille</var> to true. </p></li><li><p>Take all characters from the first-encountered passive 
character on the fractional side

to the end of the format string as the <var>suffix</var>. 

							</p></li></ol><blockquote><table width="90%"><tr><td width="10%" align="left" valign="top"><b>Note:</b></td><td align="left" valign="top"><p>If there is only one sub-picture, then all variables
for positive numbers and negative numbers will be the same, except for  
<var>prefix</var>: the prefix for negative numbers will have the <var>minus-sign</var>
character appended.</p></td></tr></table></blockquote></div><div class="div3">
<h4><a name="d5e15538" id="d5e15538"></a>16.4.4 Formatting the Number</h4><p>This algorithm describes the second phase of processing of the
<a href="#function-format-number"><b>format-number</b></a> function. It takes as input a number to be formatted
(referred to as the <em>input number</em>), and the variables set up by
analysing the <a href="#element-decimal-format"><code>xsl:decimal-format</code></a> declaration and the
<a title="picture string" href="#dt-picture-string">picture string</a>, as described above.
 The result of this algorithm is a string, which forms the return value of 
the <a href="#function-format-number"><b>format-number</b></a> function.</p><p>The algorithm for this second stage of processing is as follows:</p><ol type="1"><li><p>If the input number is NaN (not a number), return the concatenation of 
the <var>prefix</var>, the specified <var>NaN-symbol</var>, and the <var>suffix</var>, where the 
<var>prefix</var> and <var>suffix</var> are taken from the positive sub-picture if 
<var>two-sub-pictures</var> is true.</p></li><li><p>In the rules below, select the set of variables that
apply to positive numbers if the input number is positive, and the
set of variables for negative numbers otherwise. Negative zero is taken as negative,
 positive zero as positive.</p></li><li><p>If the input number is positive or negative infinity, return the 
concatenation of the appropriate <var>prefix</var>, the <var>infinity-symbol</var>,
 and the appropriate <var>suffix</var>.</p></li><li><p>If <var>is-percent</var> is true, multiply 
the number by 100. If <var>is-per-mille</var>
is true, multiply the number by 1000. The resulting number is referred
to below as the <var>adjusted number</var>.</p></li><li><p>
								<a name="d5e15612"><small>[ERR132] </small></a>It is a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a>
if 
the absolute value of the <var>adjusted number</var> is numerically greater 
than or equal to the <var>overflow-threshold</var>. The processor may
signal the error, or may recover by formatting the number as if the sub-picture were extended
to the left (after any prefix) with a sufficient number of <var>digit-sign</var> characters to accommodate
the <var>adjusted number</var>, with the addition of <var>grouping-separator</var>
characters at each multiple of <var>N</var> characters, if and only if the existing
<var>whole-part-grouping-positions</var> sequence satisfies the rule that the <var>M</var>th
integer in the sequence is in all cases equal to <var>M * N</var>.
									
								
							</p></li><li><p>(Integer case) If <var>integer-mode</var>
is true, round the <var>adjusted number</var> to the nearest integer;
if two integers are equally near, then round it to the
nearest even integer. If the number of 
digits is less than <var>minimum-whole-part-size</var>, prepend <var>zero-digit-sign</var> 
characters to pad out to that size. Map all digits if the 
<var>digit-range-mapping</var> property is true. If 
the <var>whole-part-grouping-positions</var> list is non-empty, insert a 
<var>grouping-separator-sign</var> at each position listed in <var>whole-part-grouping-positions</var>,
provided there is at least one digit to the left of that <var>grouping-separator-sign</var>.
Return the concatenation of the <var>prefix</var>, the 
string conversion of the number, and the <var>suffix</var>.</p></li><li><p>Render the <var>whole-part</var> as a string. 
 If the number of digits is less than 
<var>minimum-whole-part-size</var>, prepend <var>zero-digit</var> characters 
to pad out to that size. Map all digits if the 
<var>digit-range-mapping</var> property is true. If 
the <var>whole-part-grouping-positions</var> list is non-empty, insert a 
<var>grouping-separator-sign</var> at each position listed in <var>whole-part-grouping-positions</var>,
provided there is at least one digit to the left of that <var>grouping-separator-sign</var>.. 
(Note: the result of this step could be a zero-length string.) </p></li><li><p>Render the <var>fractional-part</var> as a string. If the number of digits is 
less than <var>minimum-fractional-part-size</var>, append <var>zero-digit-sign</var> 
characters to pad out to that size. If the number of 
digits is greater than <var>maximum-fractional-part-size</var>,
round the value to the nearest value that can be represented
using <var>maximum-fractional-part-size</var> digits in the fractional part; if two
such values are equally near, choose the one whose last digit is even.
Map all digits 
if the <var>digit-range-mapping</var> property is true. 
If 
the <var>fractional-part-grouping-positions</var> list is non-empty, insert a 
<var>grouping-separator-sign</var> at each position listed in <var>fractional-part-grouping-positions</var>,
provided there is at least one digit to the right of that <var>grouping-separator-sign</var>.. 
(Note: the 
result of this step could be a zero-length string. It 
could also be a string of zeroes.) </p></li><li><p>Return the concatenation of 
the prefix, the <var>whole-part</var> as rendered above, the 
<var>decimal-separator-sign</var>, the <var>fractional-part</var> as rendered 
above, and the <var>suffix</var>.</p></li></ol></div></div><div class="div2">
<h3><a name="misc-func" id="misc-func"></a>16.5 Miscellaneous Additional Functions</h3><div><blockquote><p><b><a href="#issue-format-date-time">Issue 75 (format-date-time)</a>: </b>There is a need for an additional function to format dates and times.</p></blockquote></div><div class="div3">
<h4><a name="current-function" id="current-function"></a>16.5.1 current</h4><a name="function-current" id="function-current"></a><div class="proto"><code class="function">current</code>()<code class="as">&nbsp;as&nbsp;</code><code class="return-type">item</code></div><p>The <a href="#function-current"><b>current</b></a> function, used within
an XPath <a title="expression" href="#dt-expression">expression</a>, returns the item that was the <a title="context item" href="#dt-context-item">context
item</a> at the point where the expression was invoked from the XSLT stylesheet.
This is referred to as the current item.  
 For an outermost expression (an expression not occurring
within another expression), the current item is always the same as the
context item.  Thus,</p><div class="exampleInner"><pre>&lt;xsl:value-of select="current()"/&gt;</pre></div><p>means the same as</p><div class="exampleInner"><pre>&lt;xsl:value-of select="."/&gt;</pre></div><p>However, within square brackets, or on the
 right-hand side of the <code>/</code> operator, 
 the current item is generally
different from the context item.</p><div class="example"><p>For example,</p><div class="exampleInner"><pre>&lt;xsl:apply-templates select="//glossary/item[@name=current()/@ref]"/&gt;</pre></div><p>will process all <code>item</code> elements that have a
<code>glossary</code> parent element and that have a <code>name</code>
attribute with value equal to the value of the current item's
<code>ref</code> attribute. This is different from</p><div class="exampleInner"><pre>&lt;xsl:apply-templates select="//glossary/item[@name=./@ref]"/&gt;</pre></div><p>which means the same as</p><div class="exampleInner"><pre>&lt;xsl:apply-templates select="//glossary/item[@name=@ref]"/&gt;</pre></div><p>and so would process all <code>item</code> elements that have a
<code>glossary</code> parent element and that have a <code>name</code>
attribute and a <code>ref</code> attribute with the same value.</p></div><p>If the <a href="#function-current"><b>current</b></a> function is used within a 
<a title="pattern" href="#dt-pattern">pattern</a>, its value is the node that is being matched 
against the pattern.</p></div><div class="div3">
<h4><a name="unparsed-entity-uri" id="unparsed-entity-uri"></a>16.5.2 unparsed-entity-uri</h4><a name="function-unparsed-entity-uri" id="function-unparsed-entity-uri"></a><div class="proto"><code class="function">unparsed-entity-uri</code>(<code class="arg">$entity-name</code><code class="as">&nbsp;as&nbsp;</code><code class="type">xs:string</code>)<code class="as">&nbsp;as&nbsp;</code><code class="return-type">xs:string</code></div><p>The <a href="#function-unparsed-entity-uri"><b>unparsed-entity-uri</b></a> returns the URI of the
unparsed entity whose name is given by the value of the <code>$entity-name</code> argument, in the 
document containing the context node
 (see <a href="#unparsed-entities"><b>4.2 Unparsed Entities</b></a>).  It returns the
zero-length string  if there is no such entity.</p><p><a name="d5e15886"><small>[ERR133] </small></a>It is a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a>
if the <a href="#function-unparsed-entity-uri"><b>unparsed-entity-uri</b></a> is called when there is no current node. The
processor must signal the error.</p></div><div class="div3">
<h4><a name="unparsed-entity-public-id" id="unparsed-entity-public-id"></a>16.5.3 unparsed-entity-public-id</h4><a name="function-unparsed-entity-public-id" id="function-unparsed-entity-public-id"></a><div class="proto"><code class="function">unparsed-entity-public-id</code>(<code class="arg">$entity-name</code><code class="as">&nbsp;as&nbsp;</code><code class="type">xs:string</code>)<code class="as">&nbsp;as&nbsp;</code><code class="return-type">xs:string</code></div><p>The <a href="#function-unparsed-entity-public-id"><b>unparsed-entity-public-id</b></a> returns the public identifier of the
unparsed entity whose name is given by the value of the <code>$entity-name</code> argument, in the 
document containing the context node
 (see <a href="#unparsed-entities"><b>4.2 Unparsed Entities</b></a>).  It returns the
zero-length string  if there is no such entity.</p><p><a name="d5e15915"><small>[ERR134] </small></a>It is a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a>
if the <a href="#function-unparsed-entity-public-id"><b>unparsed-entity-public-id</b></a> is called when there is no current node. The
processor must signal the error.</p></div><div class="div3">
<h4><a name="generate-id" id="generate-id"></a>16.5.4 generate-id</h4><a name="function-generate-id" id="function-generate-id"></a><div class="proto"><code class="function">generate-id</code>()<code class="as">&nbsp;as&nbsp;</code><code class="return-type">xs:string</code></div><div class="proto"><code class="function">generate-id</code>(<code class="arg">$node</code><code class="as">&nbsp;as&nbsp;</code><code class="type">node?</code>)<code class="as">&nbsp;as&nbsp;</code><code class="return-type">xs:string</code></div><p>The <a href="#function-generate-id"><b>generate-id</b></a> function returns a string that
uniquely identifies a given node.  The unique identifier must consist of ASCII
alphanumeric characters and must start with an alphabetic character.
Thus, the string is syntactically an XML name.  An implementation is
free to generate an identifier in any convenient way provided that it
always generates the same identifier for the same node and that
different identifiers are always generated from different nodes. An
implementation is under no obligation to generate the same identifiers
each time a document is transformed.  There is no guarantee that a
generated unique identifier will be distinct from any unique IDs
specified in the source document.  If the argument 
is the empty sequence, the result is the zero-length string. 
If the argument is omitted, it defaults
to the <a title="context node" href="#dt-context-node">context node</a>.</p></div><div class="div3">
<h4><a name="system-property" id="system-property"></a>16.5.5 system-property</h4><a name="function-system-property" id="function-system-property"></a><div class="proto"><code class="function">system-property</code>(<code class="arg">$property-name</code><code class="as">&nbsp;as&nbsp;</code><code class="type">xs:string</code>)<code class="as">&nbsp;as&nbsp;</code><code class="return-type">xs:string</code></div><p>The <code>$property-name</code> argument must evaluate to a string that is a <a title="QName" href="#dt-qname">QName</a>.
  The <a title="QName" href="#dt-qname">QName</a> is expanded into a name using
the namespace declarations in scope for the <a title="expression" href="#dt-expression">expression</a>.
<a name="d5e15981"><small>[ERR136] </small></a>It is a 
<a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> if the value 
 is
not a valid QName, or if there is no
 namespace declaration in scope for the prefix of the QName. 
The <a title="processor" href="#dt-processor">processor</a> must signal these errors.
						
					</p><p>The <a href="#function-system-property"><b>system-property</b></a> function returns a string
representing the value of the system property identified by the name.
If there is no such system property, the zero-length string is
returned.</p><p>Implementations must provide the following system properties, which
are all in the <a title="XSLT namespace" href="#dt-xslt-namespace">XSLT namespace</a>:</p><ul><li><p><code>xsl:version</code>, a number giving the version of XSLT
implemented by the <a title="processor" href="#dt-processor">processor</a>; for implementations conforming to the
version of XSLT specified by this document, this is the string
<code>"2.0"</code>. The value will always be a string in the lexical
space of the decimal data type defined in XML Schema (see <a href="#XMLSCHEMA">[XML Schema]</a>)
This allows the value to be converted to a number for the purpose
of magnitude comparisons.</p></li><li><p><code>xsl:vendor</code>, a string identifying the implementor of the
<a title="processor" href="#dt-processor">processor</a></p></li><li><p>
<code>xsl:vendor-url</code>, a string containing a URL
identifying the implementor of the <a title="processor" href="#dt-processor">processor</a>; typically this is the
host page (home page) of the implementor's Web site.</p></li><li><p><code>xsl:product-name</code>, a string containing the name
of the implementation, as defined by the implementor. This should normally
remain constant from one release of the product to the next. It should also be 
constant across platforms in cases where the same source code is used to produce
compatible products for multiple execution platforms.</p></li><li><p><code>xsl:product-version</code>, a string identifying the version 
of the implementation, as defined by the implementor. This should normally
vary from one release of the product to the next, and at the discretion
of the implementor it may also vary across different execution platforms.</p></li></ul><p>The actual values returned for the above properties
are <a title="implementation-defined" href="#dt-implementation-defined">implementation-defined</a>.</p><p>The set of system properties that are supported, in addition
to those listed above, is also <a title="implementation-defined" href="#dt-implementation-defined">implementation-defined</a>.</p><blockquote><table width="90%"><tr><td width="10%" align="left" valign="top"><b>Note:</b></td><td align="left" valign="top"><p>An implementation must not return the value <code>2.0</code>
as the value of the <code>xsl:version</code> system property unless it is
conformant to XSLT 2.0.</p><p>It is recognized that vendors who are enhancing XSLT 1.0 processors may
wish to release interim implementations before all the mandatory features of this
specification are implemented. Since such products are not conformant to XSLT 2.0, this
specification cannot define their behavior. However, implementors of such products are
encouraged to return a value for the <code>xsl:version</code> system property that
is intermediate between 1.0 and 2.0, and to provide the <a href="#function-element-available"><b>element-available</b></a> and
<a href="#function-function-available"><b>function-available</b></a> functions to allow users to test which features have
been fully implemented.</p></td></tr></table></blockquote><p>Implementations must not define additional system
properties in the XSLT namespace.</p></div></div></div><div class="div1">
<h2><a name="message" id="message"></a>17 Messages</h2><p class="element-syntax"><a name="element-message"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:message<br>&nbsp;&nbsp;terminate = { "yes" | "no" }&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>content-constructor</var> --&gt;<br>&lt;/xsl:message&gt;</code></p><p>The <a href="#element-message"><code>xsl:message</code></a> instruction sends a message in 
an <a title="implementation-defined" href="#dt-implementation-defined">implementation-defined</a> way. 
 The <a href="#element-message"><code>xsl:message</code></a> instruction causes the creation of a new
document node. The content of the
<a href="#element-message"><code>xsl:message</code></a> instruction is a
<a title="content constructor" href="#dt-content-constructor">content constructor</a>; this is evaluated
with the new document node as the <a title="current destination node" href="#dt-current-destination-node">current
destination node</a>
				.



 This XML document forms the content of the
message. The document is typically serialized and output to an
 <a title="implementation-defined" href="#dt-implementation-defined">implementation-defined</a>
destination. The result of the <a href="#element-message"><code>xsl:message</code></a> instruction is an empty
sequence.</p><blockquote><table width="90%"><tr><td width="10%" align="left" valign="top"><b>Note:</b></td><td align="left" valign="top"><p>Note: in many cases, the XML document produced using <a href="#element-message"><code>xsl:message</code></a> will
consist of a document node owning a single text node. However, it may contain a more complex
structure.</p></td></tr></table></blockquote><blockquote><table width="90%"><tr><td width="10%" align="left" valign="top"><b>Note:</b></td><td align="left" valign="top"><p>An implementation might implement <a href="#element-message"><code>xsl:message</code></a> by
popping up an alert box or by writing to a log file.</p></td></tr></table></blockquote><p>The <code>terminate</code> attribute is interpreted as
an <a title="attribute value template" href="#dt-attribute-value-template">attribute value
template</a>.</p><p>If the 
					<a title="effective value" href="#dt-effective-value">effective value</a>
of the 
				<code>terminate</code> attribute is
				<code>yes</code>, then the <a title="processor" href="#dt-processor">processor</a> must
 terminate processing after sending the message.  The default value is <code>no</code>.</p><div class="example"><p>One convenient way to do localization is to put the localized
information (message text, etc.) in an XML document, which becomes an
additional input file to the stylesheet.  For example, suppose
messages for a language <code>
						<var>L</var>
					</code> are stored in an XML
file <code>resources/<var>L</var>.xml</code> in the form:</p><div class="exampleInner"><pre>&lt;messages&gt;
  &lt;message name="problem"&gt;A problem was detected.&lt;/message&gt;
  &lt;message name="error"&gt;An error was detected.&lt;/message&gt;
&lt;/messages&gt;
</pre></div><p>Then a stylesheet could use the following approach to localize
messages:</p><div class="exampleInner"><pre>&lt;xsl:param name="lang" select="'en'"/&gt;
&lt;xsl:variable name="messages"
  select="document(concat('resources/', $lang, '.xml'))/messages"/&gt;

&lt;xsl:template name="localized-message"&gt;
  &lt;xsl:param name="name"/&gt;
  &lt;xsl:message&gt;
    &lt;xsl:value-of select="$messages/message[@name=$name]"/&gt;
  &lt;/xsl:message&gt;
&lt;/xsl:template&gt;

&lt;xsl:template name="problem"&gt;
  &lt;xsl:call-template name="localized-message"&gt;
    &lt;xsl:with-param name="name"&gt;problem&lt;/xsl:with-param&gt;
  &lt;/xsl:call-template&gt;
&lt;/xsl:template&gt;</pre></div></div></div><div class="div1">
<h2><a name="extension" id="extension"></a>18 Extensibility and Fallback</h2><p>XSLT allows two kinds of extension, extension instructions and
extension functions.
<a name="dt-extension-instruction" id="dt-extension-instruction" title="extension instruction"></a>An
<b>extension instruction</b> is an element within a
 <a title="content constructor" href="#dt-content-constructor">content constructor</a> that is in
 a namespace (not the <a title="XSLT namespace" href="#dt-xslt-namespace">XSLT namespace</a>)
 designated as an extension namespace.
<a name="dt-extension-function" id="dt-extension-function" title="extension function"></a>An
<b>extension function</b> is a function that is available for
use within an XPath <a title="expression" href="#dt-expression">expression</a>, other than a core function defined
in the XPath specification, an additional function defined in this
XSLT specification, or a <a title="stylesheet function" href="#dt-stylesheet-function">stylesheet
function</a> defined using an <a href="#element-function"><code>xsl:function</code></a> declaration.. 
</p><p>This specification does not define any mechanism for creating or binding
implementations of <a title="extension instruction" href="#dt-extension-instruction">extension instructions</a>
or <a title="extension function" href="#dt-extension-function">extension functions</a>, and
does not require that implementations support any such mechanism.
Such mechanisms, if they exist, are
<a title="implementation-defined" href="#dt-implementation-defined">implementation-defined</a>.
Therefore, an XSLT stylesheet that must
be portable between XSLT implementations cannot rely on particular
extensions being available.  XSLT provides mechanisms that allow an
XSLT stylesheet to determine whether the implementation makes particular extensions
available, and to specify what should happen if those extensions are
not available.  If an XSLT stylesheet is careful to make use of these
mechanisms, it is possible for it to take advantage of extensions and
still retain portability.</p><div class="div2">
<h3><a name="extension-functions" id="extension-functions"></a>18.1 Extension Functions</h3><p>If the <u>FunctionName</u> used in a <u>FunctionCall</u> 
within an XPath <a title="expression" href="#dt-expression">expression</a> is
not an <u>NCName</u> (that is, if it contains a colon),
and if the stylesheet
contains no <a title="stylesheet function" href="#dt-stylesheet-function">stylesheet function</a> with
a matching <a title="expanded-QName" href="#dt-expanded-qname">expanded-QName</a>,
then it is treated as a call to an <a title="extension function" href="#dt-extension-function">extension function</a>.
The <a title="QName" href="#dt-qname">QName</a> used as the <u>FunctionName</u> is expanded using the namespace declarations
in scope at the point in the stylesheet where the expression appears.</p><div class="div3">
<h4><a name="d5e16287" id="d5e16287"></a>18.1.1 Testing Availability of Functions</h4><p>The <a href="#function-function-available"><b>function-available</b></a> function can be used with the
<a href="#element-choose"><code>xsl:choose</code></a> and <a href="#element-if"><code>xsl:if</code></a> instructions to
explicitly control how a stylesheet should behave if a particular
extension function is not available.</p><a name="function-function-available" id="function-function-available"></a><div class="proto"><code class="function">function-available</code>(<code class="arg">$function-name</code><code class="as">&nbsp;as&nbsp;</code><code class="type">xs:string</code>)<code class="as">&nbsp;as&nbsp;</code><code class="return-type">xs:boolean</code></div><p>A function name is said to be available if
it matches the name of a core function defined in XPath, or the name
of an additional function defined in this XSLT specification, or the
name of a <a title="stylesheet function" href="#dt-stylesheet-function">stylesheet function</a>,
or if the <a title="processor" href="#dt-processor">processor</a>
is able to locate an implementation of an
<a title="extension function" href="#dt-extension-function">extension function</a>
with a matching name.</p><p>The <a href="#function-function-available"><b>function-available</b></a> function
returns true if the function name supplied as its <code>$function-name</code> argument is available;
otherwise it returns false.</p><p>The value of the <code>$function-name</code> argument must be a string containing a <a title="QName" href="#dt-qname">QName</a>. 
The <a title="QName" href="#dt-qname">QName</a> is expanded into an <a title="expanded-QName" href="#dt-expanded-qname">expanded-QName</a> using the
namespace declarations in scope for the <a title="expression" href="#dt-expression">expression</a>. The
<a href="#function-function-available"><b>function-available</b></a> function returns true if and
only if the <a title="expanded-QName" href="#dt-expanded-qname">expanded-QName</a> is the name of a function in the function
library. If the <a title="expanded-QName" href="#dt-expanded-qname">expanded-QName</a> has a non-null namespace URI, then it
refers to a <a title="stylesheet function" href="#dt-stylesheet-function">stylesheet
function</a> or <a title="extension function" href="#dt-extension-function">extension function</a>; 
otherwise, it refers to a function defined by XPath or XSLT.</p><p>
						<a name="d5e16356"><small>[ERR137] </small></a>It is a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> 
if the argument 

does not evaluate to a string that is a valid <a title="QName" href="#dt-qname">QName</a>,
or if there is no namespace declaration in scope for the prefix of the <a title="QName" href="#dt-qname">QName</a>.
The <a title="processor" href="#dt-processor">processor</a> must either signal the error,
 or must recover by returning the value false.
						
					</p><blockquote><table width="90%"><tr><td width="10%" align="left" valign="top"><b>Note:</b></td><td align="left" valign="top"><p>The fact that a function with a given name is available
gives no guarantee that any particular call on the function will be successful. For example,
it is not possible to determine the number of arguments expected, nor their types.</p></td></tr></table></blockquote><p>
						<a name="d5e16385"><small>[ERR138] </small></a>It is a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> if
a <u>FunctionCall</u> within an XPath <a title="expression" href="#dt-expression">expression</a>
is evaluated, when the function in question is not available.
The <a title="processor" href="#dt-processor">processor</a> must
signal the error.
						  
An implementation must not signal a
 <a title="static error" href="#dt-static-error">static error</a> merely
because an expression contains a call to 
an extension function for which no implementation is available.</p></div><div class="div3">
<h4><a name="d5e16406" id="d5e16406"></a>18.1.2 Calling Extension Functions</h4><p>If the <u>FunctionName</u> used in a <u>FunctionCall</u> 
within an XPath <a title="expression" href="#dt-expression">expression</a> identifies an
extension function, then to evaluate the <u>FunctionCall</u>, the processor
will first evaluate each of the arguments in the <u>FunctionCall</u>. If the
processor has information about the data types expected by the extension function,
then it may perform any necessary type conversions between the XPath data types and
those defined by the implementation language. If multiple extension functions are
available with the same name, the processor may decide which one to invoke based on
the number of arguments, the types of the arguments, or any other criteria.
The result returned by the implementation
is returned as the result of the function call, again after any necessary conversions
between the data types of the implementation language and those of XPath. The details
of such type conversions are outside the scope of this specification.</p><p>
						<a name="d5e16428"><small>[ERR139] </small></a>It is a <a title="dynamic error" href="#dt-dynamic-error">dynamic
error</a> if the arguments supplied to a call on an extension function do
not satisfy the rules defined for that particular extension function, or if the
extension function reports an error, or if the result of the extension function
cannot be converted to an XPath value.The processor must signal the
error.
						
					</p><blockquote><table width="90%"><tr><td width="10%" align="left" valign="top"><b>Note:</b></td><td align="left" valign="top"><p>There is no prohibition on calling extension functions that
have side-effects (for example, an extension function that writes data to a file). However,
the order of execution of XSLT instructions is not defined in this specification, so the
effects of such functions are unpredictable.</p></td></tr></table></blockquote><p>Implementations are not required to perform full validation
of values returned by extension functions. It is an error for
an extension function to return a string containing characters that are not permitted
in XML, but the consequences of this error are 
<a title="implementation-defined" href="#dt-implementation-defined">implementation-defined</a>. The implementation
may raise an error, may convert the string to a string containing valid characters only, or may
treat the invalid characters as if they were permitted characters.</p><blockquote><table width="90%"><tr><td width="10%" align="left" valign="top"><b>Note:</b></td><td align="left" valign="top"><p>The ability to execute extension functions represents a
potential security weakness, since untrusted stylesheets may invoke code that has
privileged access to resources on the machine where the processor executes. 
Implementations may therefore provide mechanisms that restrict the use of
extension functions by untrusted stylesheets.</p></td></tr></table></blockquote></div><div class="div3">
<h4><a name="external-objects" id="external-objects"></a>18.1.3 External Objects</h4><p>An implementation may allow an extension function to return
an object that does not have any natural representation in the XPath data model,
either as an atomic value or as a node. For example, an extension function <code>sql:connect</code> might
return an object that represents a connection to a relational database; the resulting
connection object might be passed as an argument to calls on other extension functions
such as <code>sql:insert</code> and <code>sql:select</code>.</p><p>The way in which such objects are represented in the type
system is <a title="implementation-defined" href="#dt-implementation-defined">implementation-defined</a>.
They might be represented by a completely new data type, or they might be mapped to existing
data types such as <code>integer</code>, <code>string</code>, or <code>anyURI</code>.</p></div></div><div class="div2">
<h3><a name="extension-instruction" id="extension-instruction"></a>18.2 Extension Instructions</h3><p>
					<a name="dt-extension-namespace" id="dt-extension-namespace" title="extension namespace"></a>The
<a title="extension instruction" href="#dt-extension-instruction">extension instruction</a> mechanism allows namespaces to be designated as
<b>extension namespace</b>s. When a namespace is designated as
an extension namespace and an element with a name from that namespace
occurs in a <a title="content constructor" href="#dt-content-constructor">content constructor</a>,
 then the element is treated as an <a title="instruction" href="#dt-instruction">instruction</a>
rather than as a <a title="literal result element" href="#dt-literal-result-element">literal result element</a>. The namespace
determines the semantics of the instruction.</p><blockquote><table width="90%"><tr><td width="10%" align="left" valign="top"><b>Note:</b></td><td align="left" valign="top"><p>Since an element that is a child of an
<a href="#element-stylesheet"><code>xsl:stylesheet</code></a> element is not occurring <em>in a
<a title="content constructor" href="#dt-content-constructor">content constructor</a>
						</em>, 
 <a title="user-defined data element" href="#dt-data-element">user-defined data elements</a>
(see <a href="#user-defined-top-level"><b>3.4.1 User-defined Data Elements</b></a>) are not extension
elements as defined here, and nothing in this section applies to
them.</p></td></tr></table></blockquote><div class="div3">
<h4><a name="d5e16524" id="d5e16524"></a>18.2.1 Designating an Extension Namespace</h4><p>A namespace is designated as an extension namespace by using an
<code>[xsl:]extension-element-prefixes</code> attribute on an
element in the stylesheet (see <a href="#standard-attributes"><b>3.3 Standard Attributes</b></a>). 
The attribute must be in the XSLT namespace
only if its parent element is <em>not</em> in the XSLT namespace.
The value of the attributes is a
whitespace-separated list of namespace prefixes. The namespace bound
to each of the prefixes is designated as an extension namespace.  <a name="d5e16537"><small>[ERR140] </small></a>It
is a <a title="static error" href="#dt-static-error">static error</a>
 if there is no namespace bound to the prefix on the
element bearing the <code>[xsl:]extension-element-prefixes</code> attribute.  
The default
namespace (as declared by <code>xmlns</code>) may be designated as an
extension namespace by including <code>#default</code> in the list of
namespace prefixes.  The designation of a namespace as an extension
namespace is effective for
the element bearing the <code>[xsl:]extension-element-prefixes</code> attribute
and for all descendants of that element within the same stylesheet module.</p></div><div class="div3">
<h4><a name="d5e16555" id="d5e16555"></a>18.2.2 Testing Availability of Instructions</h4><p>The <a href="#function-element-available"><b>element-available</b></a> function can be used with the
<a href="#element-choose"><code>xsl:choose</code></a> and <a href="#element-if"><code>xsl:if</code></a> instructions to
explicitly control how a stylesheet should behave if a particular
extension instruction is not available.</p><a name="function-element-available" id="function-element-available"></a><div class="proto"><code class="function">element-available</code>(<code class="arg">$element-name</code><code class="as">&nbsp;as&nbsp;</code><code class="type">xs:string</code>)<code class="as">&nbsp;as&nbsp;</code><code class="return-type">xs:boolean</code></div><p>The value of the <code>$element-name</code> argument must be a string containing a <a title="QName" href="#dt-qname">QName</a>.
The <a title="QName" href="#dt-qname">QName</a> is expanded into an <a title="expanded-QName" href="#dt-expanded-qname">expanded-QName</a> using the
namespace declarations in scope for the <a title="expression" href="#dt-expression">expression</a>. If there is a default namespace in scope,
then it is used to expand an unprefixed <a title="QName" href="#dt-qname">QName</a>. The
<a href="#function-element-available"><b>element-available</b></a> function returns true if and
only if the <a title="expanded-QName" href="#dt-expanded-qname">expanded-QName</a> is the name of an <a title="instruction" href="#dt-instruction">instruction</a>.  If the
<a title="expanded-QName" href="#dt-expanded-qname">expanded-QName</a> has a namespace URI equal to 
the <a title="XSLT namespace" href="#dt-xslt-namespace">XSLT namespace</a> URI,
then it refers to an element defined by XSLT.  Otherwise, it refers to
an <a title="extension instruction" href="#dt-extension-instruction">extension instruction</a>. If the <a title="expanded-QName" href="#dt-expanded-qname">expanded-QName</a> has a null namespace URI,
the <a href="#function-element-available"><b>element-available</b></a> function will return
false.</p><p>
						<a name="d5e16617"><small>[ERR141] </small></a>It is a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> 
if the argument 

does not evaluate to a string that is a valid <a title="QName" href="#dt-qname">QName</a>,
or if there is no namespace declaration in scope for the prefix of the <a title="QName" href="#dt-qname">QName</a>. 
The <a title="processor" href="#dt-processor">processor</a> must either signal the error,
 or must recover by returning the value false.
						
					</p><p>If the <a title="processor" href="#dt-processor">processor</a> does not have an implementation of a
particular <a title="extension instruction" href="#dt-extension-instruction">extension instruction</a> available, then the
<a href="#function-element-available"><b>element-available</b></a> function must return false for
the name of the element.  When such an extension instruction is
evaluated, then the <a title="processor" href="#dt-processor">processor</a> must perform fallback for the
element as specified in <a href="#fallback"><b>18.2.3 Fallback</b></a>.  An implementation
must not signal an error merely because a template contains an
extension instruction for which no implementation is available.</p><p>If the <a title="processor" href="#dt-processor">processor</a> has an implementation of a particular
<a title="extension instruction" href="#dt-extension-instruction">extension instruction</a> available, then the
<a href="#function-element-available"><b>element-available</b></a> function must return true for
the name of the element.</p></div><div class="div3">
<h4><a name="fallback" id="fallback"></a>18.2.3 Fallback</h4><p class="element-syntax"><a name="element-fallback"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:fallback&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>content-constructor</var> --&gt;<br>&lt;/xsl:fallback&gt;</code></p><p>
						<a name="d5e16678"><small>[ERR142] </small></a>When a <a title="processor" href="#dt-processor">processor</a> performs fallback for an
<a title="instruction" href="#dt-instruction">instruction</a> element, if the instruction 
element has one or more
<a href="#element-fallback"><code>xsl:fallback</code></a> children, then the content of each of the
<a href="#element-fallback"><code>xsl:fallback</code></a> children must be evaluated; it is a
 <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a>
if it has no <a href="#element-fallback"><code>xsl:fallback</code></a> children. 
This error must be signaled.
						
					</p><p>The content of an <a href="#element-fallback"><code>xsl:fallback</code></a> element is a
 <a title="content constructor" href="#dt-content-constructor">content constructor</a>,
  and when performing fallback, the value
 returned by the <a href="#element-fallback"><code>xsl:fallback</code></a> element
is the result of evaluating this content constructor.</p><p>When not performing fallback, evaluating an <a href="#element-fallback"><code>xsl:fallback</code></a> element returns
an empty sequence: the content of the <a href="#element-fallback"><code>xsl:fallback</code></a> element is ignored.</p><p>There are two situations where a
 <a title="processor" href="#dt-processor">processor</a> performs fallback: when an
 extension instruction that is not available is evaluated, and when an instruction
 in the XSLT namespace, that is not defined in XSLT 2.0, is evaluated within a 
 region of the stylesheet for which <a title="forwards-compatible behavior" href="#dt-forwards-compatible-behavior">forwards
 compatible behavior</a> is enabled.</p></div></div></div><div class="div1">
<h2><a name="result-trees" id="result-trees"></a>19 Result Trees</h2><p>The output of a transformation is a set of result trees.
			</p><p>A result tree may be created either explicitly, by evaluating an
<a href="#element-result-document"><code>xsl:result-document</code></a> instruction, or implicitly, by evaluating an instruction
that constructs a new node at a time when there is no <a title="current destination node" href="#dt-current-destination-node">current
destination node</a>. An implicit result tree is created as if the content constructor in which
this instruction appears were contained in an <a href="#element-result-document"><code>xsl:result-document</code></a> instruction with no
attributes.</p><p>The way in which a  result tree is delivered to an application
is <a title="implementation-defined" href="#dt-implementation-defined">implementation-defined</a>.</p><p>A  result tree has a URI. If the implementation provides an API to access  result
trees, then it must allow a final result tree to be identified by means of this URI.</p><blockquote><table width="90%"><tr><td width="10%" align="left" valign="top"><b>Note:</b></td><td align="left" valign="top"><p>The URI of the
result tree is not the same thing as the URI of its serialized representation on disk, if any.
For example, a server (or browser client) might store the result trees only in memory, or
in an internal disk cache. 
As long as it satisfies requests for those URIs, it is irrelevant where they are actually written
on disk, if at all.</p></td></tr></table></blockquote><blockquote><table width="90%"><tr><td width="10%" align="left" valign="top"><b>Note:</b></td><td align="left" valign="top"><p>It will often be the case that one result tree contains links to another result tree produced
during the same transformation, in the form of a relative URI. The mechanism of associating a URI with
a final result tree has been chosen to allow the integrity of such links to be preserved when the
trees are serialized.</p></td></tr></table></blockquote><blockquote><table width="90%"><tr><td width="10%" align="left" valign="top"><b>Note:</b></td><td align="left" valign="top"><p>The URI of a result tree is unrelated to the base URI
of its document node.</p></td></tr></table></blockquote><p>Serialization of final result trees is described further in <a href="#serialization"><b>20 Serialization</b></a>
			</p><div class="div2">
<h3><a name="secondary-result-trees" id="secondary-result-trees"></a>19.1 
					 Result Trees</h3><p class="element-syntax"><a name="element-result-document"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:result-document<br>&nbsp;&nbsp;format = <var>qname</var><br>&nbsp;&nbsp;href = { <var>uri-reference</var> }<br>&nbsp;&nbsp;type-information = "strict" | "lax" | "preserve" | "none"&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>content-constructor</var> --&gt;<br>&lt;/xsl:result-document&gt;</code></p><p>The <a href="#element-result-document"><code>xsl:result-document</code></a> instruction is used to create a
 result tree. The content of the
<a href="#element-result-document"><code>xsl:result-document</code></a> element is a 
<a title="content constructor" href="#dt-content-constructor">content constructor</a>; this is evaluated
to create a sequence of nodes. A document node is created with this
sequence of nodes as its children. The tree rooted at this document node
forms the  result tree.</p><p>The <a href="#element-result-document"><code>xsl:result-document</code></a> instruction defines the URI
 of the  result
tree, and may optionally specify the output format to be used for serializing this tree.</p><p>The value of the <code>format</code> attribute, if specified, must be a <a title="QName" href="#dt-qname">QName</a>.
The <a title="QName" href="#dt-qname">QName</a> is expanded using the namespace declarations in scope for the 
<a href="#element-result-document"><code>xsl:result-document</code></a> element. The <a title="expanded-QName" href="#dt-expanded-qname">expanded-QName</a> must match the expanded
QName of a named <a title="output definition" href="#dt-output-definition">output definition</a> in the stylesheet. 
This identifies
the <a href="#element-output"><code>xsl:output</code></a> declaration that will control the serialization of the
result tree (see <a href="#serialization"><b>20 Serialization</b></a>), if the result tree is serialized. If the
<code>format</code> attribute is omitted, the unnamed
 <a title="output definition" href="#dt-output-definition">output definition</a>
is used to control serialization of the result tree.</p><p>
					<a name="d5e17065"><small>[ERR145] </small></a>It is a <a title="static error" href="#dt-static-error">static error</a> if the
value of the <code>format</code> attribute 

is not a valid QName, or if it does not match the <a title="expanded-QName" href="#dt-expanded-qname">expanded-QName</a> of an 
<a title="output definition" href="#dt-output-definition">output definition</a> in the stylesheet.
				</p><p>The <code>href</code> attribute is 
					optional. The default value is the zero-length string. 
  The <a title="effective value" href="#dt-effective-value">effective value</a> of the attribute must be a
   URI, which may be absolute or relative. 
There may be
 <a title="implementation-defined" href="#dt-implementation-defined">implementation-defined</a>
 restrictions on the form of absolute URI
 that may be used, but the implementation is not required to enforce any restrictions.
 Any legal relative URI must be accepted. Note that the zero-length string
 is a legal relative URI.</p><p>If the <a title="effective value" href="#dt-effective-value">effective value</a> is a relative URI, then
 it is resolved relative to the 
					
						<a title="base output URI" href="#dt-base-output-uri">base output URI</a>
					.</p><p>The <code>type-information</code> attribute controls the 
 type annotations that will be present on element and attribute nodes in the result tree.
 The values and their meanings are the same as those for the <code>type-information</code> attribute
 on variable binding elements, described in <a href="#temporary-trees"><b>9.4 Temporary Trees</b></a>.</p><p>A <a title="processor" href="#dt-processor">processor</a> may allow a  result tree
to be serialized.
Serialization is described in <a href="#serialization"><b>20 Serialization</b></a>.
However, an implementation (for example,
a <a title="processor" href="#dt-processor">processor</a> running in an environment with no access
 to writable filestore) is not required to 
support the serialization of  result trees. An implementation that does not support
the serialization of  result trees must ignore the <code>format</code> attribute. 
Such an implementation
must provide the application with some means of access to the (un-serialized) result tree,
optionally using its URI to identify it.</p><blockquote><table width="100%"><tr><td width="10%" align="left" valign="top"><b>Ed. Note:</b></td><td align="left" valign="top">We don't want to say that it must ignore the format attribute, it might want to use
it in some other way.</td></tr></table></blockquote><div class="example"><p>
					The following example takes an XHTML document as input, and breaks it up so that the text
					following each &lt;h1&gt; element is included in a separate document. A new document <code>index.html</code>
					is constructed to act as an index:</p><blockquote><table width="100%"><tr><td width="10%" align="left" valign="top"><b>Ed. Note:</b></td><td align="left" valign="top">This example has not been tested.</td></tr></table></blockquote><div class="exampleInner"><pre>&lt;xsl:stylesheet
	version="2.0"
	xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
	xmlns:xhtml="http://www.w3.org/1999/xhtml"&gt;
	
&lt;xsl:output name="toc-format" method="xhtml" indent="yes"
            doctype-system="http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"
            doctype-public="-//W3C//DTD XHTML 1.0 Strict//EN"/&gt;
            
&lt;xsl:output name="section-format" method="xhtml" indent="no"
            doctype-system="http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"
            doctype-public="-//W3C//DTD XHTML 1.0 Transitional//EN"/&gt;/&gt;	
	 
&lt;xsl:template match="/"&gt;
  &lt;xsl:result-document href="toc.html" format="toc-format" type-information="strict"&gt;
    &lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;
      &lt;head&gt;&lt;title&gt;Table of Contents&lt;/title&gt;&lt;/head&gt;
      &lt;body&gt;
        &lt;h1&gt;Table of Contents&lt;/h1&gt;
        &lt;xsl:for-each select="/*/xhtml:body/(*[1] | xhtml:h1)"&gt;
          &lt;p&gt;&lt;a href="section{position()}.html"&gt;&lt;xsl:value-of select="."/&gt;&lt;/a&gt;&lt;/p&gt;
        &lt;/xsl:for-each&gt;
      &lt;/body&gt;
    &lt;/html&gt;
  &lt;/xsl:result-document&gt;
  &lt;xsl:for-each-group select="/*/xhtml:body/*" group-starting-with="xhtml:h1"&gt;
    &lt;xsl:result-document href="section{position()}.html" 
                         format="section-format" type-information="none"&gt;  	
      &lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;
        &lt;head&gt;&lt;xsl:value-of select="."/&gt;&lt;/head&gt;
        &lt;body&gt;
          &lt;xsl:copy-of select="current-group()"/&gt;
        &lt;/body&gt;
      &lt;/html&gt;
    &lt;/xsl:result-document&gt;
  &lt;/xsl:for-each-group&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre></div></div><p>
					<a name="d5e17174"><small>[ERR146] </small></a>It is a <a title="dynamic error" href="#dt-dynamic-error">dynamic
error</a> to evaluate the <a href="#element-result-document"><code>xsl:result-document</code></a> instruction when
the 
						
							<a title="current destination node" href="#dt-current-destination-node">current destination node</a>
is not a node belonging to a result tree (for example, when it is a node belonging to a
temporary tree). The
<a title="processor" href="#dt-processor">processor</a> must signal the error.
					.
 This means, for example,
that it is an error to use <a href="#element-result-document"><code>xsl:result-document</code></a> when the 
					tree containing the <a title="current destination node" href="#dt-current-destination-node">current destination node</a>
					
is a temporary tree created using <a href="#element-variable"><code>xsl:variable</code></a>, or a tree created using
<a href="#element-message"><code>xsl:message</code></a>, <a href="#element-attribute"><code>xsl:attribute</code></a>, etc.</p><p>
					<a name="d5e17221"><small>[ERR147] </small></a>It is a <a title="dynamic error" href="#dt-dynamic-error">dynamic
error</a> for a transformation to generate two or more result trees with the same URI. 
The <a title="processor" href="#dt-processor">processor</a> must signal the error.
					
				</p><blockquote><table width="90%"><tr><td width="10%" align="left" valign="top"><b>Note:</b></td><td align="left" valign="top"><p>Note, this means that it is an error for more than one <a href="#element-result-document"><code>xsl:result-document</code></a>
instruction to omit the <code>href</code> attribute, or for any <a href="#element-result-document"><code>xsl:result-document</code></a>
instruction to omit the <code>href</code> attribute if the initial result tree is created implicitly.</p></td></tr></table></blockquote><p>Technically, the result of evaluating the <a href="#element-result-document"><code>xsl:result-document</code></a>
instruction is an empty sequence. This means it does not contribute any nodes to
the result of the content constructor it is part of.</p><p>
					<a name="d5e17256"><small>[ERR148] </small></a>It is a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a>
for a stylesheet to write to an external resource and read from the same resource during a single
transformation, whether or not the same URI is used to access the resource in both cases. The
effect of this error is implementation-dependent: implementations are not obliged to detect
it.
					
				</p></div></div><div class="div1">
<h2><a name="serialization" id="serialization"></a>20 Serialization</h2><p>A <a title="processor" href="#dt-processor">processor</a> may output a result tree as a sequence of
bytes, although it is not required to be able to do so (see <a href="#conformance"><b>21 Conformance</b></a>). 
Stylesheet authors can use the <a href="#element-output"><code>xsl:output</code></a> declaration 
to specify how they wish result trees to be serialized. 
If a processor serializes the result tree, it should do so
as specified by these elements; however, it is not required to do so.</p><p class="element-syntax"><a name="element-output"></a><code>&lt;!-- Category: declaration --&gt;<br>&lt;xsl:output<br>&nbsp;&nbsp;name = <var>qname</var><br>&nbsp;&nbsp;method = "xml" | "html" | "xhtml" | "text" | <var>qname-but-not-ncname</var><br>&nbsp;&nbsp;version = <var>nmtoken</var><br>&nbsp;&nbsp;encoding = <var>string</var><br>&nbsp;&nbsp;omit-xml-declaration = "yes" | "no"<br>&nbsp;&nbsp;standalone = "yes" | "no"<br>&nbsp;&nbsp;doctype-public = <var>string</var><br>&nbsp;&nbsp;doctype-system = <var>string</var><br>&nbsp;&nbsp;cdata-section-elements = <var>qnames</var><br>&nbsp;&nbsp;escape-uri-attributes = "yes" | "no"<br>&nbsp;&nbsp;include-content-type = "yes" | "no"<br>&nbsp;&nbsp;indent = "yes" | "no"<br>&nbsp;&nbsp;media-type = <var>string</var><br>&nbsp;&nbsp;normalize-unicode = "yes" | "no"&nbsp;/&gt;</code></p><p>The <a href="#element-output"><code>xsl:output</code></a> declaration is optional; if used, it must always
 appear as a <a title="top-level" href="#dt-top-level">top-level</a> element within a stylesheet.</p><div><blockquote><p><b><a href="#issue-normalized-output">Issue 151 (normalized-output)</a>: </b>We have added an attribute <code>normalize-unicode="yes|no"</code> to allow
    users to request that the serialized output should be in unicode normalized form, but this
    needs to be reviewed against the W3C character model.</p></blockquote></div><p>A stylesheet may contain multiple <a href="#element-output"><code>xsl:output</code></a> declarations
and may include or import stylesheet modules that also contain
<a href="#element-output"><code>xsl:output</code></a> declarations. The name of an <a href="#element-output"><code>xsl:output</code></a> declaration
is the value of its <code>name</code> attribute, if any.
<a name="dt-output-definition" id="dt-output-definition" title="output definition"></a>All 
the <a href="#element-output"><code>xsl:output</code></a> declarations in a stylsheet
 that share the same name are grouped into a named <b>output definition</b>;
 those that have no name are grouped into a a single unnamed output definition.
			</p><p>A named output definition is used when its name matches the <code>format</code> attribute
used in an <a href="#element-result-document"><code>xsl:result-document</code></a> element. The unnamed output definition is used
when an <a href="#element-result-document"><code>xsl:result-document</code></a> element omits the <code>format</code> attribute.
It is also used when serializing the result tree that is created
implicitly in the absence of an <a href="#element-result-document"><code>xsl:result-document</code></a> element.</p><p>All the <a href="#element-output"><code>xsl:output</code></a>
elements making up an output definition are effectively merged. 
For the
<code>cdata-section-elements</code> attribute, the output definition uses
the union of the values from all the constituent <a href="#element-output"><code>xsl:output</code></a> declarations.  
For other attributes, the
output definition uses the value
 of that attribute from the 
<a href="#element-output"><code>xsl:output</code></a> declaration with the 
highest <a title="import precedence" href="#dt-import-precedence">import precedence</a>.
<a name="d5e17437"><small>[ERR150] </small></a>It is a 
<a title="dynamic error" href="#dt-dynamic-error">dynamic error</a>
if two <a href="#element-output"><code>xsl:output</code></a> declarations within an
<a title="output definition" href="#dt-output-definition">output definition</a> specify
explicit values for the same attribute (other than <code>cdata-section-elements</code>), 
with the values of the attributes being not equal, 
and with neither of these declarations being overridden
by an <a href="#element-output"><code>xsl:output</code></a> declaration with higher import precedence that specifies
an explicit value for the same attribute.
The <a title="processor" href="#dt-processor">processor</a> must either signal the error,
or must recover by using the value that occurs last in 
<a title="declaration order" href="#dt-declaration-order">declaration order</a>.

				
			</p><p>The values of attributes are defaulted after the
<a href="#element-output"><code>xsl:output</code></a> elements have been merged; different output
methods may have different default values for an attribute.</p><p>An implementation may allow the attributes of the <a href="#element-output"><code>xsl:output</code></a> declaration
to be overridden using the API that controls the transformation.</p><p> Before a final result tree
is serialized, <a title="namespace fixup" href="#dt-namespace-fixup">namespace fixup</a>
is performed (see <a href="#namespace-fixup"><b>4.4 Namespace Fixup</b></a>).</p><p>The location to which result trees are serialized (whether in filestore
or elsewhere) is <a title="implementation-defined" href="#dt-implementation-defined">implementation-defined</a>
(which in practice
may mean that it is controlled using an implementation-defined API). 
However, these locations must satisfy the constraint that
when two result trees are both created (implicitly or explicitly) using
relative URIs in the <code>href</code> attribute of the <a href="#element-result-document"><code>xsl:result-document</code></a> instruction, then
these relative URIs may be used to construct references from one tree to the other, and such references must remain
valid when both result trees are serialized.
				
			</p><p>The <code>method</code> attribute on the <a href="#element-output"><code>xsl:output</code></a> element
identifies the overall method that should be used for outputting the
result tree.  <a name="d5e17523"><small>[ERR151] </small></a>The value 

must be a valid <a title="QName" href="#dt-qname">QName</a>.  
If the <a title="QName" href="#dt-qname">QName</a> does not have a prefix, then it
identifies a method specified in this document and must be one of
<code>xml</code>, <code>html</code>, <code>xhtml</code>, 
 or <code>text</code>.  If the <a title="QName" href="#dt-qname">QName</a> has a prefix, then the <a title="QName" href="#dt-qname">QName</a> 
 is expanded into an <a title="expanded-QName" href="#dt-expanded-qname">expanded-QName</a> as described
in <a href="#qname"><b>5.1 Qualified Names</b></a>; the <a title="expanded-QName" href="#dt-expanded-qname">expanded-QName</a> identifies the output
method; the behavior in this case is not specified by this
document.</p><p>The default for the <code>method</code> attribute is chosen as
follows.  If the document node of the result tree has an element
child, and any text nodes preceding the first element child of the document
node of the result tree contain only whitespace characters, then:</p><ul><li><p>If the <a title="expanded-QName" href="#dt-expanded-qname">expanded-QName</a> of this first element child has local part
 <code>html</code> (in lower case), and namespace URI <code>http://www.w3.org/1999/xhtml</code>,
 then the default output method is <code>xhtml</code>.</p></li><li><p>If the <a title="expanded-QName" href="#dt-expanded-qname">expanded-QName</a> of this first element child has local part
<code>html</code> (in any combination of upper and lower case) and a
null namespace URI, then the default output method is <code>html</code>.</p></li></ul><p>In all other cases, the default output method
 is <code>xml</code>.</p><p>The default output method
should be used if there are no <a href="#element-output"><code>xsl:output</code></a> elements or if
none of the <a href="#element-output"><code>xsl:output</code></a> elements specifies a value for the
<code>method</code> attribute.</p><p>The other attributes on <a href="#element-output"><code>xsl:output</code></a> provide parameters
for the output method.  The following attributes are allowed:</p><ul><li><p>
						<code>encoding</code> specifies the preferred character
encoding that the <a title="processor" href="#dt-processor">processor</a> should use to encode sequences of
characters as sequences of bytes; the value of the attribute should be
treated case-insensitively; the value must contain only characters in
the range #x21 to #x7E (i.e. printable ASCII characters); the value
should either be a <code>charset</code> registered with the Internet
Assigned Numbers Authority <a href="#IANA">[IANA]</a>, <a href="#RFC2278">[RFC2278]</a> or start with <code>X-</code>
					</p></li><li><p>
						<code>cdata-section-elements</code> specifies a list of the
names of elements whose text node children should be output using
CDATA sections</p></li><li><p>
						<code>doctype-system</code> specifies the system identifier
to be used in the document type declaration</p></li><li><p>
						<code>doctype-public</code> specifies the public identifier
to be used in the document type declaration</p></li><li><p>
						<code>escape-uri-attributes</code> specifies whether the <a title="processor" href="#dt-processor">processor</a>
should escape URI-valued attributes in HTML and XHTML output using the 
method recommended in <a href="#RFC2396">[RFC2396]</a> (section 2.4.1).
The value must be
<code>yes</code> or <code>no</code>; the default is <code>yes</code>
					</p></li><li><p>
						<code>include-content-type</code> specifies whether the XSLT
<a title="processor" href="#dt-processor">processor</a> should add a <code>meta</code> element in HTML and XHTML output. The value must be
<code>yes</code> or <code>no</code>; the default is <code>yes</code>
					</p></li><li><p>
						<code>indent</code> specifies whether the <a title="processor" href="#dt-processor">processor</a> may
add additional whitespace when outputting the result tree; the value
must be <code>yes</code> or <code>no</code>
					</p></li><li><p>
						<code>media-type</code> specifies the media type (MIME
content type) of the data that results from outputting the result
tree; the <code>charset</code> parameter should not be specified
explicitly; instead, when the top-level media type is
<code>text</code>, a <code>charset</code> parameter should be added
according to the character encoding actually used by the output
method</p></li><li><p><code>normalize-unicode</code> indicates whether or not the 
					XSLT processor should convert the serialized output
					to Unicode Normalization Form C as specified in
					<a href="#UNICODE-NORMALIZATION">[Unicode Normalization]</a>. The value must be <code>yes</code> or <code>no</code>;
					the default is <code>no</code></p></li><li><p>
						<code>omit-xml-declaration</code> specifies whether the XSLT
<a title="processor" href="#dt-processor">processor</a> should output an XML declaration; the value must be
<code>yes</code> or <code>no</code>
					</p></li><li><p>
						<code>standalone</code> specifies whether the <a title="processor" href="#dt-processor">processor</a>
should output a standalone document declaration; the value must be
<code>yes</code> or <code>no</code>
					</p></li><li><p><code>version</code> specifies the version of the output method</p></li></ul><p>The detailed semantics of each attribute will be described
separately for each output method for which it is applicable.  If the
semantics of an attribute are not described for an output method, then
it is not applicable to that output method.</p><div class="div2">
<h3><a name="xml-output" id="xml-output"></a>20.1 XML Output Method</h3><p>The <code>xml</code> output method outputs the result tree as 
an XML entity that should satisfy the rules for either 
a well-formed XML document entity, or a
well-formed XML external general parsed entity, or both.
If the document node of
the result tree has a single element node child and no text node
children, then the serialized output should be a well-formed XML document
entity conforming to
the XML Namespaces Recommendation <a href="#XMLNAMES">[XML Names]</a>. 
If the result tree does not take this form, then the 
serialized output should be an entity which, when 
referenced within a trivial XML document
wrapper like this</p><div class="exampleInner"><pre>
&lt;!DOCTYPE doc [
&lt;!ENTITY e SYSTEM "<em>entity-URI</em>"&gt;
]&gt;
&lt;doc&gt;&amp;e;&lt;/doc&gt;</pre></div><p>where <code>
						<var>entity-URI</var>
					</code> is a URI for the entity,
produces a 
document which should itself be a well-formed XML document conforming to
the XML Namespaces Recommendation <a href="#XMLNAMES">[XML Names]</a>.</p><p>In
addition, the output should be such that if a new tree was constructed
by parsing the XML document as specified in 
<a href="#data-model"><b>4 Data Model</b></a>, then the new tree would
be the same as the result tree, with the following possible
exceptions:</p><ul><li><p>If the document was produced by adding a document wrapper,
as described above,
then it will contain an extra <code>doc</code> element as the document element.</p></li><li><p>The order of attribute and
namespace nodes in the two trees may be different.</p></li><li><p>The base URIs of nodes in the two
trees may be different.</p></li><li><p>The new tree may contain additional attributes resulting
from the expansion of default values in its DTD or schema.</p></li></ul><p>A consequence of this rule is that certain whitespace characters
should be output as character references, to ensure that they survive the round trip
through serialization and parsing. Specifically, CR characters in text nodes should be
written as <code>&amp;#xD;</code> or an equivalent; while CR, NL, and TAB characters in attribute
nodes should be output respectively as <code>&amp;#xD;</code>, 
<code>&amp;#xA;</code>, and <code>&amp;#x9;</code>, or
their equivalents.</p><div class="example"><p>For example,</p><div class="exampleInner"><pre>&lt;xsl:attribute name="a"&gt;x
y&lt;/xsl:attribute&gt;</pre></div><p>will result in the output</p><div class="exampleInner"><pre>a="x&amp;#xA;y"</pre></div><p>(or with any equivalent character reference). The XML output cannot
be</p><div class="exampleInner"><pre>a="x
y"</pre></div><p>because after parsing, the attribute value would be <code>a="x y"</code> as
a consequence of the XML attribute normalization rules.</p></div><blockquote><table width="90%"><tr><td width="10%" align="left" valign="top"><b>Note:</b></td><td align="left" valign="top"><p>To anticipate the proposed changes to end-of-line handling in XML 1.1, implementations
may also output the characters x85 and x2028 as character references. This will not affect the
way they are interpreted by an XML 1.0 parser.</p></td></tr></table></blockquote><div><blockquote><p><b><a href="#issue-result-tree-PSVI">Issue 83 (result-tree-PSVI)</a>: </b>The rules for serialization of the result tree consider it only as an infoset; 
      the rules need to be enhanced to allow for (potential loss of) PSVI information on the tree.</p></blockquote></div><p>
					<a name="d5e17868"><small>[ERR152] </small></a>It is a
 <a title="serialization error" href="#dt-serialization-error">serialization error</a>
 to request the output of a document type declaration, or of a  
 <code>standalone</code> attribute, if the result tree contains
 text nodes or multiple element nodes as children of the root node.
 The processor may signal the error, or may recover
 by ignoring the request to output a document type declaration
 or <code>standalone</code> attribute.
					
				</p><p>The <code>version</code> attribute specifies the version of XML to
be used for outputting the result tree.  If the <a title="processor" href="#dt-processor">processor</a> does
not support this version of XML, it should use a version of XML that
it does support.  The version output in the XML declaration (if an XML
declaration is output) should correspond to the version of XML that
the processor used for outputting the result tree. The value of the
<code>version</code> attribute should match the <u>VersionNum</u> production of the XML
Recommendation <a href="#XML">[XML]</a>. The default value is
<code>1.0</code>.</p><p>The <code>encoding</code> attribute specifies the preferred
encoding to use for outputting the result tree.  Processors are
required to respect values of <code>UTF-8</code> and
<code>UTF-16</code>.  
<a name="d5e17913"><small>[ERR153] </small></a>A <a title="serialization error" href="#dt-serialization-error">serialization error</a>
occurs when an output encoding other than <code>UTF-8</code> or <code>UTF-16</code> is requested,
if the implementation does not support that encoding. 
The <a title="processor" href="#dt-processor">processor</a> may
signal the error, or may recover by using <code>UTF-8</code> or
<code>UTF-16</code> instead.
					 
The <a title="processor" href="#dt-processor">processor</a> must not use an
encoding whose name does not match the <u>EncName</u> production of the XML
Recommendation <a href="#XML">[XML]</a>.  If no <code>encoding</code>
attribute is specified, then the processor should use either
<code>UTF-8</code> or <code>UTF-16</code>.</p><p>When outputting a newline character in the result tree,
the implementation is free to represent it using any character sequence that will
be normalized to a newline character by an XML parser.</p><p>When outputting any other character that is defined in the
selected encoding, the character should be output
using the correct representation of that character in the selected encoding.</p><p>It is possible that the
result tree will contain a character that cannot be represented in the
encoding that the processor is using for output.  In this case,
if the character occurs in a context where XML recognizes character
references (that is, in the value of an attribute node or text node), then
the character should be output as a character reference. 
<a name="d5e17960"><small>[ERR154] </small></a>A <a title="serialization error" href="#dt-serialization-error">serialization error</a>
occurs if such a character

appears in a context where character references are not allowed
(for example if the character occurs in the name of an element).
The
<a title="processor" href="#dt-processor">processor</a> should signal the 
error.
					
				</p><p>If the <code>indent</code> attribute has the value
<code>yes</code>, then the <code>xml</code> output method may output
whitespace in addition to the whitespace in the result tree (possibly
based on whitespace stripped from either the source document or the
stylesheet) in order to indent the result nicely; if the
<code>indent</code> attribute has the value <code>no</code>, it should
not output any additional whitespace. The default value is
<code>no</code>.  The <code>xml</code> output method should use an
algorithm to output additional whitespace that ensures that the result
if whitespace were to be stripped from the output using the process
described in <a href="#strip"><b>4.3 Whitespace Stripping</b></a> with the set of
whitespace-preserving elements consisting of just
<a href="#element-text"><code>xsl:text</code></a> would be the same when additional whitespace is
output as when additional whitespace is not output.</p><blockquote><table width="90%"><tr><td width="10%" align="left" valign="top"><b>Note:</b></td><td align="left" valign="top"><p>It is usually not safe to use <code>indent="yes"</code> with
document types that include element types with mixed content.</p></td></tr></table></blockquote><p>The <code>cdata-section-elements</code> attribute contains a
whitespace-separated list of <a title="QName" href="#dt-qname">QName</a>s.  Each <a title="QName" href="#dt-qname">QName</a> is expanded into an
<a title="expanded-QName" href="#dt-expanded-qname">expanded-QName</a> using the namespace declarations in effect on the
<a href="#element-output"><code>xsl:output</code></a> element in which the <a title="QName" href="#dt-qname">QName</a> occurs; if there is a default
namespace, it is used for <a title="QName" href="#dt-qname">QName</a>s
that do not have a prefix.  The expansion is performed before the
merging of multiple <a href="#element-output"><code>xsl:output</code></a> elements into a single
effective <a href="#element-output"><code>xsl:output</code></a> element. If the <a title="expanded-QName" href="#dt-expanded-qname">expanded-QName</a> of the
parent of a text node is a member of the list, then the text node
should be output as a CDATA section.</p><div class="example"><p>For example,</p><div class="exampleInner"><pre>&lt;xsl:output cdata-section-elements="example"/&gt;</pre></div><p>would cause a <a title="literal result element" href="#dt-literal-result-element">literal result element</a> written in the stylesheet as</p><div class="exampleInner"><pre>&lt;example&gt;&amp;lt;foo&gt;&lt;/example&gt;</pre></div><p>or as</p><div class="exampleInner"><pre>&lt;example&gt;&lt;![CDATA[&lt;foo&gt;]]&gt;&lt;/example&gt;</pre></div><p>to be output as             </p><div class="exampleInner"><pre>&lt;example&gt;&lt;![CDATA[&lt;foo&gt;]]&gt;&lt;/example&gt;</pre></div></div><p>If the text node contains the sequence of characters
<code>]]&gt;</code>, then the currently open CDATA section should be
closed following the <code>]]</code> and a new CDATA section opened
before the <code>&gt;</code>.</p><div class="example"><p>For example, a literal result element
written in the stylesheet as</p><div class="exampleInner"><pre>&lt;example&gt;]]&amp;gt;&lt;/example&gt;</pre></div><p>would be output as</p><div class="exampleInner"><pre>&lt;example&gt;&lt;![CDATA[]]]]&gt;&lt;![CDATA[&gt;]]&gt;&lt;/example&gt;</pre></div></div><p>If the text node contains characters that are not representable in
the character encoding being used to output the result tree, then the
currently open CDATA section should be closed before such characters,
the characters should be output using character references or entity
references, and a new CDATA section should be opened for any further
characters in the text node.</p><p>CDATA sections should not be used except where they have been
explicitly requested by the user, either by using the
<code>cdata-section-elements</code> attribute,
or by using some other <a title="implementation-defined" href="#dt-implementation-defined">implementation-defined</a>
 mechanism.</p><blockquote><table width="90%"><tr><td width="10%" align="left" valign="top"><b>Note:</b></td><td align="left" valign="top"><p>This is phrased to permit an implementor to provide an option that
attempts to preserve CDATA sections present in the source document.</p></td></tr></table></blockquote><p>The <code>xml</code> output method should output an XML declaration
unless the <code>omit-xml-declaration</code> attribute has the value
<code>yes</code>. The XML declaration should include both version
information and an encoding declaration. If the
<code>standalone</code> attribute is specified, it should include a
standalone document declaration with the same value as the value as
the value of the <code>standalone</code> attribute.  Otherwise, it
should not include a standalone document declaration; this ensures
that it is both an XML
declaration (allowed at the beginning of a document entity) and a text
declaration (allowed at the beginning of an external general parsed
entity).</p><p>The <code>omit-xml-declaration</code> attribute
should be ignored if the <code>standalone</code> attribute is present, or if
 the <code>encoding</code> attribute specifies a value other than UTF-8 or UTF-16.</p><p>If the <code>doctype-system</code> attribute is specified, the
<code>xml</code> output method should output a document type
declaration immediately before the first element.  The name following
<code>&lt;!DOCTYPE</code> should be the name of the first element.  If
<code>doctype-public</code> attribute is also specified, then the
<code>xml</code> output method should output <code>PUBLIC</code>
followed by the public identifier and then the system identifier;
otherwise, it should output <code>SYSTEM</code> followed by the system
identifier.  The internal subset should be empty.  The
<code>doctype-public</code> attribute should be ignored unless the
<code>doctype-system</code> attribute is specified.</p><p>The <code>media-type</code> attribute is applicable for the
<code>xml</code> output method.  The default value for the
<code>media-type</code> attribute is <code>text/xml</code>.</p><p>The <code>unicode-normalization</code> attribute is applicable for the
<code>xml</code> output method.</p></div><div class="div2">
<h3><a name="xhtml-output" id="xhtml-output"></a>20.2 XHTML Output Method</h3><p>The <code>xhtml</code> output method serializes the result
tree as XML, using the HTML compatibility guidelines defined in
 the XHTML specification.</p><p>It is entirely the responsibility of the stylesheet author to
ensure that the result tree conforms to the <a href="#XHTML10">[XHTML 1.0]</a> 
or <a href="#XHTML11">[XHTML 1.1]</a>
specification. It is not an error if the result tree is invalid XHTML.
Equally, it is entirely under the control of the stylesheet author
whether the output conforms to XHTML Strict, XHTML Transitional, XHTML Frameset,
or XHTML Basic.</p><blockquote><table width="90%"><tr><td width="10%" align="left" valign="top"><b>Note:</b></td><td align="left" valign="top"><p>A result tree can be validated against the relevant
schema by specifying <code>type-information="strict"</code> on the 
<a href="#element-result-document"><code>xsl:result-document</code></a> instruction.</p></td></tr></table></blockquote><p>The serialization of the result tree follows the same rules 
as for the <code>xml</code> output method, with the exceptions noted
below. These differences are based on the HTML compatibility guidelines 
published in Appendix C of <a href="#XHTML10">[XHTML 1.0]</a>, which are
designed to ensure that as far as possible, XHTML is rendered correctly on
user agents designed originally to handle HTML.</p><ul><li><p>Given an empty instance of an XHTML element whose 
content model is not EMPTY (for example, an empty title or paragraph)
 the serializer should not use the minimized form. That is, it should output
  <code>&lt;p&gt; &lt;/p&gt;</code> 
 and not <code>&lt;p&nbsp;&nbsp;/&gt;</code>. </p></li><li><p>
							
Given an XHTML element whose content model is EMPTY, the 
 serializer should use the minimized tag syntax,
   for example <code>&lt;br&nbsp;&nbsp;/&gt;</code>, as the alternative syntax
   <code>&lt;br&gt;&lt;/br&gt;</code> allowed by XML gives uncertain results
    in many existing user agents. 
    The serializer should include a space before the trailing
<code>/&gt;</code>
							,
 e.g. <code>&lt;br&nbsp;&nbsp;/&gt;</code>, <code>&lt;hr&nbsp;&nbsp;/&gt;</code> and
  <code>&lt;img&nbsp;&nbsp;src="karen.jpg"&nbsp;&nbsp;alt="Karen"&nbsp;&nbsp;/&gt;</code>.</p></li><li><p>The serializer should avoid outputting line breaks and
 multiple whitespace characters within attribute values.
 These are handled inconsistently by user agents.</p></li><li><p>The serializer should avoid use of the entity reference
 <code>&amp;apos;</code> which, although legal in XML and therefore in XHTML, is
 not defined in HTML and is not recognized by all HTML user agents.</p></li><li><p>If the result tree includes a <code>head</code> element
in the XHTML namespace, then 
unless the <code>include-content-type</code>
attribute is present and has the value <code>"no"</code>,
the
<code>xhtml</code> output method should add a <code>meta</code> element
immediately after the start-tag of the <code>head</code> element
specifying the character encoding actually used.</p><div class="example"><p>For example,</p><div class="exampleInner"><pre>&lt;head&gt;
&lt;meta http-equiv="Content-Type" content="text/html; charset=EUC-JP"&gt;
...</pre></div></div><p>The content type should be set to
the value given for the <code>media-type</code> attribute;
 the default value for XHTML is <code>text/html</code>.
 The value <code>application/xhtml+xml</code>, registered in
 <a href="#RFC3236">[RFC3236]</a>, may also be used.</p></li><li><p>Unless the <code>escape-uri-attributes</code> attribute
is present and has the value <code>no</code>, the <code>html</code> output method should escape non-ASCII
characters in URI attribute values using the method recommended in
<a href="#RFC2396">[RFC2396]</a> (section 2.4.1).</p></li></ul><blockquote><table width="90%"><tr><td width="10%" align="left" valign="top"><b>Note:</b></td><td align="left" valign="top"><p>This escaping is deliberately confined to non-ASCII characters, because
escaping of ASCII characters is not always appropriate, for example when URIs or URI fragments
are interpreted locally by the HTML user agent. Even in the case of non-ASCII characters, escaping
can sometimes cause problems. More precise control of URI escaping is therefore
available by setting <code>escape-uri-attributes</code> to <code>no</code>, and
controlling the escaping of URIs by means of the <u>fn:escape-uri</u> function 
defined in <a href="#FANDO">[Functions and Operators]</a>.</p></td></tr></table></blockquote></div><div class="div2">
<h3><a name="d5e18332" id="d5e18332"></a>20.3 HTML Output Method</h3><p>The <code>html</code> output method outputs the result tree as
HTML.</p><div class="example"><p>For example,</p><div class="exampleInner"><pre>&lt;xsl:stylesheet version="2.0"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

&lt;xsl:output method="html"/&gt;

&lt;xsl:template match="/"&gt;
  &lt;html&gt;
   &lt;xsl:apply-templates/&gt;
  &lt;/html&gt;
&lt;/xsl:template&gt;

...

&lt;/xsl:stylesheet&gt;</pre></div></div><p>The <code>version</code> attribute indicates the version of the
HTML.  The default value is <code>4.0</code>, which specifies that the
result should be output as HTML conforming to the HTML 4.0
Recommendation <a href="#HTML">[HTML]</a>.</p><p>The <code>html</code> output method should not output an element
differently from the <code>xml</code> output method unless the
<a title="expanded-QName" href="#dt-expanded-qname">expanded-QName</a> of the element has a null namespace URI; an element
whose <a title="expanded-QName" href="#dt-expanded-qname">expanded-QName</a> has a non-null namespace URI should be output as
XML.  If the <a title="expanded-QName" href="#dt-expanded-qname">expanded-QName</a> of the element has a null namespace URI,
but the local part of the <a title="expanded-QName" href="#dt-expanded-qname">expanded-QName</a> is not recognized as the name
of an HTML element, the element should output in the same way as a
non-empty, inline element such as <code>span</code>.</p><p>The <code>html</code> output method should not output an end-tag
for empty elements.  For HTML 4.0, the empty elements are
<code>area</code>, <code>base</code>, <code>basefont</code>,
<code>br</code>, <code>col</code>, <code>frame</code>,
<code>hr</code>, <code>img</code>, <code>input</code>,
<code>isindex</code>, <code>link</code>, <code>meta</code> and
<code>param</code>. For example, an element written as
<code>&lt;br/&gt;</code> or <code>&lt;br&gt;&lt;/br&gt;</code> in the
stylesheet should be output as <code>&lt;br&gt;</code>.</p><p>The <code>html</code> output method should recognize the names of
HTML elements regardless of case.  For example, elements named
<code>br</code>, <code>BR</code> or <code>Br</code> should all be
recognized as the HTML <code>br</code> element and output without an
end-tag.</p><p>The <code>html</code> output method should not perform escaping for
the content of the <code>script</code> and <code>style</code>
elements.</p><div class="example"><p>For example, a literal result element written in the
stylesheet as</p><div class="exampleInner"><pre>&lt;script&gt;if (a &amp;lt; b) foo()&lt;/script&gt;</pre></div><p>or</p><div class="exampleInner"><pre>&lt;script&gt;&lt;![CDATA[if (a &lt; b) foo()]]&gt;&lt;/script&gt;</pre></div><p>should be output as</p><div class="exampleInner"><pre>&lt;script&gt;if (a &lt; b) foo()&lt;/script&gt;</pre></div></div><p>The <code>html</code> output method should not escape
<code>&lt;</code> characters occurring in attribute values.</p><p>If the <code>indent</code> attribute has the value
<code>yes</code>, then the <code>html</code> output method may add or
remove whitespace as it outputs the result tree, so long as it does
not change how an HTML user agent would render the output.  The
default value is <code>yes</code>.</p><p>Unless the <code>escape-uri-attributes</code> attribute
is present and has the value <code>no</code>, the <code>html</code> output method should escape non-ASCII
characters in URI attribute values using the method recommended in
<a href="#RFC2396">[RFC2396]</a> (section 2.4.1).</p><blockquote><table width="90%"><tr><td width="10%" align="left" valign="top"><b>Note:</b></td><td align="left" valign="top"><p>This escaping is deliberately confined to non-ASCII characters, because
escaping of ASCII characters is not always appropriate, for example when URIs or URI fragments
are interpreted locally by the HTML user agent. Even in the case of non-ASCII characters, escaping
can sometimes cause problems. More precise control of URI escaping is therefore
available by setting <code>escape-uri-attributes</code> to <code>no</code>, and
controlling the escaping of URIs by means of the <u>fn:escape-uri</u> function 
defined in <a href="#FANDO">[Functions and Operators]</a>.</p></td></tr></table></blockquote><p>The <code>html</code> output method may output a character using a
character entity reference in preference to using a numeric character reference, 
if an entity is defined for the character in the version of
HTML that the output method is using. Entity references and character references
should be used only where the character is not present in the selected encoding, or
where the visual representation of the character is unclear (as with <code>&amp;nbsp;</code>,
for example).</p><p>When outputting a sequence of whitespace characters in the result tree,
within an element where whitespace is treated normally, (but not in
elements such as <code>pre</code> and <code>textarea</code>)
the <code>html</code> output method is free to represent it using any character sequence that will
be treated as whitespace by an HTML user agent.</p><p>The <code>html</code> output method should terminate processing
instructions with <code>&gt;</code> rather than
<code>?&gt;</code>.</p><p>The <code>html</code> output method should output boolean
attributes (that is attributes with only a single allowed value that
is equal to the name of the attribute) in minimized form.</p><div class="example"><p>For example,
a start-tag written in the stylesheet as</p><div class="exampleInner"><pre>&lt;OPTION selected="selected"&gt;</pre></div><p>should be output as</p><div class="exampleInner"><pre>&lt;OPTION selected&gt;</pre></div></div><p>The <code>html</code> output method should not escape a
<code>&amp;</code> character occurring in an attribute value
immediately followed by a <code>{</code> character (see <a href="http://www.w3.org/TR/REC-html40/appendix/notes.html#h-B.7.1.1">Section
B.7.1</a> of the HTML 4.0 Recommendation).</p><div class="example"><p>For example, a start-tag
written in the stylesheet as</p><div class="exampleInner"><pre>&lt;BODY bgcolor='&amp;amp;{{randomrbg}};'&gt;</pre></div><p>should be output as</p><div class="exampleInner"><pre>&lt;BODY bgcolor='&amp;{randomrbg};'&gt;</pre></div></div><p>The <code>encoding</code> attribute specifies the preferred
encoding to be used. If there is a <code>HEAD</code> element, then 
unless the <code>include-content-type</code>
attribute is present and has the value <code>"no"</code>,
the
<code>html</code> output method should add a <code>META</code> element
immediately after the start-tag of the <code>HEAD</code> element
specifying the character encoding actually used.</p><div class="example"><p>For example,</p><div class="exampleInner"><pre>&lt;HEAD&gt;
&lt;META http-equiv="Content-Type" content="text/html; charset=EUC-JP"&gt;
...</pre></div></div><p>The content type should be set to
the value given for the <code>media-type</code> attribute;
 the default value is <code>text/html</code>.</p><p>
					<a name="d5e18629"><small>[ERR155] </small></a>It is possible that the result tree 
will contain a character that
cannot be represented in the encoding that the <a title="processor" href="#dt-processor">processor</a> is using
for output.  In this case, if the character occurs in a context where
HTML recognizes character references, then the character should be
output as a character entity reference or decimal numeric character
reference; otherwise (for example, in a
<code>script</code> or <code>style</code> element or in a comment),
the processor should signal a
 <a title="serialization error" href="#dt-serialization-error">serialization error</a>.
				</p><p>If the <code>doctype-public</code> or <code>doctype-system</code>
attributes are specified, then the <code>html</code> output method
should output a document type declaration immediately before the first
element.  The name following <code>&lt;!DOCTYPE</code> should be
<code>HTML</code> or <code>html</code>.  If the
<code>doctype-public</code> attribute is specified, then the output
method should output <code>PUBLIC</code> followed by the specified
public identifier; if the <code>doctype-system</code> attribute is
also specified, it should also output the specified system identifier
following the public identifier.  If the <code>doctype-system</code>
attribute is specified but the <code>doctype-public</code> attribute
is not specified, then the output method should output
<code>SYSTEM</code> followed by the specified system identifier.</p><p>The <code>media-type</code> attribute is applicable for the
<code>html</code> output method.  The default value is
<code>text/html</code>.</p><p>The <code>unicode-normalization</code> attribute is applicable for the
<code>html</code> output method.</p></div><div class="div2">
<h3><a name="d5e18701" id="d5e18701"></a>20.4 Text Output Method</h3><p>The <code>text</code> output method outputs the result tree by
outputting the string-value of every text node in the result tree in
document order without any escaping.</p><p>A newline character in the result tree may be output using
any character sequence that is conventionally used to represent a line ending
in the chosen system environment.</p><p>The <code>media-type</code> attribute is applicable for the
<code>text</code> output method.  The default value for the
<code>media-type</code> attribute is <code>text/plain</code>.</p><p>The <code>encoding</code> attribute identifies the encoding that
the <code>text</code> output method should use to convert sequences of
characters to sequences of bytes.  The default is system-dependent. 
<a name="d5e18733"><small>[ERR156] </small></a>If
the result tree contains a character that cannot be represented in the
encoding that the <a title="processor" href="#dt-processor">processor</a> is using for output, the implementation
 should signal a <a title="serialization error" href="#dt-serialization-error">serialization error</a>.

				</p><p>The <code>unicode-normalization</code> attribute is applicable for the
<code>text</code> output method.</p></div><div class="div2">
<h3><a name="disable-output-escaping" id="disable-output-escaping"></a>20.5 Disabling Output Escaping</h3><p>Normally, the <code>xml</code> output method escapes special
characters such as <code>&amp;</code> and <code>&lt;</code>
when outputting text and attribute nodes.  This
ensures that the output is well-formed XML. However, it is sometimes
convenient to be able to produce output that is almost, but not quite
well-formed XML; for example, the output may include ill-formed
sections which are intended to be transformed into well-formed XML by
a subsequent non-XML-aware process.  For this reason, XSLT provides a
mechanism for disabling output escaping.</p><p>An <a href="#element-value-of"><code>xsl:value-of</code></a>
or <a href="#element-text"><code>xsl:text</code></a> element may have a
<code>disable-output-escaping</code> attribute; the allowed values are
<code>yes</code> or <code>no</code>; the default is <code>no</code>;
if the value is <code>yes</code>, then a text node generated by
evaluating the <a href="#element-value-of"><code>xsl:value-of</code></a> or <a href="#element-text"><code>xsl:text</code></a>
element should be output without any escaping.</p><div class="example"><p>For example,</p><div class="exampleInner"><pre>&lt;xsl:text disable-output-escaping="yes"&gt;&amp;lt;&lt;/xsl:text&gt;</pre></div><p>should generate the single character <code>&lt;</code>.</p></div><p>
					<a name="d5e18808"><small>[ERR157] </small></a>It is a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> for
 output escaping to be disabled for a text node
that is used for something other than a text node in the result tree.
Thus, it is an error to disable output escaping for an
<a href="#element-value-of"><code>xsl:value-of</code></a> or <a href="#element-text"><code>xsl:text</code></a> element that is
used to generate the string-value of a comment, processing instruction
or attribute node; it is also a
 <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> to convert a node to a 
 number or a string if the node is, or contains, a text node for which escaping
was disabled.  In both cases, the <a title="processor" href="#dt-processor">processor</a> must either signal the error,
or must recover by ignoring the
<code>disable-output-escaping</code> attribute.
					
				</p><div><blockquote><p><b><a href="#issue-conversion-with-d-o-e">Issue 124 (conversion-with-d-o-e)</a>: </b>The rule prohibiting conversion of a text node to a string or number when the text node
      contains a "sticky d-o-e bit" needs revising, it was originally written for XSLT 1.0 before
      the operations available on temporary trees were generalized.</p></blockquote></div><blockquote><table width="100%"><tr><td width="10%" align="left" valign="top"><b>Ed. Note:</b></td><td align="left" valign="top">The above paragraph will change: see the resolution of the
				referenced issue.</td></tr></table></blockquote><p>Text nodes for which escaping is disabled are subject to
merging with text nodes that are adjacent in the result tree in the
same way as text nodes for which is escaping is not disabled.  An
element or document node in the result tree never has two consecutive text
node children. Thus, it is possible for escaping to be disabled for
some but not all of the characters in a text node.</p><p>Output escaping can be disabled for an attribute node
by specifying <code>disable-output-escaping="yes"</code> on the <a href="#element-attribute"><code>xsl:attribute</code></a>
instruction. It is not possible to disable escaping of some characters in the attribute
value while allowing escaping of others.</p><p>When output escaping is disabled for an attribute node, the serializer should use quotation
marks to delimit the attribute value if it contains an apostrophe, and should use apostrophes to
delimit the value if it contains a quotation mark. If it contains both quotations marks and
apostrophes, or if it contains neither, then the serializer may use either character as the
delimiter.</p><p>When output escaping is disabled for an attribute, the escaping of special characters
in URI values that is normally performed by the HTML and XHTML output methods will also be disabled.</p><div class="example"><p>For example,</p><div class="exampleInner"><pre>&lt;jsp:setProperty name="user" property="id"&gt;
  &lt;xsl:attribute name="value" disable-output-escaping="yes"&gt;
    &lt;xsl:text&gt;&amp;lt;%= "id" + idValue %&amp;gt&lt;/xsl:text&gt;
  &lt;/xsl:attribute&gt;
&lt;/jsp:setProperty&gt;</pre></div><p>should generate the output:</p><div class="exampleInner"><pre>&lt;jsp:setProperty name="user" property="id" value='&lt;%= "id" + idValue %&gt;'/&gt;</pre></div><p>Although this output is not well-formed XML or HTML, it is valid in Java Server Pages.</p></div><p>When a text or attribute node is copied, either by
using <a href="#element-copy"><code>xsl:copy</code></a> or by applying 
<a href="#element-copy-of"><code>xsl:copy-of</code></a> to that node or one of its ancestors, and when
escaping was disabled for some or all of the characters within that  node,
then escaping should also be disabled for the resulting copy of those characters.
 For example</p><div class="exampleInner"><pre>&lt;xsl:variable name="x"&gt;
&lt;xsl:text disable-output-escaping="yes"&gt;&amp;lt;&lt;/xsl:text&gt;
&lt;/xsl:variable&gt;
&lt;xsl:copy-of select="$x"/&gt;</pre></div><p>should output <code>&lt;</code> not
<code>&amp;lt;</code>.</p><p>The <code>disable-output-escaping</code> attribute may be used with
the <code>html</code> output method as well as with the
<code>xml</code> output method.  The <code>text</code> output method
ignores the <code>disable-output-escaping</code> attribute, since it
does not perform any output escaping.</p><p>A <a title="processor" href="#dt-processor">processor</a> will only be able to disable output escaping if
it controls how the result tree is output. This might not always be the
case.  For example, the result tree might be used as the source tree for
another XSLT transformation instead of being output.  
It is <a title="implementation-defined" href="#dt-implementation-defined">implementation-defined</a>
whether (and under what circumstances) disabling output escaping is supported.
 <a name="d5e18910"><small>[ERR158] </small></a>It is 
 a <a title="serialization error" href="#dt-serialization-error">serialization error</a>
 if an
<a href="#element-value-of"><code>xsl:value-of</code></a> or <a href="#element-text"><code>xsl:text</code></a> instruction specifies that
output escaping should be disabled and the implementation does not
support this. The <a title="processor" href="#dt-processor">processor</a> must either signal the error,
of must recover by not disabling output escaping.
					
				</p><p>
					<a name="d5e18932"><small>[ERR159] </small></a>It is 
 a <a title="serialization error" href="#dt-serialization-error">serialization error</a>
if output escaping is disabled for a character that is not
representable in the encoding that the <a title="processor" href="#dt-processor">processor</a> is using for
output. The processor must either signal the error,
of must recover by not disabling output escaping.
					
				</p><p>Since disabling output escaping might not work with all implementations
 and can result in XML that is not well-formed, it should be
used only when there is no alternative.</p></div></div><div class="div1">
<h2><a name="conformance" id="conformance"></a>21 Conformance</h2><blockquote><table width="100%"><tr><td width="10%" align="left" valign="top"><b>Ed. Note:</b></td><td align="left" valign="top">The XSL Working Group intends to define a conformance 
level for XSLT processors that do not perform
any schema processing. The detailed rules for such a processor have yet to be defined. It is likely that
such a processor will be expected to reject any <a href="#element-import-schema"><code>xsl:import-schema</code></a> declaration, but to
recognize the built-in types of XML Schema. The processor will either reject or ignore any non-trivial
type annotations on element and attribute nodes in the source document, and will reject or ignore any attempt to
attach type annotations to result trees or temporary trees, either directly or by invoking schema
validation.</td></tr></table></blockquote><p>A conforming <a title="processor" href="#dt-processor">processor</a> must be able to use a stylesheet to
transform source trees into result trees as specified in this document.  A
conforming processor need not be able to serialize the result in XML
or in any other form.</p><blockquote><table width="100%"><tr><td width="10%" align="left" valign="top"><b>Ed. Note:</b></td><td align="left" valign="top">The XSL Working Group has decided in principle to define a separate
conformance module for serialization: XSLT processors will not be required to provide a serializer, but
a processor that claims conformance to this module will be required to do serialization as defined
in this specification.</td></tr></table></blockquote><blockquote><table width="90%"><tr><td width="10%" align="left" valign="top"><b>Note:</b></td><td align="left" valign="top"><p>Implementations are strongly encouraged to provide
a way to verify that the <a title="processor" href="#dt-processor">processor</a> is behaving conformingly by
allowing result trees to be output as XML or by providing access to
result trees through a standard API such as the DOM or
SAX.</p></td></tr></table></blockquote><p>A conforming <a title="processor" href="#dt-processor">processor</a> must signal any 
errors except for those
that this document specifically allows a processor not to
signal. A conforming processor may continue after signaling
an error, but if it does so, it must either take the recovery action defined in
this document, or it must eventually terminate without producing a result tree.</p><p>However, a processor will not be considered
as failing to conform to this specification solely because it implements 
constructs that are introduced in a later version of this specification.</p><blockquote><table width="90%"><tr><td width="10%" align="left" valign="top"><b>Note:</b></td><td align="left" valign="top"><p>This means that a processor that implements all of version 2.0 and
a few features of version 3.0 can claim conformance with XSLT 2.0. This differs from
the situation with XSLT 1.0, where implementing selected XSLT 2.0 constructs makes
a processor technically non-conformant with XSLT 1.0.</p></td></tr></table></blockquote><p>A conforming processor may impose limits on the processing
resources consumed by the processing of a stylesheet.</p><div><blockquote><p><b><a href="#issue-conformance-modules">Issue 86 (conformance-modules)</a>: </b>Should we introduce multiple conformance levels or modules, recognizing that serialization 
      is a separate specification to which processors may or may not conform?</p></blockquote></div></div></div><div class="back"><div class="div1">
<h2><a name="references" id="references"></a>A References</h2><div class="div2">
<h3><a name="d5e18986" id="d5e18986"></a>A.1 Normative References</h3><dl><dt class="label"><a name="DATAMODEL" id="DATAMODEL"></a>Data Model</dt><dd>World Wide Web Consortium. 
<em>XQuery 1.0 and XPath 2.0 Data Model</em> W3C Working Draft. 
See <a href="http://www.w3.org/TR/query-datamodel/">http://www.w3.org/TR/query-datamodel/</a>
					</dd><dt class="label"><a name="FANDO" id="FANDO"></a>Functions and Operators</dt><dd>World Wide Web Consortium. 
<em>XQuery 1.0 and XPath 2.0 Functions and Operators.</em>
W3C Working Draft. 
See <a href="http://www.w3.org/TR/xquery-operators/">http://www.w3.org/TR/xquery-operators/</a>
					</dd><dt class="label"><a name="DOM2"></a>DOM2</dt><dd>World Wide Web Consortium. <em>Document
Object Model (DOM) Level 2 Core Specification.</em> W3C Recommendation. 
See <a href="http://www.w3.org/TR/DOM-Level-2-Core/">http://www.w3.org/TR/DOM-Level-2-Core/</a>
					</dd><dt class="label"><a name="UNICODE-NORMALIZATION" id="UNICODE-NORMALIZATION"></a>Unicode Normalization</dt><dd>Unicode Consortium.
					<em>Unicode Normalization Forms</em>. Unicode Standard Annex #15.
					See <a href="http://www.unicode.org/unicode/reports/tr15/">http://www.unicode.org/unicode/reports/tr15/</a>
					</dd><dt class="label"><a name="XHTML10" id="XHTML10"></a>XHTML 1.0</dt><dd>World Wide Web Consortium. <em>XHTML
1.0: The Extensible HyperText Markup Language.</em> W3C Recommendation. 
See <a href="http://www.w3.org/TR/xhtml1/">http://www.w3.org/TR/xhtml1/</a>. Note: a second edition of this
specification is in preparation.</dd><dt class="label"><a name="XHTML11" id="XHTML11"></a>XHTML 1.1</dt><dd>World Wide Web Consortium. <em>XHTML
1.1: Module-Based XHTML.</em> W3C Recommendation. 
See <a href="http://www.w3.org/TR/xhtml11/">http://www.w3.org/TR/xhtml11/</a>
					</dd><dt class="label"><a name="XML" id="XML"></a>XML</dt><dd>World Wide Web Consortium. <em>Extensible
Markup Language (XML) 1.0 (Second Edition)</em> W3C Recommendation. 
See <a href="http://www.w3.org/TR/2000/REC-xml-20001006">http://www.w3.org/TR/2000/REC-xml-20001006</a>
					</dd><dt class="label"><a name="XMLBASE"></a>XMLBASE</dt><dd>World Wide Web
Consortium. <em>XML Base.</em> W3C Recommendation. See
<a href="http://www.w3.org/TR/xmlbase/">http://www.w3.org/TR/xmlbase/</a>
					</dd><dt class="label"><a name="XMLNAMES" id="XMLNAMES"></a>XML Names</dt><dd>World Wide Web
Consortium. <em>Namespaces in XML.</em> W3C Recommendation. See
<a href="http://www.w3.org/TR/REC-xml-names/">http://www.w3.org/TR/REC-xml-names/</a>
					</dd><dt class="label"><a name="XMLSCHEMA" id="XMLSCHEMA"></a>XML Schema</dt><dd>World Wide Web Consortium. 
<em>XML Schema Part 1: Structures</em> and 
and <em>XML Schema Part 2: Data Types</em>. W3C Recommendation.
See <a href="http://www.w3.org/TR/xmlschema-1/">http://www.w3.org/TR/xmlschema-1/</a> and
<a href="http://www.w3.org/TR/xmlschema-2/">http://www.w3.org/TR/xmlschema-2/</a>
					</dd><dt class="label"><a name="XPATH20" id="XPATH20"></a>XPath 2.0</dt><dd>World Wide Web Consortium. <em>XML Path
Language Version 2.0</em> W3C Working Draft.
See <a href="http://www.w3.org/TR/xpath20/">http://www.w3.org/TR/xpath20/</a>
					</dd><dt class="label"><a name="XPATH-FS" id="XPATH-FS"></a>Formal Semantics</dt><dd>World Wide Web Consortium. 
<em>XQuery 1.0 Formal Semantics</em> W3C Working Draft.
See <a href="http://www.w3.org/TR/query-semantics/">http://www.w3.org/TR/query-semantics/</a>
					</dd></dl></div><div class="div2">
<h3><a name="d5e19079" id="d5e19079"></a>A.2 Other References</h3><dl><dt class="label"><a name="HTML" id="HTML"></a>HTML</dt><dd>World Wide Web Consortium. <em>HTML 4.01
specification</em>. W3C Recommendation. 
See <a href="http://www.w3.org/TR/html4/">http://www.w3.org/TR/html4/</a>
					</dd><dt class="label"><a name="IANA" id="IANA"></a>IANA</dt><dd>Internet Assigned Numbers
Authority. <em>Character Sets</em>. 
See <a href="http://www.iana.org/assignments/character-sets">http://www.iana.org/assignments/character-sets</a>.</dd><dt class="label"><a name="RFC2119" id="RFC2119"></a>RFC2119</dt><dd>S. Bradner.  <em>Key 
words for use in RFCs to Indicate Requirement Levels</em>.  IETF RFC 2119. 
See <a href="http://www.ietf.org/rfc/rfc2119.txt">http://www.ietf.org/rfc/rfc2119.txt</a>.</dd><dt class="label"><a name="RFC2278" id="RFC2278"></a>RFC2278</dt><dd>N. Freed, J. Postel.  <em>IANA
Charset Registration Procedures</em>.  IETF RFC 2278. 
See <a href="http://www.ietf.org/rfc/rfc2278.txt">http://www.ietf.org/rfc/rfc2278.txt</a>.</dd><dt class="label"><a name="RFC2376" id="RFC2376"></a>RFC2376</dt><dd>E. Whitehead, M. Murata.  <em>XML
Media Types</em>. IETF RFC 2376. 
See <a href="http://www.ietf.org/rfc/rfc2376.txt">http://www.ietf.org/rfc/rfc2376.txt</a>.</dd><dt class="label"><a name="RFC2396" id="RFC2396"></a>RFC2396</dt><dd>T. Berners-Lee, R. Fielding, and
L. Masinter.  <em>Uniform Resource Identifiers (URI): Generic
Syntax</em>. IETF RFC 2396. 
See <a href="http://www.ietf.org/rfc/rfc2396.txt">http://www.ietf.org/rfc/rfc2396.txt</a>.</dd><dt class="label"><a name="RFC3023" id="RFC3023"></a>RFC3023</dt><dd>M. Murata, S. St.Laurent, and D. Cohn. 
<em>XML Media Types</em>. IETF RFC 3023. 
See <a href="http://www.ietf.org/rfc/rfc3023.txt">http://www.ietf.org/rfc/rfc3023.txt</a>.</dd><dt class="label"><a name="RFC3236" id="RFC3236"></a>RFC3236</dt><dd>M. Baker, P. Stark. 
<em>The 'application/xhtml+xml' Media Type</em>.  IETF RFC 3236. 
See <a href="http://www.ietf.org/rfc/rfc3236.txt">http://www.ietf.org/rfc/rfc3236.txt</a>.</dd><dt class="label"><a name="UNICODE-TR10" id="UNICODE-TR10"></a>UNICODE TR10</dt><dd>Unicode Consortium.
<em>Unicode Technical Standard #10. Unicode Collation
Algorithm</em>.  Unicode Technical Report.  
See <a href="http://www.unicode.org/unicode/reports/tr10/">http://www.unicode.org/unicode/reports/tr10/</a>.</dd><dt class="label"><a name="XINCLUDE" id="XINCLUDE"></a>XInclude</dt><dd>World Wide Web
Consortium. <em>XML Inclusions (XInclude)</em>
W3C Recommendation. 
See <a href="http://www.w3.org/TR/xinclude/">http://www.w3.org/TR/xinclude/</a></dd><dt class="label"><a name="XMLSTYLE" id="XMLSTYLE"></a>XML Stylesheet</dt><dd>World Wide Web
Consortium. <em>Associating Style Sheets with XML documents.</em>
W3C Recommendation. 
See <a href="http://www.w3.org/TR/xml-stylesheet/">http://www.w3.org/TR/xml-stylesheet/</a>
					</dd><dt class="label"><a name="XPOINTER" id="XPOINTER"></a>XPointer</dt><dd>World Wide Web Consortium. <em>XML Pointer
Language (XPointer) Version 1.0</em> W3C Candidate Recommendation.
See <a href="http://www.w3.org/TR/xptr/">http://www.w3.org/TR/xptr/</a>
					</dd><dt class="label"><a name="XSLFO" id="XSLFO"></a>XSL Formatting Objects</dt><dd>World Wide Web Consortium.  
<em>Extensible Stylesheet Language (XSL).</em>  W3C Recommendation.  
See <a href="http://www.w3.org/TR/xsl/">http://www.w3.org/TR/xsl/</a>
					</dd><dt class="label"><a name="XSLT10" id="XSLT10"></a>XSLT 1.0</dt><dd>World Wide Web Consortium. 
<em>XSL Transformations (XSLT) Version 1.0</em> W3C Recommendation. 
See <a href="http://www.w3.org/TR/xslt">http://www.w3.org/TR/xslt</a>
					</dd><dt class="label"><a name="XSLT20REQ" id="XSLT20REQ"></a>XSLT 2.0 Requirements</dt><dd>World Wide Web
Consortium. <em>XSLT Requirements Version 2.0</em>
W3C Working Draft. See <a href="http://www.w3.org/TR/xslt20req">http://www.w3.org/TR/xslt20req</a>
					</dd></dl></div></div><div class="div1">
<h2><a name="glossary" id="glossary"></a>B Glossary (Non-Normative)</h2><table width="100%"><tr><td width="20%" valign="top"><a href="#dt-temporary-tree"></a></td><td width="5%">&nbsp;</td><td valign="top"><p>If a <a title="variable-binding element" href="#dt-variable-binding-element">variable-binding element</a> has no <code>select</code>
attribute and has non-empty content (i.e. the variable-binding element
has one or more child nodes), then the content of the
variable-binding element specifies the supplied value. The content of the
variable-binding element is a
 <a title="content constructor" href="#dt-content-constructor">content constructor</a>; a new
document (referred to as a <b>temporary tree</b>) is constructed with a document
 node having as its children
the sequence of nodes that results from evaluating the content constructor.</p></td></tr><tr><td width="20%" valign="top"><a href="#dt-alias">alias</a></td><td width="5%">&nbsp;</td><td valign="top"><p>A stylesheet can use the
<a href="#element-namespace-alias"><code>xsl:namespace-alias</code></a> element to declare that one namespace
URI is an <b>alias</b> for another namespace URI.</p></td></tr><tr><td width="20%" valign="top"><a href="#dt-argument-conversion-rules">argument conversion rules</a></td><td width="5%">&nbsp;</td><td valign="top"><p>Except where otherwise indicated, the actual
value of an <a title="expression" href="#dt-expression">expression</a> is converted to the <a title="required type" href="#dt-required-type">required type</a>
using the <b>argument conversion rules</b>. These are the rules defined in
<a href="#XPATH20">[XPath 2.0]</a> for converting the supplied argument of a function call to the
required type of that argument, as defined in the function signature. The relevant
rules are those that apply when the "XPath 1.0 backwards compatibility flag" is not set.</p></td></tr><tr><td width="20%" valign="top"><a href="#dt-attribute-set">attribute set</a></td><td width="5%">&nbsp;</td><td valign="top"><p>The
 <a href="#element-attribute-set"><code>xsl:attribute-set</code></a> element defines a named <b>attribute set</b>: that is,
 a collection of attribute values that can be used repeatedly on different elements in the
 result tree.</p></td></tr><tr><td width="20%" valign="top"><a href="#dt-attribute-value-template">attribute value template</a></td><td width="5%">&nbsp;</td><td valign="top"><p>In an 
attribute that is designated as an
<b>attribute value template</b>, such as an attribute of a
<a title="literal result element" href="#dt-literal-result-element">literal result element</a>, 
an <a title="expression" href="#dt-expression">expression</a> can be used by surrounding
the expression with curly braces (<code>{}</code>)</p></td></tr><tr><td width="20%" valign="top"><a href="#dt-backwards-compatible-behavior">backwards compatible behavior</a></td><td width="5%">&nbsp;</td><td valign="top"><p>An element 
enables backwards-compatible behavior for itself, its
attributes, its descendants and their attributes if it has an
<code>[xsl:]version</code> attribute (see <a href="#standard-attributes"><b>3.3 Standard Attributes</b></a>)
whose value is less than <code>2.0</code>.</p></td></tr><tr><td width="20%" valign="top"><a href="#dt-base-output-uri">base output URI</a></td><td width="5%">&nbsp;</td><td valign="top"><p>A <b>base output URI</b>,
that is, a URI to be used as the base URI when resolving a relative URI allocated to a result tree. 
If the transformation generates multiple result
trees, then typically each one will be allocated a URI relative to this base URI.</p></td></tr><tr><td width="20%" valign="top"><a href="#dt-circularity">circularity</a></td><td width="5%">&nbsp;</td><td valign="top"><p>If th
					e <a title="expression" href="#dt-expression">expression</a> or <a title="content constructor" href="#dt-content-constructor">content constructor</a>
specifying the value of a <a title="global variable" href="#dt-global-variable">global variable</a> <var>X</var> references a
global variable <var>Y</var>, then the value for <var>Y</var> must
be computed before the value of <var>X</var>.   If it
is impossible to do this for all global variable definitions,
then a <b>circularity</b> is said to exist.</p></td></tr><tr><td width="20%" valign="top"><a href="#dt-collation">collation</a></td><td width="5%">&nbsp;</td><td valign="top"><p>Facilities in
 XSLT 2.0 and XPath 2.0 that require strings to be ordered rely on the concept of a named
<b>collation</b>. A collation is a set of rules that determine
whether two strings are equal, and if not, which of them should be sorted before the other.</p></td></tr><tr><td width="20%" valign="top"><a href="#dt-content-constructor">content constructor</a></td><td width="5%">&nbsp;</td><td valign="top"><p>A <b>content
constructor</b> is a sequence of nodes in the stylesheet that 
is used to generate nodes in a result tree.
The new nodes become children, attributes, or namespaces of the
 <a title="current destination node" href="#dt-current-destination-node">current destination node</a>.
					</p></td></tr><tr><td width="20%" valign="top"><a href="#dt-context-item">context item</a></td><td width="5%">&nbsp;</td><td valign="top"><p>The <b>context item</b> is the item currently
 being processed. An item (see <a href="#DATAMODEL">[Data Model]</a>) is either an atomic value (such as an
 integer, date, or string), or a node. 
								The context item is initially set to the
  <a title="initial context node" href="#dt-initial-context-node">initial context node</a>
  supplied when the transformation is invoked (see <a href="#initiating"><b>2.3 Initiating a Transformation</b></a>).
 It changes
 whenever instructions such as <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> and <a href="#element-for-each"><code>xsl:for-each</code></a>
 are used to process a sequence of items; each item in such a sequence becomes the context item
 while that item is being processed.</p></td></tr><tr><td width="20%" valign="top"><a href="#dt-context-node">context node</a></td><td width="5%">&nbsp;</td><td valign="top"><p>If the <a title="context item" href="#dt-context-item">context item</a>
 is a node (as distinct
from an atomic value such as an integer), then it is also referred to as the <b>context node</b>.
The context node is not an independent variable, it changes whenever the context item changes. When
the context item is an atomic value, there is no context node: its value is an empty sequence.</p></td></tr><tr><td width="20%" valign="top"><a href="#dt-context-position">context position</a></td><td width="5%">&nbsp;</td><td valign="top"><p>The <b>context position</b> is the position of
the context item within the sequence of items currently being processed. It changes whenever the
context item changes. When an instruction such as <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> or
 <a href="#element-for-each"><code>xsl:for-each</code></a> is used to process
a sequence of items, the first item in the sequence is processed with a context position of 1, the
second item with a context position of 2, and so on.</p></td></tr><tr><td width="20%" valign="top"><a href="#dt-context-size">context size</a></td><td width="5%">&nbsp;</td><td valign="top"><p>The <b>context size</b> is the number of items in
the sequence of items currently being processed. It changes
 whenever instructions such as <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> and <a href="#element-for-each"><code>xsl:for-each</code></a>
 are used to process a sequence of items; during the processing of each one of those items, the
 context size is set to the count of the number of items in the sequence (or equivalently, the position
 of the last item in the sequence).</p></td></tr><tr><td width="20%" valign="top"><a href="#dt-current-destination-node">current destination node</a></td><td width="5%">&nbsp;</td><td valign="top"><p>At
any time during the processing of a stylesheet there may be a <b>current destination node</b>.
This is always either a document node or an element node. When a new node is constructed by an
instruction in the stylesheet, the current destination node becomes its parent.</p></td></tr><tr><td width="20%" valign="top"><a href="#dt-current-group">current group</a></td><td width="5%">&nbsp;</td><td valign="top"><p>The evaluation context for 
XPath <a title="expression" href="#dt-expression">expressions</a> includes an additional value
called the <b>current group</b>, which is a sequence. The current group is the collection of
related items that are processed collectively in one iteration of the <a href="#element-for-each-group"><code>xsl:for-each-group</code></a> element.</p></td></tr><tr><td width="20%" valign="top"><a href="#dt-current-mode">current mode</a></td><td width="5%">&nbsp;</td><td valign="top"><p>At any point in the processing
 of a stylesheet, there is a <b>current mode</b>.  When the transformation is initiated,
 the current mode is the default mode (unless the processor provides some mechanism for
 starting processing in a different mode). Whenever an <a href="#element-apply-templates"><code>xsl:apply-templates</code></a>
 instruction is evaluated, the current mode becomes the mode selected by this instruction.</p></td></tr><tr><td width="20%" valign="top"><a href="#dt-current-template-rule">current template rule</a></td><td width="5%">&nbsp;</td><td valign="top"><p>At any point in the processing
 of a stylesheet, there may be a
<b>current template rule</b>.  Whenever a <a title="template rule" href="#dt-template-rule">template rule</a> is
chosen by matching a pattern, the template rule becomes the current
template rule for the evaluation of the rule's content constructor. When an
<a href="#element-for-each"><code>xsl:for-each</code></a> or <a href="#element-for-each-group"><code>xsl:for-each-group</code></a> 
instruction is evaluated, or when 
a <a title="stylesheet function" href="#dt-stylesheet-function">stylesheet function</a>
 is called (see <a href="#stylesheet-functions"><b>10.3 Stylesheet Functions</b></a>), the current
template rule becomes null for the evaluation of that instruction
or function.</p></td></tr><tr><td width="20%" valign="top"><a href="#dt-decimal-format">decimal-format</a></td><td width="5%">&nbsp;</td><td valign="top"><p>The <a href="#element-decimal-format"><code>xsl:decimal-format</code></a> 
element declares a
decimal-format, which controls the interpretation of a <a title="picture string" href="#dt-picture-string">picture string</a>
used by the <a href="#function-format-number"><b>format-number</b></a> function.</p></td></tr><tr><td width="20%" valign="top"><a href="#dt-declaration">declaration</a></td><td width="5%">&nbsp;</td><td valign="top"><p>Top-level 
elements fall into two categories: declarations, and 
user-defined data elements.
Top-level elements whose names are in the
<a title="XSLT namespace" href="#dt-xslt-namespace">XSLT namespace</a> are <b>declaration</b>s.
Top-level elements in any other namespace are
 <a title="user-defined data element" href="#dt-data-element">user-defined data elements</a>
(see <a href="#user-defined-top-level"><b>3.4.1 User-defined Data Elements</b></a>)</p></td></tr><tr><td width="20%" valign="top"><a href="#dt-declaration-order">declaration order</a></td><td width="5%">&nbsp;</td><td valign="top"><p>The
 <a title="declaration" href="#dt-declaration">declarations</a> within a
<a title="stylesheet level" href="#dt-stylesheet-level">stylesheet level</a> have a total ordering known
 as <b>declaration order</b>. The order of declarations within a stylesheet
 level is the same as the document order that would result if each stylesheet module were
 inserted textually in place of the <a href="#element-include"><code>xsl:include</code></a> element that references it.</p></td></tr><tr><td width="20%" valign="top"><a href="#dt-default-priority">default priority</a></td><td width="5%">&nbsp;</td><td valign="top"><p>If no <code>priority</code>
attribute is specified on the <a href="#element-template"><code>xsl:template</code></a> element, the <b>default
priority</b> is computed as follows:</p></td></tr><tr><td width="20%" valign="top"><a href="#dt-dynamic-error">dynamic error</a></td><td width="5%">&nbsp;</td><td valign="top"><p>An error that is not detected until
 a source document is being transformed is referred to as a
  <b>dynamic error</b>.</p></td></tr><tr><td width="20%" valign="top"><a href="#dt-effective-value">effective value</a></td><td width="5%">&nbsp;</td><td valign="top"><p>The 
result of evaluating an attribute value template is referred to as the
<b>effective value</b> of the attribute.</p></td></tr><tr><td width="20%" valign="top"><a href="#dt-embedded-stylesheet-module">embedded stylesheet module</a></td><td width="5%">&nbsp;</td><td valign="top"><p>An 
<b>embedded stylesheet module</b> is a stylesheet module that is
embedded within another XML document, typically the source document
 that is being transformed.
				</p></td></tr><tr><td width="20%" valign="top"><a href="#dt-expanded-qname">expanded-QName</a></td><td width="5%">&nbsp;</td><td valign="top"><p>An
<b>expanded-QName</b> is a pair of values containing a local name and an optional namespace URI.
A QName is expanded by replacing the namespace prefix with the corresponding namespace URI,
from the namespace declarations that are in scope at the point where the QName is written.
Two expanded-QNames are equal if the namespace URIs are the same 
(or both absent) and the local names are the
same.</p></td></tr><tr><td width="20%" valign="top"><a href="#dt-expression">expression</a></td><td width="5%">&nbsp;</td><td valign="top"><p>Within this specification, the term
<b>XPath expression</b>, or simply <b>expression</b>, means
a string that matches the production <u>ExprSequence</u>
defined in <a href="#XPATH20">[XPath 2.0]</a>.</p></td></tr><tr><td width="20%" valign="top"><a href="#dt-extension-function">extension function</a></td><td width="5%">&nbsp;</td><td valign="top"><p>An
<b>extension function</b> is a function that is available for
use within an XPath <a title="expression" href="#dt-expression">expression</a>, other than a core function defined
in the XPath specification, an additional function defined in this
XSLT specification, or a <a title="stylesheet function" href="#dt-stylesheet-function">stylesheet
function</a> defined using an <a href="#element-function"><code>xsl:function</code></a> declaration.</p></td></tr><tr><td width="20%" valign="top"><a href="#dt-extension-instruction">extension instruction</a></td><td width="5%">&nbsp;</td><td valign="top"><p>An
<b>extension instruction</b> is an element within a
 <a title="content constructor" href="#dt-content-constructor">content constructor</a> that is in
 a namespace (not the <a title="XSLT namespace" href="#dt-xslt-namespace">XSLT namespace</a>)
 designated as an extension namespace</p></td></tr><tr><td width="20%" valign="top"><a href="#dt-extension-namespace">extension namespace</a></td><td width="5%">&nbsp;</td><td valign="top"><p>The
<a title="extension instruction" href="#dt-extension-instruction">extension instruction</a> mechanism allows namespaces to be designated as
<b>extension namespace</b>s. When a namespace is designated as
an extension namespace and an element with a name from that namespace
occurs in a <a title="content constructor" href="#dt-content-constructor">content constructor</a>,
 then the element is treated as an <a title="instruction" href="#dt-instruction">instruction</a>
rather than as a <a title="literal result element" href="#dt-literal-result-element">literal result element</a>.</p></td></tr><tr><td width="20%" valign="top"><a href="#dt-focus">focus</a></td><td width="5%">&nbsp;</td><td valign="top"><p>When a
 <a title="content constructor" href="#dt-content-constructor">content constructor</a> is
 evaluated, the <a title="processor" href="#dt-processor">processor</a> keeps track of which 
 nodes are being processed 
 by means of a set of implicit variables referred to collectively as the
  <b>focus</b>.</p></td></tr><tr><td width="20%" valign="top"><a href="#dt-forwards-compatible-behavior">forwards-compatible behavior</a></td><td width="5%">&nbsp;</td><td valign="top"><p>An element enables
 <b>forwards-compatible behavior</b> for itself, its
attributes, its descendants and their attributes if it has an
<code>[xsl:]version</code> attribute (see <a href="#standard-attributes"><b>3.3 Standard Attributes</b></a>) 
whose value is greater than <code>2.0</code>.</p></td></tr><tr><td width="20%" valign="top"><a href="#dt-function-parameter">function parameter</a></td><td width="5%">&nbsp;</td><td valign="top"><p>
An <a href="#element-param"><code>xsl:param</code></a> element may appear as a child of an <a href="#element-function"><code>xsl:function</code></a>
element, before any non-<a href="#element-param"><code>xsl:param</code></a> children of that element. Such a parameter
is known as a <b>function parameter</b>. A function parameter is a 
<a title="local variable" href="#dt-local-variable">local variable</a> with the additional 
property that its value can be set when the function
is called, using a function call in an XPath <a title="expression" href="#dt-expression">expression</a>.</p></td></tr><tr><td width="20%" valign="top"><a href="#dt-global-variable">global variable</a></td><td width="5%">&nbsp;</td><td valign="top"><p>A 
top-level <a title="variable-binding element" href="#dt-variable-binding-element">variable-binding element</a>
 declares a <b>global variable</b> that
is visible everywhere (except where it
is <a title="shadows" href="#dt-shadows">shadowed</a> by another
binding).</p></td></tr><tr><td width="20%" valign="top"><a href="#dt-group">group</a></td><td width="5%">&nbsp;</td><td valign="top"><p>The <a href="#element-for-each-group"><code>xsl:for-each-group</code></a> instruction partitions a sequence into
<b>group</b>s of items (that is, it establishes a set of sequences) based either on common
values of a grouping key, or on 
a <a title="pattern" href="#dt-pattern">pattern</a> that the initial node in a group must match.</p></td></tr><tr><td width="20%" valign="top"><a href="#dt-grouping-key">grouping key</a></td><td width="5%">&nbsp;</td><td valign="top"><p>If either of the
<code>group-by</code> attribute nor <code>group-adjacent</code> attributes is present, then
a <b>grouping key</b> is calculated for each item in the <a title="population" href="#dt-population">population</a>.</p></td></tr><tr><td width="20%" valign="top"><a href="#dt-implementation">implementation</a></td><td width="5%">&nbsp;</td><td valign="top"><p>A specific product that performs the functions of
 an <a title="processor" href="#dt-processor">XSLT processor</a> is referred to as
 an <b>implementation</b>
					</p></td></tr><tr><td width="20%" valign="top"><a href="#dt-implementation-defined">implementation-defined</a></td><td width="5%">&nbsp;</td><td valign="top"><p>In this
specification, the term <b>implementation-defined</b> refers to a feature where the
implementation is allowed some flexibility, and where the choices made by the
implementation should be described in the vendor's documentation.</p></td></tr><tr><td width="20%" valign="top"><a href="#dt-implementation-dependent">implementation-dependent</a></td><td width="5%">&nbsp;</td><td valign="top"><p>The 
term <b>implementation-dependent</b> refers to a feature where the
behavior may vary from one implementation to another, and where the vendor is not expected to
provide a full specification of the behavior.</p></td></tr><tr><td width="20%" valign="top"><a href="#dt-import-precedence">import precedence</a></td><td width="5%">&nbsp;</td><td valign="top"><p>A <a title="declaration" href="#dt-declaration">declaration</a>
							<var>D</var> in the stylesheet
is defined to have lower <b>import precedence</b> than another
declaration <var>E</var> if the stylesheet level containing <var>D</var> would be
visited before the stylesheet level containing <var>E</var> in a
post-order traversal of the import tree (that is, a traversal of the
import tree in which a stylesheet level is visited
after its children). Two declarations within the same stylesheet level have
the same import precedence.</p></td></tr><tr><td width="20%" valign="top"><a href="#dt-import-tree">import tree</a></td><td width="5%">&nbsp;</td><td valign="top"><p>The
<a title="stylesheet level" href="#dt-stylesheet-level">stylesheet levels</a>
making up a stylesheet are
treated as forming an <b>import tree</b>.  In the import tree,
each stylesheet level has one child for each
<a href="#element-import"><code>xsl:import</code></a> declaration that it contains.</p></td></tr><tr><td width="20%" valign="top"><a href="#dt-initial-context-node">initial context node</a></td><td width="5%">&nbsp;</td><td valign="top"><p>A node that acts as
 the <b>initial context node</b> for the transformation. This node is accessible within the
stylesheet as the initial value of the XPath <a title="expression" href="#dt-expression">expressions</a> <code>.</code> and <code>self::node()</code>,
as described in <a href="#focus"><b>2.5 Maintaining Position: the Focus</b></a>
								</p></td></tr><tr><td width="20%" valign="top"><a href="#dt-initial-input-sequence">initial input sequence</a></td><td width="5%">&nbsp;</td><td valign="top"><p>A set of nodes
 (possibly empty) that forms the <b>initial input sequence</b>. These nodes (which will often 
be document nodes, but may in principle be any kind of node, from the same or different documents) are
available at any time during the transformation as the result of the <u>fn:input</u>
function described in <a href="#FANDO">[Functions and Operators]</a>.</p></td></tr><tr><td width="20%" valign="top"><a href="#dt-initial-sequence">initial sequence</a></td><td width="5%">&nbsp;</td><td valign="top"><p>The sequence to be sorted
is referred to as the <b>initial sequence</b>.</p></td></tr><tr><td width="20%" valign="top"><a href="#dt-instruction">instruction</a></td><td width="5%">&nbsp;</td><td valign="top"><p>The elements occurring within a content
constructor are classified as being either <a title="literal result element" href="#dt-literal-result-element">literal result elements</a>
or instructions. If the element is in the XSLT namespace,
or in a namespace designated as an <a title="extension namespace" href="#dt-extension-namespace">extension
namespace</a>, then it is an <b>instruction</b>. Otherwise, it is a literal
result element.</p></td></tr><tr><td width="20%" valign="top"><a href="#dt-key">key</a></td><td width="5%">&nbsp;</td><td valign="top"><p>A <b>key</b> is defined as
					a set of <a href="#element-key"><code>xsl:key</code></a> declarations in the stylesheet that share the same name.</p></td></tr><tr><td width="20%" valign="top"><a href="#dt-literal-namespace-uri">literal namespace URI</a></td><td width="5%">&nbsp;</td><td valign="top"><p>A
 namespace URI in the stylesheet tree that is being used to
specify a namespace URI in the result tree is called a <b>literal
namespace URI</b>.</p></td></tr><tr><td width="20%" valign="top"><a href="#dt-literal-result-element">literal result element</a></td><td width="5%">&nbsp;</td><td valign="top"><p>In 
a <a title="content constructor" href="#dt-content-constructor">content constructor</a>, an element in 
the stylesheet that does not belong to
the <a title="XSLT namespace" href="#dt-xslt-namespace">XSLT namespace</a> and 
that is not an <a title="extension instruction" href="#dt-extension-instruction">extension instruction</a> (see <a href="#extension-instruction"><b>18.2 Extension Instructions</b></a>) is classified as a 
<b>literal result element</b>.</p></td></tr><tr><td width="20%" valign="top"><a href="#dt-local-variable">local variable</a></td><td width="5%">&nbsp;</td><td valign="top"><p>As 
well as being allowed as <a title="declaration" href="#dt-declaration">declaration</a> elements, the
<a href="#element-variable"><code>xsl:variable</code></a> element is also
allowed in <a title="content constructor" href="#dt-content-constructor">content constructors</a>
and within the <a href="#element-function"><code>xsl:function</code></a> element
(see <a href="#stylesheet-functions"><b>10.3 Stylesheet Functions</b></a>) after any <a href="#element-param"><code>xsl:param</code></a> elements and before the
<a href="#element-result"><code>xsl:result</code></a> element. Such a variable
is known as a <b>local variable</b>.</p></td></tr><tr><td width="20%" valign="top"><a href="#dt-mode">mode</a></td><td width="5%">&nbsp;</td><td valign="top"><p>
						<b>Modes</b> 
allow a node in the source tree to be processed multiple times, each time
producing a different result. They also allow different sets 
of <a title="template rule" href="#dt-template-rule">template rules</a>
 to be active when processing different
trees, for example when processing documents loaded using the <u>fn:document</u> function
(see <a href="#document"><b>16.1 Multiple Source Documents</b></a>) or when processing <a title="" href="#dt-temporary-tree">temporary trees</a>
 (see <a href="#temporary-trees"><b>9.4 Temporary Trees</b></a>)</p></td></tr><tr><td width="20%" valign="top"><a href="#dt-named-sort-key">named sort specification</a></td><td width="5%">&nbsp;</td><td valign="top"><p>A 
<b>named sort specification</b> is defined
 by an <a href="#element-sort-key"><code>xsl:sort-key</code></a> declaration. This is a top-level
element in the stylesheet.</p></td></tr><tr><td width="20%" valign="top"><a href="#dt-named-template">named template</a></td><td width="5%">&nbsp;</td><td valign="top"><p>Templates can be invoked by name.  
An <a href="#element-template"><code>xsl:template</code></a>
element with a <code>name</code> attribute specifies a <b>named template</b>.</p></td></tr><tr><td width="20%" valign="top"><a href="#dt-namespace-fixup">namespace fixup</a></td><td width="5%">&nbsp;</td><td valign="top"><p>The rules for the individual XSLT instructions that 
				construct a result tree (see <a href="#creating-new-nodes"><b>11 Creating New Nodes</b></a>) prescribe some of the situations
				in which namespace nodes are written to the tree. These rules, however, are not sufficient
				to ensure that the above constraints are always satisfied. The XSLT processor must therefore
				add additional namespace nodes to satisfy these constraints. This process is referred to
				as <b>namespace fixup</b>.</p></td></tr><tr><td width="20%" valign="top"><a href="#dt-first-appearance">order of first appearance</a></td><td width="5%">&nbsp;</td><td valign="top"><p>There is an ordering
among <a title="group" href="#dt-group">groups</a> referred to as the <b>order of first
appearance</b>. A group <var>G</var> is defined to precede a group <var>H</var> in order of first
appearance if the initial item of <var>G</var> precedes the initial item of <var>H</var> 
in population order.</p></td></tr><tr><td width="20%" valign="top"><a href="#dt-output-definition">output definition</a></td><td width="5%">&nbsp;</td><td valign="top"><p>All 
the <a href="#element-output"><code>xsl:output</code></a> declarations in a stylsheet
 that share the same name are grouped into a named <b>output definition</b>;
 those that have no name are grouped into a a single unnamed output definition.</p></td></tr><tr><td width="20%" valign="top"><a href="#dt-parameter">parameter</a></td><td width="5%">&nbsp;</td><td valign="top"><p>The <a href="#element-param"><code>xsl:param</code></a>
element declares a <b>parameter</b>, which may be a 
<a title="stylesheet parameter" href="#dt-stylesheet-parameter">stylesheet parameter</a>,
a <a title="template parameter" href="#dt-template-parameter">template parameter</a>,
or a <a title="function parameter" href="#dt-function-parameter">function parameter</a>. A parameter
is a <a title="variable" href="#dt-variable">variable</a> with the additional property that its value can be set
 by the caller of the stylesheet, the template, or the function.</p></td></tr><tr><td width="20%" valign="top"><a href="#dt-pattern">pattern</a></td><td width="5%">&nbsp;</td><td valign="top"><p>A <b>pattern</b> specifies
 a set of conditions on a node. A
node that satisfies the conditions matches the pattern; a node that
does not satisfy the conditions does not match the pattern.  The
syntax for patterns is a subset of the syntax for <a title="expression" href="#dt-expression">expressions</a>.</p></td></tr><tr><td width="20%" valign="top"><a href="#dt-picture-string">picture string</a></td><td width="5%">&nbsp;</td><td valign="top"><p>The formatting of a 
number is controlled by a <b>picture string</b>. The
picture string is a sequence of characters, in which the characters
assigned to the variables <var>decimal-separator-sign</var>, <var>grouping-sign</var>,

							<var>zero-digit-sign</var>,
<var>digit-sign</var> and <var>pattern-separator-sign</var> are classified as
active characters, and all other characters 
(including the <var>percent-sign</var> and <var>per-mille-sign</var>)
are classified as passive characters.</p></td></tr><tr><td width="20%" valign="top"><a href="#dt-place-marker">place marker</a></td><td width="5%">&nbsp;</td><td valign="top"><p>The
 <a href="#element-number"><code>xsl:number</code></a> instruction performs
two tasks: firstly, determining a <b>place marker</b> (this is 
a sequence of integers, to allow for hierarchic numbering schemes such as
<code>1.12.2</code> or <code>3(c)ii</code>), and secondly, 
formatting the place marker for output as a text node in the result tree.</p></td></tr><tr><td width="20%" valign="top"><a href="#dt-population">population</a></td><td width="5%">&nbsp;</td><td valign="top"><p>The sequence of items
 to be grouped, which
 is referred to as the <b>population</b>,
is determined by evaluating the XPath <a title="expression" href="#dt-expression">expression</a> contained in the
<code>select</code> attribute.</p></td></tr><tr><td width="20%" valign="top"><a href="#dt-population-order">population order</a></td><td width="5%">&nbsp;</td><td valign="top"><p>The population is treated as a sequence; 
the order of
items in this sequence is referred to as <b>population order</b>
					</p></td></tr><tr><td width="20%" valign="top"><a href="#dt-principal-stylesheet-module">principal stylesheet module</a></td><td width="5%">&nbsp;</td><td valign="top"><p>A 
stylesheet may consist of several stylesheet modules,
contained in different XML documents. 
For a given transformation, one of these functions as the
<b>principal stylesheet module</b>. The complete stylesheet is
assembled by finding the stylesheet modules referenced 
directly or indirectly from the
principal stylesheet module using <a href="#element-include"><code>xsl:include</code></a> and
<a href="#element-import"><code>xsl:import</code></a> elements: see <a href="#include"><b>3.8.1 Stylesheet Inclusion</b></a> and
<a href="#import"><b>3.8.2 Stylesheet Import</b></a>
					</p></td></tr><tr><td width="20%" valign="top"><a href="#dt-processor">processor</a></td><td width="5%">&nbsp;</td><td valign="top"><p>The software responsible
 for transforming source trees into
a result trees is referred to as the <b>processor</b>. This is sometimes expanded
to <em>XSLT processor</em> to avoid any confusion with
other processors, for example an XML processor.</p></td></tr><tr><td width="20%" valign="top"><a href="#dt-qname">QName</a></td><td width="5%">&nbsp;</td><td valign="top"><p>A <b>QName</b> is
always written in the form <code>(NCName ":")? NCName</code>, that is, a local name
optionally preceded by a namespace prefix. When two QNames are compared, however,
they are considered equal if the corresponding
 <a title="expanded-QName" href="#dt-expanded-qname">expanded-QNames</a> are the same.</p></td></tr><tr><td width="20%" valign="top"><a href="#dt-required-type">required type</a></td><td width="5%">&nbsp;</td><td valign="top"><p>The context within a stylesheet
where an XPath <a title="expression" href="#dt-expression">expression</a>
 appears may specify the <b>required type</b> of
the expression. The required type indicates the data type of value that the
expression is expected to return.</p></td></tr><tr><td width="20%" valign="top"><a href="#dt-reserved-namespace">reserved namespace</a></td><td width="5%">&nbsp;</td><td valign="top"><p>The
 XSLT namespace, together with certain other namespaces
recognized by an XSLT processor, are classified as <b>reserved namespaces</b> 
and may be used only as specified in this and related specifications.</p></td></tr><tr><td width="20%" valign="top"><a href="#dt-schema-datatypes-namespace">schema datatypes namespace</a></td><td width="5%">&nbsp;</td><td valign="top"><p>The <b>schema
datatypes namespace</b>
								<code>http://www.w3.org/2001/XMLSchema-datatypes</code> is used  
as defined in <a href="#XMLSCHEMA">[XML Schema]</a>
							</p></td></tr><tr><td width="20%" valign="top"><a href="#dt-schema-instance-namespace">schema instance namespace</a></td><td width="5%">&nbsp;</td><td valign="top"><p>The <b>schema
instance namespace</b>
								<code>http://www.w3.org/2001/XMLSchema-instance</code> is used 
as defined in <a href="#XMLSCHEMA">[XML Schema]</a>
							</p></td></tr><tr><td width="20%" valign="top"><a href="#dt-schema-namespace">schema namespace</a></td><td width="5%">&nbsp;</td><td valign="top"><p>The <b>schema
namespace</b>
								<code>http://www.w3.org/2001/XMLSchema</code> is used 
as defined in <a href="#XMLSCHEMA">[XML Schema]</a>
							</p></td></tr><tr><td width="20%" valign="top"><a href="#dt-serialization">serialization</a></td><td width="5%">&nbsp;</td><td valign="top"><p>A frequent requirement is to
output a result tree as an XML document (or in other formats such as HTML). 
This process is referred to as
 <b>serialization</b>.</p></td></tr><tr><td width="20%" valign="top"><a href="#dt-serialization-error">serialization error</a></td><td width="5%">&nbsp;</td><td valign="top"><p>If a transformation has successfully produced
 a result tree, it is still possible that errors may occur in serializing the result tree.
 For example, it may be impossible to serialize the result tree using the encoding selected by the user.
 Such an error is referred to as a <b>serialization error</b>.</p></td></tr><tr><td width="20%" valign="top"><a href="#dt-shadows">shadows</a></td><td width="5%">&nbsp;</td><td valign="top"><p>A binding <b>shadows</b> another
binding if the binding occurs at a point where the other binding is visible, and
the bindings have the same name.
</p></td></tr><tr><td width="20%" valign="top"><a href="#dt-simplified-stylesheet-module">simplified stylesheet module</a></td><td width="5%">&nbsp;</td><td valign="top"><p>A
<b>simplified stylesheet module</b> is an XML document, or part
of an XML document, whose outermost element is a <a title="literal result element" href="#dt-literal-result-element">literal result element</a>
to be copied to the result tree. This element is not itself in the XSLT namespace, but it
 must have an <code>xsl:version</code> attribute, 
 which implies that the XSLT namespace must be declared.
For further details see <a href="#simplified-stylesheet"><b>3.5 Simplified Stylesheet Modules</b></a>.
						</p></td></tr><tr><td width="20%" valign="top"><a href="#dt-singleton-focus">singleton focus</a></td><td width="5%">&nbsp;</td><td valign="top"><p>A <b>singleton focus</b> 
based on a node <var>N</var>
has the <a title="context item" href="#dt-context-item">context item</a> (and therefore the 
<a title="context node" href="#dt-context-node">context node</a>) set to <var>N</var>, and the <a title="context position" href="#dt-context-position">context position</a>
and <a title="context size" href="#dt-context-size">context size</a> both set to 1 (one).</p></td></tr><tr><td width="20%" valign="top"><a href="#dt-sorted-sequence">sorted sequence</a></td><td width="5%">&nbsp;</td><td valign="top"><p>The sequence after sorting 
as defined by the <a href="#element-sort"><code>xsl:sort</code></a> elements
is referred to as the <b>sorted sequence</b>.</p></td></tr><tr><td width="20%" valign="top"><a href="#dt-sort-key">sort key</a></td><td width="5%">&nbsp;</td><td valign="top"><p>
For each item in the <a title="initial sequence" href="#dt-initial-sequence">initial sequence</a>,
a value is computed
for each <a title="sort key definition" href="#dt-sort-key-definition">sort key definition</a>
within the <a title="sort specification" href="#dt-sort-specification">sort specification</a>.
The value computed for an item by using the <var>N</var>th sort key definition
is referred to as the <var>N</var>th <b>sort key</b> of that item.</p></td></tr><tr><td width="20%" valign="top"><a href="#dt-sort-key-definition">sort key definition</a></td><td width="5%">&nbsp;</td><td valign="top"><p>Within a
<a title="sort specification" href="#dt-sort-specification">sort specification</a>, each
<a href="#element-sort"><code>xsl:sort</code></a> element provides one <b>sort key definition</b>.</p></td></tr><tr><td width="20%" valign="top"><a href="#dt-sort-specification">sort specification</a></td><td width="5%">&nbsp;</td><td valign="top"><p>A 
<b>sort specification</b>
is a sequence of one or more adjacent <a href="#element-sort"><code>xsl:sort</code></a> elements which together define rules
for sorting the items in an input sequence to form a sorted sequence.</p></td></tr><tr><td width="20%" valign="top"><a href="#dt-standard-attributes">standard attributes</a></td><td width="5%">&nbsp;</td><td valign="top"><p>There are a number of 
<b>standard attributes</b> that may appear on any XSLT element: specifically
<code>version</code>, 
						<code>exclude-result-prefixes</code>, 
<code>extension-element-prefixes</code>, and
<code>default-xpath-namespace</code>.</p></td></tr><tr><td width="20%" valign="top"><a href="#dt-standard-function-namespace">standard function namespace</a></td><td width="5%">&nbsp;</td><td valign="top"><p>The <b>standard
function namespace</b>
								<code>http://www.w3.org/2002/08/xquery-functions</code> is used for functions
in the core function library, defined in <a href="#FANDO">[Functions and Operators]</a>
							</p></td></tr><tr><td width="20%" valign="top"><a href="#dt-standard-operator-namespace">standard operator namespace</a></td><td width="5%">&nbsp;</td><td valign="top"><p>The <b>standard
operator namespace</b>
								<code>http://www.w3.org/2002/08/xquery-operators</code> is used for functions
that underpin XPath operators, defined in <a href="#FANDO">[Functions and Operators]</a>
							</p></td></tr><tr><td width="20%" valign="top"><a href="#dt-standard-stylesheet-module">standard stylesheet module</a></td><td width="5%">&nbsp;</td><td valign="top"><p>A
<b>standard stylesheet module</b> is an XML document, or part of an XML document,
having an <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> or <a href="#element-transform"><code>xsl:transform</code></a> element
as its outermost element (see <a href="#stylesheet-element"><b>3.4 Stylesheet Element</b></a>).</p></td></tr><tr><td width="20%" valign="top"><a href="#dt-static-error">static error</a></td><td width="5%">&nbsp;</td><td valign="top"><p>An error that is detected by examining
 a stylesheet before execution starts (that is, before the source document
 and values of stylesheet parameters
 are available) is referred to as a <b>static error</b>.</p></td></tr><tr><td width="20%" valign="top"><a href="#dt-stylesheet">stylesheet</a></td><td width="5%">&nbsp;</td><td valign="top"><p>A 
transformation in the XSLT language is expressed 
in the form of a <b>stylesheet</b>, whose syntax is 
well-formed XML <a href="#XML">[XML]</a> conforming to the
Namespaces in XML Recommendation <a href="#XMLNAMES">[XML Names]</a>.</p></td></tr><tr><td width="20%" valign="top"><a href="#dt-stylesheet-function">stylesheet function</a></td><td width="5%">&nbsp;</td><td valign="top"><p>An <a href="#element-function"><code>xsl:function</code></a> 
declaration declares the name, parameters, and implementation of a
 <b>stylesheet function</b>
 that can be called from any XPath
<a title="expression" href="#dt-expression">expression</a> within the stylesheet.</p></td></tr><tr><td width="20%" valign="top"><a href="#dt-stylesheet-level">stylesheet level</a></td><td width="5%">&nbsp;</td><td valign="top"><p>A <b>stylesheet level</b>
is a collection of <a title="stylesheet module" href="#dt-stylesheet-module">stylesheet modules</a> connected
using <a href="#element-include"><code>xsl:include</code></a> declarations: 
specifically, two stylesheet modules <var>A</var> and <var>B</var> are part of the same 
stylesheet level if one of them includes the other by means of an <a href="#element-include"><code>xsl:include</code></a>
declaration, or if there is a third stylesheet module <var>C</var> that is in the same 
stylesheet level as both <var>A</var> and <var>B</var>.</p></td></tr><tr><td width="20%" valign="top"><a href="#dt-stylesheet-module">stylesheet module</a></td><td width="5%">&nbsp;</td><td valign="top"><p>A 
<a title="stylesheet" href="#dt-stylesheet">stylesheet</a>
consists of one or more <b>stylesheet module</b>s, each one forming
all or part of a well-formed XML document.</p></td></tr><tr><td width="20%" valign="top"><a href="#dt-stylesheet-parameter">stylesheet parameter</a></td><td width="5%">&nbsp;</td><td valign="top"><p>A top-level <a href="#element-param"><code>xsl:param</code></a> element
declares a <b>stylesheet parameter</b>.
A stylesheet parameter is a global variable with the additional property 
that its value can be supplied
by the caller when a transformation is initiated. XSLT does not define the
mechanism by which parameter values are passed to the stylesheet.</p></td></tr><tr><td width="20%" valign="top"><a href="#dt-template-parameter">template parameter</a></td><td width="5%">&nbsp;</td><td valign="top"><p>
An <a href="#element-param"><code>xsl:param</code></a> element may appear as a child of an <a href="#element-template"><code>xsl:template</code></a>
element, before any non-<a href="#element-param"><code>xsl:param</code></a> children of that element. Such a parameter
is known as a <b>template parameter</b>. A template parameter is a 
<a title="local variable" href="#dt-local-variable">local variable</a> with the additional 
property that its value can be set when the template
is called, using any of the instructions <a href="#element-call-template"><code>xsl:call-template</code></a>, <a href="#element-apply-templates"><code>xsl:apply-templates</code></a>,
or <a href="#element-apply-imports"><code>xsl:apply-imports</code></a>.</p></td></tr><tr><td width="20%" valign="top"><a href="#dt-template-rule">template rule</a></td><td width="5%">&nbsp;</td><td valign="top"><p>A stylesheet generally contains
 a set of <b>template rules</b>. A template rule has
two parts: a <a title="pattern" href="#dt-pattern">pattern</a> which is matched against nodes in a source tree
and a <a title="content constructor" href="#dt-content-constructor">content constructor</a> which is 
evaluated to create new nodes that are written to a result
tree.</p></td></tr><tr><td width="20%" valign="top"><a href="#dt-top-level">top-level</a></td><td width="5%">&nbsp;</td><td valign="top"><p>An element occurring as
a child of an <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> element is called a
<b>top-level</b> element.</p></td></tr><tr><td width="20%" valign="top"><a href="#dt-type-error">type errors</a></td><td width="5%">&nbsp;</td><td valign="top"><p>Certain errors are classified as <b>type errors</b>.
 A type error occurs when the value supplied as input to an operation is of the wrong type
 for that operation, for example when an integer is supplied to an operation that expects
 a node.</p></td></tr><tr><td width="20%" valign="top"><a href="#dt-data-element">user-defined data element</a></td><td width="5%">&nbsp;</td><td valign="top"><p>In addition to 
<a title="declaration" href="#dt-declaration">declarations</a>, 
the <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> element may contain
any element not from the <a title="XSLT namespace" href="#dt-xslt-namespace">XSLT namespace</a>,
 provided that the
<a title="expanded-QName" href="#dt-expanded-qname">expanded-QName</a> of the element has a non-null namespace URI.  Such
elements are referred to as <b>user-defined data elements</b>.</p></td></tr><tr><td width="20%" valign="top"><a href="#dt-value">value</a></td><td width="5%">&nbsp;</td><td valign="top"><p>The value to
which a variable is bound (the <b>value</b> of the variable) is
any sequence (of nodes and/or atomic values), as defined in <a href="#DATAMODEL">[Data Model]</a>.</p></td></tr><tr><td width="20%" valign="top"><a href="#dt-variable">variable</a></td><td width="5%">&nbsp;</td><td valign="top"><p>The <a href="#element-variable"><code>xsl:variable</code></a> element declares a
<b>variable</b>, which may be a <a title="global variable" href="#dt-global-variable">global variable</a>
 or a <a title="local variable" href="#dt-local-variable">local variable</a>.</p></td></tr><tr><td width="20%" valign="top"><a href="#dt-variable-binding-element">variable-binding element</a></td><td width="5%">&nbsp;</td><td valign="top"><p>The 
two elements <a href="#element-variable"><code>xsl:variable</code></a> and <a href="#element-param"><code>xsl:param</code></a>
are referred to as <b>variable-binding elements</b>
</p></td></tr><tr><td width="20%" valign="top"><a href="#xml-namespace">XML namespace</a></td><td width="5%">&nbsp;</td><td valign="top"><p>The <b>XML namespace</b>, defined
in <a href="#XMLNAMES">[XML Names]</a> as <code>http://www.w3.org/XML/1998/namespace</code>,
 is used for attributes such as <code>xml:lang</code> and <code>xml:space</code></p></td></tr><tr><td width="20%" valign="top"><a href="#dt-xslt-namespace">XSLT namespace</a></td><td width="5%">&nbsp;</td><td valign="top"><p>The <b>XSLT namespace</b>
 has the URI <code>http://www.w3.org/1999/XSL/Transform</code>. It is used to identify
 elements, attributes, and other names that have a special meaning defined in
 this specification.</p></td></tr></table></div><div class="div1">
<h2><a name="element-syntax-summary" id="element-syntax-summary"></a>C Element Syntax Summary (Non-Normative)</h2><p>The syntax of each XSLT element is summarized below, together with the
context in the stylesheet where the element may appear. Some elements (specifically,
instructions) are allowed as a child of any element that is allowed to contain a content
constructor. These elements are:</p><ul><li><code>xsl:attribute</code></li><li><code>xsl:comment</code></li><li><code>xsl:copy</code></li><li><code>xsl:element</code></li><li><code>xsl:fallback</code></li><li><code>xsl:for-each</code></li><li><code>xsl:for-each-group</code></li><li><code>xsl:if</code></li><li><code>xsl:matching-substring</code></li><li><code>xsl:message</code></li><li><code>xsl:namespace</code></li><li><code>xsl:non-matching-substring</code></li><li><code>xsl:otherwise</code></li><li><code>xsl:param</code></li><li><code>xsl:processing-instruction</code></li><li><code>xsl:result</code></li><li><code>xsl:result-document</code></li><li><code>xsl:template</code></li><li><code>xsl:text</code></li><li><code>xsl:variable</code></li><li><code>xsl:when</code></li><li><code>xsl:with-param</code></li><li>Literal result elements</li><li>Extension instructions, if so defined</li></ul><p><b><a href="#element-analyze-string">xsl:analyze-string</a></b></p><table width="100%"><tr><td width="10%">&nbsp;</td><td><p><i>Category: </i>instruction</p><p><i>Model:</i></p><p class="element-syntax-summary"><code>&lt;xsl:analyze-string<br>&nbsp;&nbsp;<b>select</b> = <var>expression</var><br>&nbsp;&nbsp;<b>regex</b> = { <var>string</var> }<br>&nbsp;&nbsp;flags = { <var>string</var> }&gt;<br>&nbsp;&nbsp;&lt;!-- Content: (<a href="#element-matching-substring">xsl:matching-substring</a>?, <a href="#element-non-matching-substring">xsl:non-matching-substring</a>?, <a href="#element-fallback">xsl:fallback</a>*) --&gt;<br>&lt;/xsl:analyze-string&gt;</code></p><p><i>Permitted parent elements:</i></p><ul><li>any XSLT element whose content model is <i>content constructor</i></li><li>any literal result element</li></ul></td></tr></table><p><b><a href="#element-apply-imports">xsl:apply-imports</a></b></p><table width="100%"><tr><td width="10%">&nbsp;</td><td><p><i>Category: </i>instruction</p><p><i>Model:</i></p><p class="element-syntax-summary"><code>&lt;xsl:apply-imports&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <a href="#element-with-param">xsl:with-param</a>* --&gt;<br>&lt;/xsl:apply-imports&gt;</code></p><p><i>Permitted parent elements:</i></p><ul><li>any XSLT element whose content model is <i>content constructor</i></li><li>any literal result element</li></ul></td></tr></table><p><b><a href="#element-apply-templates">xsl:apply-templates</a></b></p><table width="100%"><tr><td width="10%">&nbsp;</td><td><p><i>Category: </i>instruction</p><p><i>Model:</i></p><p class="element-syntax-summary"><code>&lt;xsl:apply-templates<br>&nbsp;&nbsp;select = <var>node-sequence-expression</var><br>&nbsp;&nbsp;mode = <var>token</var>&gt;<br>&nbsp;&nbsp;&lt;!-- Content: (<a href="#element-sort">xsl:sort</a> | <a href="#element-with-param">xsl:with-param</a>)* --&gt;<br>&lt;/xsl:apply-templates&gt;</code></p><p><i>Permitted parent elements:</i></p><ul><li>any XSLT element whose content model is <i>content constructor</i></li><li>any literal result element</li></ul></td></tr></table><p><b><a href="#element-attribute">xsl:attribute</a></b></p><table width="100%"><tr><td width="10%">&nbsp;</td><td><p><i>Category: </i>instruction</p><p><i>Model:</i></p><p class="element-syntax-summary"><code>&lt;xsl:attribute<br>&nbsp;&nbsp;<b>name</b> = { <var>qname</var> }<br>&nbsp;&nbsp;namespace = { <var>uri-reference</var> }<br>&nbsp;&nbsp;type-annotation = <var>qname</var><br>&nbsp;&nbsp;disable-output-escaping = "yes" | "no"&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>content-constructor</var> --&gt;<br>&lt;/xsl:attribute&gt;</code></p><p><i>Permitted parent elements:</i></p><ul><li><code>xsl:attribute-set</code></li><li>any XSLT element whose content model is <i>content constructor</i></li><li>any literal result element</li></ul></td></tr></table><p><b><a href="#element-attribute-set">xsl:attribute-set</a></b></p><table width="100%"><tr><td width="10%">&nbsp;</td><td><p><i>Category: </i>declaration</p><p><i>Model:</i></p><p class="element-syntax-summary"><code>&lt;xsl:attribute-set<br>&nbsp;&nbsp;<b>name</b> = <var>qname</var><br>&nbsp;&nbsp;use-attribute-sets = <var>qnames</var>&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <a href="#element-attribute">xsl:attribute</a>* --&gt;<br>&lt;/xsl:attribute-set&gt;</code></p><p><i>Permitted parent elements:</i></p><ul><li><code>xsl:stylesheet</code></li><li><code>xsl:transform</code></li></ul></td></tr></table><p><b><a href="#element-call-template">xsl:call-template</a></b></p><table width="100%"><tr><td width="10%">&nbsp;</td><td><p><i>Category: </i>instruction</p><p><i>Model:</i></p><p class="element-syntax-summary"><code>&lt;xsl:call-template<br>&nbsp;&nbsp;<b>name</b> = <var>qname</var>&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <a href="#element-with-param">xsl:with-param</a>* --&gt;<br>&lt;/xsl:call-template&gt;</code></p><p><i>Permitted parent elements:</i></p><ul><li>any XSLT element whose content model is <i>content constructor</i></li><li>any literal result element</li></ul></td></tr></table><p><b><a href="#element-choose">xsl:choose</a></b></p><table width="100%"><tr><td width="10%">&nbsp;</td><td><p><i>Category: </i>instruction</p><p><i>Model:</i></p><p class="element-syntax-summary"><code>&lt;xsl:choose&gt;<br>&nbsp;&nbsp;&lt;!-- Content: (<a href="#element-when">xsl:when</a>+, <a href="#element-otherwise">xsl:otherwise</a>?) --&gt;<br>&lt;/xsl:choose&gt;</code></p><p><i>Permitted parent elements:</i></p><ul><li>any XSLT element whose content model is <i>content constructor</i></li><li>any literal result element</li></ul></td></tr></table><p><b><a href="#element-comment">xsl:comment</a></b></p><table width="100%"><tr><td width="10%">&nbsp;</td><td><p><i>Category: </i>instruction</p><p><i>Model:</i></p><p class="element-syntax-summary"><code>&lt;xsl:comment&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>content-constructor</var> --&gt;<br>&lt;/xsl:comment&gt;</code></p><p><i>Permitted parent elements:</i></p><ul><li>any XSLT element whose content model is <i>content constructor</i></li><li>any literal result element</li></ul></td></tr></table><p><b><a href="#element-copy">xsl:copy</a></b></p><table width="100%"><tr><td width="10%">&nbsp;</td><td><p><i>Category: </i>instruction</p><p><i>Model:</i></p><p class="element-syntax-summary"><code>&lt;xsl:copy<br>&nbsp;&nbsp;copy-namespaces = "yes" | "no"<br>&nbsp;&nbsp;use-attribute-sets = <var>qnames</var>&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>content-constructor</var> --&gt;<br>&lt;/xsl:copy&gt;</code></p><p><i>Permitted parent elements:</i></p><ul><li>any XSLT element whose content model is <i>content constructor</i></li><li>any literal result element</li></ul></td></tr></table><p><b><a href="#element-copy-of">xsl:copy-of</a></b></p><table width="100%"><tr><td width="10%">&nbsp;</td><td><p><i>Category: </i>instruction</p><p><i>Model:</i></p><p class="element-syntax-summary"><code>&lt;xsl:copy-of<br>&nbsp;&nbsp;<b>select</b> = <var>expression</var><br>&nbsp;&nbsp;separator = { <var>string</var> }<br>&nbsp;&nbsp;copy-namespaces = "yes" | "no"<br>&nbsp;&nbsp;copy-type-annotations = "yes" | "no"&nbsp;/&gt;</code></p><p><i>Permitted parent elements:</i></p><ul><li>any XSLT element whose content model is <i>content constructor</i></li><li>any literal result element</li></ul></td></tr></table><p><b><a href="#element-decimal-format">xsl:decimal-format</a></b></p><table width="100%"><tr><td width="10%">&nbsp;</td><td><p><i>Category: </i>declaration</p><p><i>Model:</i></p><p class="element-syntax-summary"><code>&lt;xsl:decimal-format<br>&nbsp;&nbsp;name = <var>qname</var><br>&nbsp;&nbsp;decimal-separator = <var>char</var><br>&nbsp;&nbsp;grouping-separator = <var>char</var><br>&nbsp;&nbsp;infinity = <var>string</var><br>&nbsp;&nbsp;minus-sign = <var>char</var><br>&nbsp;&nbsp;NaN = <var>string</var><br>&nbsp;&nbsp;percent = <var>char</var><br>&nbsp;&nbsp;per-mille = <var>char</var><br>&nbsp;&nbsp;zero-digit = <var>char</var><br>&nbsp;&nbsp;digit = <var>char</var><br>&nbsp;&nbsp;pattern-separator = <var>char</var>&nbsp;/&gt;</code></p><p><i>Permitted parent elements:</i></p><ul><li><code>xsl:stylesheet</code></li><li><code>xsl:transform</code></li></ul></td></tr></table><p><b><a href="#element-element">xsl:element</a></b></p><table width="100%"><tr><td width="10%">&nbsp;</td><td><p><i>Category: </i>instruction</p><p><i>Model:</i></p><p class="element-syntax-summary"><code>&lt;xsl:element<br>&nbsp;&nbsp;<b>name</b> = { <var>qname</var> }<br>&nbsp;&nbsp;namespace = { <var>uri-reference</var> }<br>&nbsp;&nbsp;use-attribute-sets = <var>qnames</var><br>&nbsp;&nbsp;type-annotation = <var>qname</var>&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>content-constructor</var> --&gt;<br>&lt;/xsl:element&gt;</code></p><p><i>Permitted parent elements:</i></p><ul><li>any XSLT element whose content model is <i>content constructor</i></li><li>any literal result element</li></ul></td></tr></table><p><b><a href="#element-fallback">xsl:fallback</a></b></p><table width="100%"><tr><td width="10%">&nbsp;</td><td><p><i>Category: </i>instruction</p><p><i>Model:</i></p><p class="element-syntax-summary"><code>&lt;xsl:fallback&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>content-constructor</var> --&gt;<br>&lt;/xsl:fallback&gt;</code></p><p><i>Permitted parent elements:</i></p><ul><li>any XSLT element whose content model is <i>content constructor</i></li><li>any literal result element</li></ul></td></tr></table><p><b><a href="#element-for-each">xsl:for-each</a></b></p><table width="100%"><tr><td width="10%">&nbsp;</td><td><p><i>Category: </i>instruction</p><p><i>Model:</i></p><p class="element-syntax-summary"><code>&lt;xsl:for-each<br>&nbsp;&nbsp;<b>select</b> = <var>sequence-expression</var>&gt;<br>&nbsp;&nbsp;&lt;!-- Content: (<a href="#element-sort">xsl:sort</a>*, <var>content-constructor</var>) --&gt;<br>&lt;/xsl:for-each&gt;</code></p><p><i>Permitted parent elements:</i></p><ul><li>any XSLT element whose content model is <i>content constructor</i></li><li>any literal result element</li></ul></td></tr></table><p><b><a href="#element-for-each-group">xsl:for-each-group</a></b></p><table width="100%"><tr><td width="10%">&nbsp;</td><td><p><i>Category: </i>instruction</p><p><i>Model:</i></p><p class="element-syntax-summary"><code>&lt;xsl:for-each-group<br>&nbsp;&nbsp;<b>select</b> = <var>expression</var><br>&nbsp;&nbsp;group-by = <var>expression</var><br>&nbsp;&nbsp;group-adjacent = <var>expression</var><br>&nbsp;&nbsp;group-starting-with = <var>pattern</var><br>&nbsp;&nbsp;group-ending-with = <var>pattern</var><br>&nbsp;&nbsp;collation = { <var>uri</var> }<br>&nbsp;&nbsp;as = <var>qname</var>&gt;<br>&nbsp;&nbsp;&lt;!-- Content: (<a href="#element-sort">xsl:sort</a>*, <var>content-constructor</var>) --&gt;<br>&lt;/xsl:for-each-group&gt;</code></p><p><i>Permitted parent elements:</i></p><ul><li>any XSLT element whose content model is <i>content constructor</i></li><li>any literal result element</li></ul></td></tr></table><p><b><a href="#element-function">xsl:function</a></b></p><table width="100%"><tr><td width="10%">&nbsp;</td><td><p><i>Category: </i>declaration</p><p><i>Model:</i></p><p class="element-syntax-summary"><code>&lt;xsl:function<br>&nbsp;&nbsp;<b>name</b> = <var>qname</var><br>&nbsp;&nbsp;override = "yes" | "no"&gt;<br>&nbsp;&nbsp;&lt;!-- Content: (<a href="#element-param">xsl:param</a>*, (<a href="#element-variable">xsl:variable</a> | <a href="#element-message">xsl:message</a>)*, <a href="#element-result">xsl:result</a>) --&gt;<br>&lt;/xsl:function&gt;</code></p><p><i>Permitted parent elements:</i></p><ul><li><code>xsl:stylesheet</code></li><li><code>xsl:transform</code></li></ul></td></tr></table><p><b><a href="#element-if">xsl:if</a></b></p><table width="100%"><tr><td width="10%">&nbsp;</td><td><p><i>Category: </i>instruction</p><p><i>Model:</i></p><p class="element-syntax-summary"><code>&lt;xsl:if<br>&nbsp;&nbsp;<b>test</b> = <var>expression</var>&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>content-constructor</var> --&gt;<br>&lt;/xsl:if&gt;</code></p><p><i>Permitted parent elements:</i></p><ul><li>any XSLT element whose content model is <i>content constructor</i></li><li>any literal result element</li></ul></td></tr></table><p><b><a href="#element-import">xsl:import</a></b></p><table width="100%"><tr><td width="10%">&nbsp;</td><td><p><i>Category: </i>declaration</p><p><i>Model:</i></p><p class="element-syntax-summary"><code>&lt;xsl:import<br>&nbsp;&nbsp;<b>href</b> = <var>uri-reference</var>&nbsp;/&gt;</code></p><p><i>Permitted parent elements:</i></p><ul><li><code>xsl:stylesheet</code></li><li><code>xsl:transform</code></li></ul></td></tr></table><p><b><a href="#element-import-schema">xsl:import-schema</a></b></p><table width="100%"><tr><td width="10%">&nbsp;</td><td><p><i>Category: </i>declaration</p><p><i>Model:</i></p><p class="element-syntax-summary"><code>&lt;xsl:import-schema<br>&nbsp;&nbsp;namespace = <var>uri-reference</var><br>&nbsp;&nbsp;schema-location = <var>uri-reference</var>&nbsp;/&gt;</code></p><p><i>Permitted parent elements:</i></p><ul><li><code>xsl:stylesheet</code></li><li><code>xsl:transform</code></li></ul></td></tr></table><p><b><a href="#element-include">xsl:include</a></b></p><table width="100%"><tr><td width="10%">&nbsp;</td><td><p><i>Category: </i>declaration</p><p><i>Model:</i></p><p class="element-syntax-summary"><code>&lt;xsl:include<br>&nbsp;&nbsp;<b>href</b> = <var>uri-reference</var>&nbsp;/&gt;</code></p><p><i>Permitted parent elements:</i></p><ul><li><code>xsl:stylesheet</code></li><li><code>xsl:transform</code></li></ul></td></tr></table><p><b><a href="#element-key">xsl:key</a></b></p><table width="100%"><tr><td width="10%">&nbsp;</td><td><p><i>Category: </i>declaration</p><p><i>Model:</i></p><p class="element-syntax-summary"><code>&lt;xsl:key<br>&nbsp;&nbsp;<b>name</b> = <var>qname</var><br>&nbsp;&nbsp;<b>match</b> = <var>pattern</var><br>&nbsp;&nbsp;<b>use</b> = <var>expression</var><br>&nbsp;&nbsp;as = <var>qname</var><br>&nbsp;&nbsp;collation = <var>uri</var>&nbsp;/&gt;</code></p><p><i>Permitted parent elements:</i></p><ul><li><code>xsl:stylesheet</code></li><li><code>xsl:transform</code></li></ul></td></tr></table><p><b><a href="#element-matching-substring">xsl:matching-substring</a></b></p><table width="100%"><tr><td width="10%">&nbsp;</td><td><p><i>Model:</i></p><p class="element-syntax-summary"><code>&lt;xsl:matching-substring&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>content-constructor</var> --&gt;<br>&lt;/xsl:matching-substring&gt;</code></p><p><i>Permitted parent elements:</i></p><ul><li><code>xsl:analyze-string</code></li></ul></td></tr></table><p><b><a href="#element-message">xsl:message</a></b></p><table width="100%"><tr><td width="10%">&nbsp;</td><td><p><i>Category: </i>instruction</p><p><i>Model:</i></p><p class="element-syntax-summary"><code>&lt;xsl:message<br>&nbsp;&nbsp;terminate = { "yes" | "no" }&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>content-constructor</var> --&gt;<br>&lt;/xsl:message&gt;</code></p><p><i>Permitted parent elements:</i></p><ul><li>any XSLT element whose content model is <i>content constructor</i></li><li>any literal result element</li><li><code>xsl:function</code></li></ul></td></tr></table><p><b><a href="#element-namespace">xsl:namespace</a></b></p><table width="100%"><tr><td width="10%">&nbsp;</td><td><p><i>Category: </i>instruction</p><p><i>Model:</i></p><p class="element-syntax-summary"><code>&lt;xsl:namespace<br>&nbsp;&nbsp;<b>name</b> = { <var>ncname</var> }&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>content-constructor</var> --&gt;<br>&lt;/xsl:namespace&gt;</code></p><p><i>Permitted parent elements:</i></p><ul><li>any XSLT element whose content model is <i>content constructor</i></li><li>any literal result element</li></ul></td></tr></table><p><b><a href="#element-namespace-alias">xsl:namespace-alias</a></b></p><table width="100%"><tr><td width="10%">&nbsp;</td><td><p><i>Category: </i>declaration</p><p><i>Model:</i></p><p class="element-syntax-summary"><code>&lt;xsl:namespace-alias<br>&nbsp;&nbsp;<b>stylesheet-prefix</b> = <var>prefix</var> | "#default"<br>&nbsp;&nbsp;<b>result-prefix</b> = <var>prefix</var> | "#default"&nbsp;/&gt;</code></p><p><i>Permitted parent elements:</i></p><ul><li><code>xsl:stylesheet</code></li><li><code>xsl:transform</code></li></ul></td></tr></table><p><b><a href="#element-non-matching-substring">xsl:non-matching-substring</a></b></p><table width="100%"><tr><td width="10%">&nbsp;</td><td><p><i>Model:</i></p><p class="element-syntax-summary"><code>&lt;xsl:non-matching-substring&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>content-constructor</var> --&gt;<br>&lt;/xsl:non-matching-substring&gt;</code></p><p><i>Permitted parent elements:</i></p><ul><li><code>xsl:analyze-string</code></li></ul></td></tr></table><p><b><a href="#element-number">xsl:number</a></b></p><table width="100%"><tr><td width="10%">&nbsp;</td><td><p><i>Category: </i>instruction</p><p><i>Model:</i></p><p class="element-syntax-summary"><code>&lt;xsl:number<br>&nbsp;&nbsp;level = "single" | "multiple" | "any"<br>&nbsp;&nbsp;count = <var>pattern</var><br>&nbsp;&nbsp;from = <var>pattern</var><br>&nbsp;&nbsp;value = <var>number-expression</var><br>&nbsp;&nbsp;format = { <var>string</var> }<br>&nbsp;&nbsp;lang = { <var>nmtoken</var> }<br>&nbsp;&nbsp;letter-value = { "alphabetic" | "traditional" }<br>&nbsp;&nbsp;grouping-separator = { <var>char</var> }<br>&nbsp;&nbsp;grouping-size = { <var>number</var> }&nbsp;/&gt;</code></p><p><i>Permitted parent elements:</i></p><ul><li>any XSLT element whose content model is <i>content constructor</i></li><li>any literal result element</li></ul></td></tr></table><p><b><a href="#element-otherwise">xsl:otherwise</a></b></p><table width="100%"><tr><td width="10%">&nbsp;</td><td><p><i>Model:</i></p><p class="element-syntax-summary"><code>&lt;xsl:otherwise&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>content-constructor</var> --&gt;<br>&lt;/xsl:otherwise&gt;</code></p><p><i>Permitted parent elements:</i></p><ul><li><code>xsl:choose</code></li></ul></td></tr></table><p><b><a href="#element-output">xsl:output</a></b></p><table width="100%"><tr><td width="10%">&nbsp;</td><td><p><i>Category: </i>declaration</p><p><i>Model:</i></p><p class="element-syntax-summary"><code>&lt;xsl:output<br>&nbsp;&nbsp;name = <var>qname</var><br>&nbsp;&nbsp;method = "xml" | "html" | "xhtml" | "text" | <var>qname-but-not-ncname</var><br>&nbsp;&nbsp;version = <var>nmtoken</var><br>&nbsp;&nbsp;encoding = <var>string</var><br>&nbsp;&nbsp;omit-xml-declaration = "yes" | "no"<br>&nbsp;&nbsp;standalone = "yes" | "no"<br>&nbsp;&nbsp;doctype-public = <var>string</var><br>&nbsp;&nbsp;doctype-system = <var>string</var><br>&nbsp;&nbsp;cdata-section-elements = <var>qnames</var><br>&nbsp;&nbsp;escape-uri-attributes = "yes" | "no"<br>&nbsp;&nbsp;include-content-type = "yes" | "no"<br>&nbsp;&nbsp;indent = "yes" | "no"<br>&nbsp;&nbsp;media-type = <var>string</var><br>&nbsp;&nbsp;normalize-unicode = "yes" | "no"&nbsp;/&gt;</code></p><p><i>Permitted parent elements:</i></p><ul><li><code>xsl:stylesheet</code></li><li><code>xsl:transform</code></li></ul></td></tr></table><p><b><a href="#element-param">xsl:param</a></b></p><table width="100%"><tr><td width="10%">&nbsp;</td><td><p><i>Category: </i>declaration</p><p><i>Model:</i></p><p class="element-syntax-summary"><code>&lt;xsl:param<br>&nbsp;&nbsp;<b>name</b> = <var>qname</var><br>&nbsp;&nbsp;select = <var>expression</var><br>&nbsp;&nbsp;as = <var>sequence-type</var><br>&nbsp;&nbsp;required = "yes" | "no"<br>&nbsp;&nbsp;type-information = "strict" | "lax" | "preserve" | "none"&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>content-constructor</var> --&gt;<br>&lt;/xsl:param&gt;</code></p><p><i>Permitted parent elements:</i></p><ul><li><code>xsl:stylesheet</code></li><li><code>xsl:transform</code></li><li><code>xsl:function</code></li><li><code>xsl:template</code></li></ul></td></tr></table><p><b><a href="#element-preserve-space">xsl:preserve-space</a></b></p><table width="100%"><tr><td width="10%">&nbsp;</td><td><p><i>Category: </i>declaration</p><p><i>Model:</i></p><p class="element-syntax-summary"><code>&lt;xsl:preserve-space<br>&nbsp;&nbsp;<b>elements</b> = <var>tokens</var>&nbsp;/&gt;</code></p><p><i>Permitted parent elements:</i></p><ul><li><code>xsl:stylesheet</code></li><li><code>xsl:transform</code></li></ul></td></tr></table><p><b><a href="#element-processing-instruction">xsl:processing-instruction</a></b></p><table width="100%"><tr><td width="10%">&nbsp;</td><td><p><i>Category: </i>instruction</p><p><i>Model:</i></p><p class="element-syntax-summary"><code>&lt;xsl:processing-instruction<br>&nbsp;&nbsp;<b>name</b> = { <var>ncname</var> }&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>content-constructor</var> --&gt;<br>&lt;/xsl:processing-instruction&gt;</code></p><p><i>Permitted parent elements:</i></p><ul><li>any XSLT element whose content model is <i>content constructor</i></li><li>any literal result element</li></ul></td></tr></table><p><b><a href="#element-result">xsl:result</a></b></p><table width="100%"><tr><td width="10%">&nbsp;</td><td><p><i>Model:</i></p><p class="element-syntax-summary"><code>&lt;xsl:result<br>&nbsp;&nbsp;select = <var>expression</var><br>&nbsp;&nbsp;as = <var>sequence-type</var><br>&nbsp;&nbsp;type-information = "strict" | "lax" | "preserve" | "none"&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>content-constructor</var> --&gt;<br>&lt;/xsl:result&gt;</code></p><p><i>Permitted parent elements:</i></p><ul><li><code>xsl:function</code></li></ul></td></tr></table><p><b><a href="#element-result-document">xsl:result-document</a></b></p><table width="100%"><tr><td width="10%">&nbsp;</td><td><p><i>Category: </i>instruction</p><p><i>Model:</i></p><p class="element-syntax-summary"><code>&lt;xsl:result-document<br>&nbsp;&nbsp;format = <var>qname</var><br>&nbsp;&nbsp;href = { <var>uri-reference</var> }<br>&nbsp;&nbsp;type-information = "strict" | "lax" | "preserve" | "none"&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>content-constructor</var> --&gt;<br>&lt;/xsl:result-document&gt;</code></p><p><i>Permitted parent elements:</i></p><ul><li>any XSLT element whose content model is <i>content constructor</i></li><li>any literal result element</li></ul></td></tr></table><p><b><a href="#element-sort">xsl:sort</a></b></p><table width="100%"><tr><td width="10%">&nbsp;</td><td><p><i>Model:</i></p><p class="element-syntax-summary"><code>&lt;xsl:sort<br>&nbsp;&nbsp;select = <var>expression</var><br>&nbsp;&nbsp;lang = { <var>nmtoken</var> }<br>&nbsp;&nbsp;as = { <var>qname</var> }<br>&nbsp;&nbsp;order = { "ascending" | "descending" }<br>&nbsp;&nbsp;collation = { <var>uri</var> }<br>&nbsp;&nbsp;case-order = { "upper-first" | "lower-first" }<br>&nbsp;&nbsp;data-type = { "text" | "number" | <var>qname-but-not-ncname</var> }&nbsp;/&gt;</code></p><p><i>Permitted parent elements:</i></p><ul><li><code>xsl:sort-key</code></li><li><code>xsl:for-each</code></li><li><code>xsl:apply-templates</code></li><li><code>xsl:for-each-group</code></li></ul></td></tr></table><p><b><a href="#element-sort-key">xsl:sort-key</a></b></p><table width="100%"><tr><td width="10%">&nbsp;</td><td><p><i>Category: </i>declaration</p><p><i>Model:</i></p><p class="element-syntax-summary"><code>&lt;xsl:sort-key<br>&nbsp;&nbsp;<b>name</b> = <var>qname</var>&gt;<br>&nbsp;&nbsp;&lt;!-- Content: (<a href="#element-sort">xsl:sort</a>+) --&gt;<br>&lt;/xsl:sort-key&gt;</code></p><p><i>Permitted parent elements:</i></p><ul><li><code>xsl:stylesheet</code></li><li><code>xsl:transform</code></li></ul></td></tr></table><p><b><a href="#element-strip-space">xsl:strip-space</a></b></p><table width="100%"><tr><td width="10%">&nbsp;</td><td><p><i>Category: </i>declaration</p><p><i>Model:</i></p><p class="element-syntax-summary"><code>&lt;xsl:strip-space<br>&nbsp;&nbsp;<b>elements</b> = <var>tokens</var>&nbsp;/&gt;</code></p><p><i>Permitted parent elements:</i></p><ul><li><code>xsl:stylesheet</code></li><li><code>xsl:transform</code></li></ul></td></tr></table><p><b><a href="#element-stylesheet">xsl:stylesheet</a></b></p><table width="100%"><tr><td width="10%">&nbsp;</td><td><p><i>Model:</i></p><p class="element-syntax-summary"><code>&lt;xsl:stylesheet<br>&nbsp;&nbsp;id = <var>id</var><br>&nbsp;&nbsp;extension-element-prefixes = <var>tokens</var><br>&nbsp;&nbsp;exclude-result-prefixes = <var>tokens</var><br>&nbsp;&nbsp;<b>version</b> = <var>number</var><br>&nbsp;&nbsp;default-xpath-namespace = <var>uri</var>&gt;<br>&nbsp;&nbsp;&lt;!-- Content: (<a href="#element-import">xsl:import</a>*, <var>other-declarations</var>) --&gt;<br>&lt;/xsl:stylesheet&gt;</code></p><p><i>Permitted parent elements:</i></p><ul><li>None</li></ul></td></tr></table><p><b><a href="#element-template">xsl:template</a></b></p><table width="100%"><tr><td width="10%">&nbsp;</td><td><p><i>Category: </i>declaration</p><p><i>Model:</i></p><p class="element-syntax-summary"><code>&lt;xsl:template<br>&nbsp;&nbsp;match = <var>pattern</var><br>&nbsp;&nbsp;name = <var>qname</var><br>&nbsp;&nbsp;priority = <var>number</var><br>&nbsp;&nbsp;mode = <var>tokens</var>&gt;<br>&nbsp;&nbsp;&lt;!-- Content: (<a href="#element-param">xsl:param</a>*, <var>content-constructor</var>) --&gt;<br>&lt;/xsl:template&gt;</code></p><p><i>Permitted parent elements:</i></p><ul><li><code>xsl:stylesheet</code></li><li><code>xsl:transform</code></li></ul></td></tr></table><p><b><a href="#element-text">xsl:text</a></b></p><table width="100%"><tr><td width="10%">&nbsp;</td><td><p><i>Category: </i>instruction</p><p><i>Model:</i></p><p class="element-syntax-summary"><code>&lt;xsl:text<br>&nbsp;&nbsp;disable-output-escaping = "yes" | "no"&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>content-constructor</var> --&gt;<br>&lt;/xsl:text&gt;</code></p><p><i>Permitted parent elements:</i></p><ul><li>any XSLT element whose content model is <i>content constructor</i></li><li>any literal result element</li></ul></td></tr></table><p><b><a href="#element-transform">xsl:transform</a></b></p><table width="100%"><tr><td width="10%">&nbsp;</td><td><p><i>Model:</i></p><p class="element-syntax-summary"><code>&lt;xsl:transform<br>&nbsp;&nbsp;id = <var>id</var><br>&nbsp;&nbsp;extension-element-prefixes = <var>tokens</var><br>&nbsp;&nbsp;exclude-result-prefixes = <var>tokens</var><br>&nbsp;&nbsp;<b>version</b> = <var>number</var><br>&nbsp;&nbsp;default-xpath-namespace = <var>uri</var>&gt;<br>&nbsp;&nbsp;&lt;!-- Content: (<a href="#element-import">xsl:import</a>*, <var>other-declarations</var>) --&gt;<br>&lt;/xsl:transform&gt;</code></p><p><i>Permitted parent elements:</i></p><ul><li>None</li></ul></td></tr></table><p><b><a href="#element-value-of">xsl:value-of</a></b></p><table width="100%"><tr><td width="10%">&nbsp;</td><td><p><i>Category: </i>instruction</p><p><i>Model:</i></p><p class="element-syntax-summary"><code>&lt;xsl:value-of<br>&nbsp;&nbsp;<b>select</b> = <var>expression</var><br>&nbsp;&nbsp;separator = { <var>string</var> }<br>&nbsp;&nbsp;disable-output-escaping = "yes" | "no"&nbsp;/&gt;</code></p><p><i>Permitted parent elements:</i></p><ul><li>any XSLT element whose content model is <i>content constructor</i></li><li>any literal result element</li></ul></td></tr></table><p><b><a href="#element-variable">xsl:variable</a></b></p><table width="100%"><tr><td width="10%">&nbsp;</td><td><p><i>Category: </i>declaration</p><p><i>Model:</i></p><p class="element-syntax-summary"><code>&lt;xsl:variable<br>&nbsp;&nbsp;<b>name</b> = <var>qname</var><br>&nbsp;&nbsp;select = <var>expression</var><br>&nbsp;&nbsp;as = <var>sequence-type</var><br>&nbsp;&nbsp;type-information = "strict" | "lax" | "preserve" | "none"&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>content-constructor</var> --&gt;<br>&lt;/xsl:variable&gt;</code></p><p><i>Permitted parent elements:</i></p><ul><li><code>xsl:stylesheet</code></li><li><code>xsl:transform</code></li><li><code>xsl:function</code></li><li>any XSLT element whose content model is <i>content constructor</i></li><li>any literal result element</li></ul></td></tr></table><p><b><a href="#element-when">xsl:when</a></b></p><table width="100%"><tr><td width="10%">&nbsp;</td><td><p><i>Model:</i></p><p class="element-syntax-summary"><code>&lt;xsl:when<br>&nbsp;&nbsp;<b>test</b> = <var>expression</var>&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>content-constructor</var> --&gt;<br>&lt;/xsl:when&gt;</code></p><p><i>Permitted parent elements:</i></p><ul><li><code>xsl:choose</code></li></ul></td></tr></table><p><b><a href="#element-with-param">xsl:with-param</a></b></p><table width="100%"><tr><td width="10%">&nbsp;</td><td><p><i>Model:</i></p><p class="element-syntax-summary"><code>&lt;xsl:with-param<br>&nbsp;&nbsp;<b>name</b> = <var>qname</var><br>&nbsp;&nbsp;select = <var>expression</var><br>&nbsp;&nbsp;type-information = "strict" | "lax" | "preserve" | "none"&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>content-constructor</var> --&gt;<br>&lt;/xsl:with-param&gt;</code></p><p><i>Permitted parent elements:</i></p><ul><li><code>xsl:apply-templates</code></li><li><code>xsl:apply-imports</code></li><li><code>xsl:call-template</code></li></ul></td></tr></table></div><div class="div1">
<h2><a name="error-summary" id="error-summary"></a>D Summary of Error Conditions (Non-Normative)</h2><p>This appendix provides a summary of error conditions that a processor
may signal. This list is not exhaustive or definitive. The errors are numbered
for ease of reference, but there is no implication that an implementation should
report errors using these error codes, or that applications can test for these codes.
Moreover, implementations are not required to report errors using the descriptive
text used here.</p><p><b>Static errors</b></p><table><tr><td width="10%" valign="top"><p><a href="#d5e477">ERR001</a></p></td><td valign="top"><p>A <a title="static error" href="#dt-static-error">static error</a> is signaled
 if an XSLT-defined element is used in a context
  where it is not permitted, if a required attribute is omitted,
  or if the content of the element does not correspond to the
  content that is allowed for the element.</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e483">ERR002</a></p></td><td valign="top"><p>It is a <a title="static error" href="#dt-static-error">static error</a>
if an attribute (other than an attribute written using curly braces in 
a position where an
 <a title="attribute value template" href="#dt-attribute-value-template">attribute value template</a> is permitted) contains a value 
that is not one of the permitted values for that attribute.</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e1712">ERR007</a></p></td><td valign="top"><p>It is a <a title="static error" href="#dt-static-error">static error</a> for
 an element from the XSLT namespace to have an attribute 
 whose namespace is either null 
(i.e. an attribute with an unprefixed name) or the XSLT namespace, other than attributes defined
for the element in this document.</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e1851">ERR008</a></p></td><td valign="top"><p>It is a <a title="static error" href="#dt-static-error">static error</a>
 to use a <a title="reserved namespace" href="#dt-reserved-namespace">reserved namespace</a> in the name of 
 a <a title="named template" href="#dt-named-template">named template</a>,
 a <a title="mode" href="#dt-mode">mode</a>,
 an <a title="attribute set" href="#dt-attribute-set">attribute set</a>, 
 a <a title="key" href="#dt-key">key</a>,
a named <a title="sort specification" href="#dt-sort-specification">sort specification</a>,
a <a title="decimal-format" href="#dt-decimal-format">decimal-format</a>,
 a <a title="variable" href="#dt-variable">variable</a> or <a title="parameter" href="#dt-parameter">parameter</a>,
a <a title="stylesheet function" href="#dt-stylesheet-function">stylesheet function</a>, or a
named <a title="output definition" href="#dt-output-definition">output definition</a>.</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e2144">ERR009</a></p></td><td valign="top"><p>An <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> element must have a
<code>version</code> attribute, indicating the version of XSLT that
the stylesheet requires.</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e2153">ERR010</a></p></td><td valign="top"><p>The value of the <code>version</code> attribute
  [of the <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> element] 
must be a number (specifically, it must be a <u>DecimalLiteral</u> as defined
 in <a href="#XPATH20">[XPath 2.0]</a>.)</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e2182">ERR011</a></p></td><td valign="top"><p>An <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> element must have
no text node children, other than text nodes consisting entirely of whitespace.</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e2353">ERR012</a></p></td><td valign="top"><p>It is a <a title="static error" href="#dt-static-error">static error</a>
 if the <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> element has
a child element having a null namespace URI.</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e2406">ERR013</a></p></td><td valign="top"><p>A <a title="user-defined data element" href="#dt-data-element">user-defined data element</a>
must not precede an <a href="#element-import"><code>xsl:import</code></a> element within a
<a title="stylesheet module" href="#dt-stylesheet-module">stylesheet module</a>.</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e2478">ERR014</a></p></td><td valign="top"><p>A <a title="literal result element" href="#dt-literal-result-element">literal result element</a> that
 is used as the outermost element of a
simplified stylesheet module must have
 an <code>xsl:version</code> attribute.</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e2834">ERR017</a></p></td><td valign="top"><p>The <a href="#element-include"><code>xsl:include</code></a> element is allowed only as a
 <a title="top-level" href="#dt-top-level">top-level</a> element.</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e2897">ERR018</a></p></td><td valign="top"><p>It is an <a title="static error" href="#dt-static-error">static error</a> 
if a stylesheet module
 directly or indirectly includes itself.</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e3036">ERR019</a></p></td><td valign="top"><p>The <a href="#element-import"><code>xsl:import</code></a>
							<a title="declaration" href="#dt-declaration">declaration</a> 
is allowed only as a <a title="top-level" href="#dt-top-level">top-level</a> element.</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e3048">ERR020</a></p></td><td valign="top"><p>The
<a href="#element-import"><code>xsl:import</code></a> element children must precede all other
element children of an <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> element, including
any <a href="#element-include"><code>xsl:include</code></a> element children and any
<a title="user-defined data element" href="#dt-data-element">user-defined data elements</a>.</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e3170">ERR021</a></p></td><td valign="top"><p>It is a <a title="static error" href="#dt-static-error">static error</a> if
 a stylesheet module directly or indirectly imports itself.</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e3300">ERR022</a></p></td><td valign="top"><p>It is a static error if the processor is not able to locate a schema using the <code>namespace</code>
and/or <code>schema-location</code> attributes  [of the <a href="#element-import-schema"><code>xsl:import-schema</code></a>
declaration] , or if the document that it locates is neither a valid XML Schema nor any other resource that the
implementation can process.</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e3317">ERR023</a></p></td><td valign="top"><p>It is a static error if two <a href="#element-import-schema"><code>xsl:import-schema</code></a> declarations yield multiple
definitions for the same named type, even if the definitions are consistent with each other.</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e3504">ERR024</a></p></td><td valign="top"><p>Within an XSLT element that is required to be empty,
  any content other than comments or processing instructions, including any whitespace-only
  text node preserved using the <code>xml:space="preserve"</code> attribute, is a
  <a title="static error" href="#dt-static-error">static error</a>.</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e4004">ERR027</a></p></td><td valign="top"><p>It is a <a title="static error" href="#dt-static-error">static error</a>
to use a reserved namespace URI in the name of any stylesheet-defined object. The reserved namespaces are 
listed in <a href="#xslt-namespace"><b>3.1 XSLT Namespace</b></a>.</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e4060">ERR028</a></p></td><td valign="top"><p>In the case of a <a title="QName" href="#dt-qname">QName</a> 
used as the value of an attribute in the
stylesheet, or appearing within the text of an XPath <a title="expression" href="#dt-expression">expression</a> in the the stylesheet,
it is a <a title="static error" href="#dt-static-error">static error</a> if the defining element has
no namespace node whose name matches the prefix of the <a title="QName" href="#dt-qname">QName</a>.</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e4144">ERR030</a></p></td><td valign="top"><p>Except where otherwise stated, it is a 
<a title="static error" href="#dt-static-error">static error</a>
if the value of such an 
attribute [an attribute defined as containing an XPath
 <a title="expression" href="#dt-expression">expression</a>] , or the text between curly
braces in an attribute value template, does not match the
XPath production <u>ExprSequence</u>, or if it fails to satisfy
other static constraints defined in the XPath specification, for example
that all variable references must refer to <a title="variable" href="#dt-variable">variables</a> that are
in scope.</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e4621">ERR034</a></p></td><td valign="top"><p>Where an attribute is
defined to contain a <a title="pattern" href="#dt-pattern">pattern</a>,
it is a <a title="static error" href="#dt-static-error">static error</a> if the
 pattern does not match the production <a href="#NT-Pattern">Pattern</a>.</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e5085">ERR035</a></p></td><td valign="top"><p>It is a <a title="static error" href="#dt-static-error">static error</a>
if a left curly brace appears in an attribute value template without a matching right
curly brace.</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e5093">ERR036</a></p></td><td valign="top"><p>It is a <a title="static error" href="#dt-static-error">static error</a>
if the string contained between matching curly braces in an attribute value template
does not match the XPath production <u>Expr</u>.</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e5104">ERR037</a></p></td><td valign="top"><p>It is a <a title="static error" href="#dt-static-error">static error</a> 
if a right curly brace occurs in an attribute value template outside an <a title="expression" href="#dt-expression">expression</a> 
without being followed by a second right curly brace.</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e6082">ERR047</a></p></td><td valign="top"><p>The value of this
  [the <code>priority</code> attribute of the <a href="#element-template"><code>xsl:template</code></a> element] 
 must be a real number (positive or negative),
matching the production <u>NumericLiteral</u>
with an optional leading minus sign (<code>-</code>).</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e6100">ERR048</a></p></td><td valign="top"><p>If an <a href="#element-template"><code>xsl:template</code></a> element does not have
a <code>match</code> attribute, then it must not have a <code>priority</code>
attribute.</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e6324">ERR050</a></p></td><td valign="top"><p>If an <a href="#element-template"><code>xsl:template</code></a> element does not have
a <code>match</code> attribute, then it is a
 <a title="static error" href="#dt-static-error">static error</a> if it has a <code>mode</code>
attribute.</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e7097">ERR054</a></p></td><td valign="top"><p>It is an error
to specify the <code>type-information</code> attribute on a variable binding element that has 
empty content.</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e7224">ERR056</a></p></td><td valign="top"><p>It is an error
to specify the <code>type-information</code> attribute on an <a href="#element-param"><code>xsl:param</code></a> element that has 
empty content.</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e7308">ERR058</a></p></td><td valign="top"><p>If 
the <a title="variable-binding element" href="#dt-variable-binding-element">variable-binding element</a> has a <code>select</code>
attribute, then the value of the attribute must be an
<a title="expression" href="#dt-expression">expression</a> and the supplied value of the variable
is the value that results from evaluating the expression.  In this
case, the content of the variable-binding element must be empty.</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e7620">ERR061</a></p></td><td valign="top"><p>It is a
<a title="static error" href="#dt-static-error">static error</a> if a
 stylesheet contains more than one binding of a global
variable with the same name and same
 <a title="import precedence" href="#dt-import-precedence">import precedence</a>.</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e8103">ERR063</a></p></td><td valign="top"><p>It is a <a title="static error" href="#dt-static-error">static error</a> if a
 stylesheet contains more than one template with
the same name and the same <a title="import precedence" href="#dt-import-precedence">import
precedence</a>.</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e8140">ERR064</a></p></td><td valign="top"><p>It is a <a title="static error" href="#dt-static-error">static error</a> if
a stylesheet contains an <a href="#element-call-template"><code>xsl:call-template</code></a> instruction whose <code>name</code> attribute does
not match the <code>name</code> attribute of any <a href="#element-template"><code>xsl:template</code></a> in the stylesheet.</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e8210">ERR065</a></p></td><td valign="top"><p>It is a <a title="static error" href="#dt-static-error">static error</a> if
a single <a href="#element-call-template"><code>xsl:call-template</code></a>,
<a href="#element-apply-templates"><code>xsl:apply-templates</code></a> or <a href="#element-apply-imports"><code>xsl:apply-imports</code></a>
element contains more than one <a href="#element-with-param"><code>xsl:with-param</code></a> element
with the same name.</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e8283">ERR067</a></p></td><td valign="top"><p>In the case of <a href="#element-call-template"><code>xsl:call-template</code></a>,
it is a <a title="static error" href="#dt-static-error">static error</a> if
the template that is invoked declares a <a title="template parameter" href="#dt-template-parameter">template parameter</a> 
with <code>required="yes"</code> and no value for
this parameter is supplied by the calling instruction.</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e8640">ERR070</a></p></td><td valign="top"><p>A stylesheet function must have a prefixed name,
to remove any risk of a clash with a system-defined function. It is a 
<a title="static error" href="#dt-static-error">static error</a> if the name has no prefix.</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e8708">ERR071</a></p></td><td valign="top"><p>The <code>name</code> attribute
  [of the <a href="#element-function"><code>xsl:function</code></a> element] 
  must be in a non-null namespace: that is,
 it must be written with a prefix.</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e8753">ERR072</a></p></td><td valign="top"><p>Because arguments to a stylesheet
function call must all be specified, the <a href="#element-param"><code>xsl:param</code></a> elements within an
<a href="#element-function"><code>xsl:function</code></a> element must not specify a default value: this means they
must be empty, and must have no <code>select</code> attribute.</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e8791">ERR073</a></p></td><td valign="top"><p>It is a <a title="static error" href="#dt-static-error">static error</a> for
a stylesheet to contain two or more functions with the same <a title="expanded-QName" href="#dt-expanded-qname">expanded-QName</a>
and the same import precedence, unless there is another function with the
same <a title="expanded-QName" href="#dt-expanded-qname">expanded-QName</a> and a higher import precedence.</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e9147">ERR077</a></p></td><td valign="top"><p>It is a <a title="static error" href="#dt-static-error">static error</a>
if the value of the <code>xsl:type-annotation</code> attribute
 [of a literal result element] 
is not a <a title="QName" href="#dt-qname">QName</a>, or is a QName whose prefix cannot be resolved using the in-scope namespace
declarations, or is a QName that is not either the name of a built-in schema type, or
the name of a global type definition in a schema imported
using an <a href="#element-import-schema"><code>xsl:import-schema</code></a> declaration.</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e9491">ERR080</a></p></td><td valign="top"><p>It is
a <a title="static error" href="#dt-static-error">static error</a> if there is more
 than one such declaration 
  [more than one <a href="#element-namespace-alias"><code>xsl:namespace-alias</code></a> declaration] 
 with the same <code>stylesheet-prefix</code> and the same 
 <a title="import precedence" href="#dt-import-precedence">import precedence</a>
							 and different values for <code>namespace-uri</code>.  
						</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e9743">ERR083</a></p></td><td valign="top"><p>It is a <a title="static error" href="#dt-static-error">static error</a>
if the value of the <code>type-annotation</code> attribute
 [of the <a href="#element-element"><code>xsl:element</code></a> instruction] 
is not a <a title="QName" href="#dt-qname">QName</a>, or is a QName whose prefix cannot be resolved using the in-scope namespace
declarations, or is a QName that is not either the name of a built-in schema type, or
the name of a global type definition in a schema imported
using an <a href="#element-import-schema"><code>xsl:import-schema</code></a> declaration.</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e10053">ERR089</a></p></td><td valign="top"><p>It is a <a title="static error" href="#dt-static-error">static error</a>
if the value of the <code>type-annotation</code> attribute
 [of the <a href="#element-attribute"><code>xsl:attribute</code></a> instruction] 
is not a QName, or is a QName whose prefix cannot be resolved using the in-scope namespace
declarations, or is a QName that is not either the name of a built-in schema type, or
the name of a global type definition in a schema imported
using an <a href="#element-import-schema"><code>xsl:import-schema</code></a> declaration.</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e10173">ERR091</a></p></td><td valign="top"><p>It is a <a title="static error" href="#dt-static-error">static error</a>
to specify <code>disable-output-escaping="yes"</code> on an <a href="#element-text"><code>xsl:text</code></a> instruction that
has element node children.</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e11897">ERR101</a></p></td><td valign="top"><p>When used within <a href="#element-for-each"><code>xsl:for-each</code></a> or
<a href="#element-for-each-group"><code>xsl:for-each-group</code></a>, <a href="#element-sort"><code>xsl:sort</code></a>
elements must occur before any other children.</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e12644">ERR106</a></p></td><td valign="top"><p>It is a <a title="static error" href="#dt-static-error">static error</a> for
a stylesheet to contain two or more named sort specifications with the same <a title="expanded-QName" href="#dt-expanded-qname">expanded-QName</a>
and the same import precedence, unless there is another named sort specification with the
same <a title="expanded-QName" href="#dt-expanded-qname">expanded-QName</a> and a higher import precedence.</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e12763">ERR108</a></p></td><td valign="top"><p>The <a href="#function-current-group"><b>current-group</b></a> function must not be used
within a <a title="pattern" href="#dt-pattern">pattern</a>.</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e12872">ERR109</a></p></td><td valign="top"><p>These four attributes 
 [the <code>group-by</code>,  
<code>group-adjacent</code>, 
<code>group-starting-with</code>, and <code>group-ending-with</code>
 attributes of <a href="#element-for-each-group"><code>xsl:for-each-group</code></a>
						] 
are mutually exclusive: exactly one of the four attributes must be present.</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e12895">ERR110</a></p></td><td valign="top"><p>The <code>as</code> attribute,
if specified, must be the name of an atomic type (either a built-in type, or a type defined in an
imported schema).</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e12903">ERR111</a></p></td><td valign="top"><p>It is an error to specify either the
 <code>as</code> attribute or the <code>collation</code> attribute if neither the
<code>group-by</code> attribute nor <code>group-adjacent</code> attribute is specified.</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e14132">ERR121</a></p></td><td valign="top"><p>It is a static error if there are several <a href="#element-key"><code>xsl:key</code></a> declarations
in the stylesheet with the same key name and different  types, or if the  type is specified
in one of these declarations and omitted in another.</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e14149">ERR122</a></p></td><td valign="top"><p>It is a static error if there are several <a href="#element-key"><code>xsl:key</code></a> declarations
in the stylesheet with the same key name and different collation sequences, or if the collation is specified
in one of these declarations and omitted in another.</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e14157">ERR123</a></p></td><td valign="top"><p>It is a static error if the value of the <code>as</code> attribute
 [of the <a href="#element-key"><code>xsl:key</code></a> element]  is not an atomic type (optionally
followed by an occurrence count).</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e14171">ERR124</a></p></td><td valign="top"><p>It is a static error if a value is specified for the <code>collation</code> attribute
 [of the <a href="#element-key"><code>xsl:key</code></a> element] 
unless the <code>as</code> attribute is defaulted or set to <code>xs:string</code>.</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e14674">ERR129</a></p></td><td valign="top"><p>It is a <a title="static error" href="#dt-static-error">static error</a>
 to declare either the
default decimal-format or a decimal-format with a given name more than
once (even with different <a title="import precedence" href="#dt-import-precedence">import
precedence</a>), unless it is declared every time with the same
value for all attributes (taking into account any default values).</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e14840">ERR130</a></p></td><td valign="top"><p>It is a <a title="static error" href="#dt-static-error">static error</a> if,
 for any named or unnamed decimal format, the variables
representing characters used in a <a title="picture string" href="#dt-picture-string">picture string</a>
do not each have distinct values. These variables are <var>decimal-separator-sign</var>,
<var>grouping-sign</var>, <var>percent-sign</var>, <var>per-mille-sign</var>,
<var>digit-zero-sign</var>, <var>digit-sign</var>, and <var>pattern-separator-sign</var>.
</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e16537">ERR140</a></p></td><td valign="top"><p>It
is a <a title="static error" href="#dt-static-error">static error</a>
 if there is no namespace bound to the prefix on the
element bearing the <code>[xsl:]extension-element-prefixes</code> attribute.</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e17065">ERR145</a></p></td><td valign="top"><p>It is a <a title="static error" href="#dt-static-error">static error</a> if the
value of the <code>format</code> attribute 
 [of an <a href="#element-result-document"><code>xsl:result-document</code></a> element] 
is not a valid QName, or if it does not match the <a title="expanded-QName" href="#dt-expanded-qname">expanded-QName</a> of an 
<a title="output definition" href="#dt-output-definition">output definition</a> in the stylesheet.</p></td></tr></table><p><b>Type errors</b></p><table><tr><td width="10%" valign="top"><p><a href="#d5e4211">ERR032</a></p></td><td valign="top"><p>It is a 
<a title="type errors" href="#dt-type-error">type error</a>
if an XPath <a title="expression" href="#dt-expression">expression</a> raises a type error, or if the type
of the XPath expression is incompatible with the
<a title="required type" href="#dt-required-type">required type</a>. 

					<br><i>&nbsp;&nbsp;&nbsp;&nbsp;Action: </i>The processor must either signal a type error
as a <a title="static error" href="#dt-static-error">static error</a>, 
or must attempt to recover by converting
the result of the expression to the required type using the
<a title="argument conversion rules" href="#dt-argument-conversion-rules">argument conversion rules</a>; 
if conversion is not possible under these
rules, the processor must signal a
<a title="dynamic error" href="#dt-dynamic-error">dynamic error</a>
						</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e7063">ERR053</a></p></td><td valign="top"><p>If the <code>as</code> attribute 
 [of <a href="#element-variable"><code>xsl:variable</code></a> 
					] 
is specified, then the supplied value of the
variable is converted to the required type, using the 
<a title="argument conversion rules" href="#dt-argument-conversion-rules">argument conversion rules</a>.

It is a <a title="type errors" href="#dt-type-error">type error</a>
if this conversion fails.</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e7191">ERR055</a></p></td><td valign="top"><p>If the <code>as</code> attribute 
 [of <a href="#element-param"><code>xsl:param</code></a>] 
is specified, then the supplied value of the
parameter is converted to the required type, using 
<a title="argument conversion rules" href="#dt-argument-conversion-rules">argument conversion rules</a>.
It is a <a title="type errors" href="#dt-type-error">type error</a>
if this conversion fails.</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e7265">ERR057</a></p></td><td valign="top"><p>If the value of the <code>required</code> attribute is <code>no</code>, 
and the caller supplies
no value for the parameter, then it is a <a title="type errors" href="#dt-type-error">type error</a> if the default value
of the parameter cannot be converted to the required type, using the
<a title="argument conversion rules" href="#dt-argument-conversion-rules">argument conversion rules</a>. 
</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e9019">ERR076</a></p></td><td valign="top"><p>If the <code>as</code> attribute 
 [of <a href="#element-result"><code>xsl:result</code></a>
							] 
is specified, then the calculated result is converted to the required type,
using the <a title="argument conversion rules" href="#dt-argument-conversion-rules">argument conversion rules</a>.
It is a <a title="type errors" href="#dt-type-error">type error</a>
if this conversion fails.</p></td></tr></table><p><b>Dynamic errors</b></p><table><tr><td width="10%" valign="top"><p><a href="#d5e492">ERR003</a></p></td><td valign="top"><p>It is a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a>
if the <a title="effective value" href="#dt-effective-value">effective value</a> of an attribute written
 using curly braces, in 
a position where an <a title="attribute value template" href="#dt-attribute-value-template">attribute value template</a> is
 permitted, is a value 
that is not one of the permitted values for that attribute.</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e635">ERR004</a></p></td><td valign="top"><p>It is a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> if the invocation of the
stylesheet specifies a template name that does not match the
<a title="expanded-QName" href="#dt-expanded-qname">expanded-QName</a> of a named template defined in the stylesheet.</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e661">ERR005</a></p></td><td valign="top"><p>It is a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a>
 if the first template executed by the transformation defines <a title="template parameter" href="#dt-template-parameter">template parameter</a>
 that specifies <code>required="yes"</code>. <br><i>&nbsp;&nbsp;&nbsp;&nbsp;Action: </i>The processor must signal the error.</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e1129">ERR006</a></p></td><td valign="top"><p>When the focus is
undefined, evaluation of any <a title="expression" href="#dt-expression">expression</a> that references the context item, context position, or context size results
in a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a>. 
					<br><i>&nbsp;&nbsp;&nbsp;&nbsp;Action: </i>The processor must signal the
error.</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e2570">ERR015</a></p></td><td valign="top"><p>If the value
 [returned by an XPath <a title="expression" href="#dt-expression">expression</a>
 with backwards-compatible behavior]  
is an empty sequence or a sequence that consists entirely of nodes,
then it is converted to a node-set; it is a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a>
if the value is any other sequence of two or more items.

							<br><i>&nbsp;&nbsp;&nbsp;&nbsp;Action: </i>The <a title="processor" href="#dt-processor">processor</a> must signal the error.</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e2594">ERR016</a></p></td><td valign="top"><p>If an implementation does not support backwards-compatible
behavior, then it is a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a>
if any element is evaluated that enables 
backwards-compatible behavior.

					<br><i>&nbsp;&nbsp;&nbsp;&nbsp;Action: </i>The <a title="processor" href="#dt-processor">processor</a> must signal the error.</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e3606">ERR025</a></p></td><td valign="top"><p>It is an <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> if
 this  [the process of finding an <a href="#element-strip-space"><code>xsl:strip-space</code></a> or 
 <a href="#element-preserve-space"><code>xsl:preserve-space</code></a> declaration to match an element in the source document] 
 leaves more than one match.  
					<br><i>&nbsp;&nbsp;&nbsp;&nbsp;Action: </i>The <a title="processor" href="#dt-processor">processor</a> must either signal the error,
of must recover by choosing, from amongst the matches that are left, the
one that occurs last in
 <a title="declaration order" href="#dt-declaration-order">declaration order</a>.
 </p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e3839">ERR026</a></p></td><td valign="top"><p>It is a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> if
 such a document  [a source document, a document returned by the <u>fn:document</u>
 or by an extension function, or supplied as a stylesheet parameter]  does
  not already
satisfy the constraints listed above  [in summary, that the namespace nodes
on the tree are consistent with those produced by parsing a well-formed document
conforming to the XML Namespaces Recommendation] . 

					<br><i>&nbsp;&nbsp;&nbsp;&nbsp;Action: </i>The <a title="processor" href="#dt-processor">processor</a> may signal the error,
or may recover by performing namespace fixup, 
or may produce <a title="implementation-dependent" href="#dt-implementation-dependent">implementation-dependent</a>
 results.</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e4077">ERR029</a></p></td><td valign="top"><p>In the case of a <a title="QName" href="#dt-qname">QName</a> produced by evaluating 
an XPath <a title="expression" href="#dt-expression">expression</a>,
it is a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> if the defining element has
no namespace node whose name matches the prefix of the <a title="QName" href="#dt-qname">QName</a>. The error is a dynamic error
even if the value of the expression is known statically, for example if the QName is written
as a string literal. 
					<br><i>&nbsp;&nbsp;&nbsp;&nbsp;Action: </i>The required action depends on the defining
element.</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e4165">ERR031</a></p></td><td valign="top"><p>The transformation fails with a
 <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> if any XPath
  <a title="expression" href="#dt-expression">expression</a>
 is evaluated and raises a dynamic error. <br><i>&nbsp;&nbsp;&nbsp;&nbsp;Action: </i>The
  <a title="processor" href="#dt-processor">processor</a> must signal the error.</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e4338">ERR033</a></p></td><td valign="top"><p>It is a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> for
an <a title="expression" href="#dt-expression">expression</a> to call any function that is not included in the in-scope functions.

							<br><i>&nbsp;&nbsp;&nbsp;&nbsp;Action: </i>The <a title="processor" href="#dt-processor">processor</a> must signal the error,
but only if the function call is actually evaluated.</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e5487">ERR038</a></p></td><td valign="top"><p>It is an 
<a title="dynamic error" href="#dt-dynamic-error">dynamic error</a>
if an <a title="extension instruction" href="#dt-extension-instruction">extension instruction</a>
 attempts to return a sequence containing a document node.
 
					<br><i>&nbsp;&nbsp;&nbsp;&nbsp;Action: </i>The <a title="processor" href="#dt-processor">processor</a> must signal the error.</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e5504">ERR039</a></p></td><td valign="top"><p>It is a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> if
 the result sequence  [returned by a content constructor]  
 (after concatenating the results of individual instructions) contains a namespace node or
 attribute node that is preceded
in the sequence by a node that is neither a namespace node nor an attribute node. 

					<br><i>&nbsp;&nbsp;&nbsp;&nbsp;Action: </i>The <a title="processor" href="#dt-processor">processor</a> must either signal
the error, or must recover by ignoring the offending namespace or attribute node.
</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e5567">ERR041</a></p></td><td valign="top"><p>Elements such as <a href="#element-variable"><code>xsl:variable</code></a>, <a href="#element-param"><code>xsl:param</code></a>,
<a href="#element-message"><code>xsl:message</code></a>, and <a href="#element-result-document"><code>xsl:result-document</code></a> construct a new document node,
, which becomes the <a title="current destination node" href="#dt-current-destination-node">current
destination node</a> for the nodes in the result sequence returned by the content constructor.
								In this case it is an <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a>
 if the result sequence contains namespace
or attribute nodes. 
							<br><i>&nbsp;&nbsp;&nbsp;&nbsp;Action: </i>The <a title="processor" href="#dt-processor">processor</a> must either signal the error, or must recover by ignoring the offending
nodes.</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e5628">ERR042</a></p></td><td valign="top"><p>It is a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> if
the result sequence contains two or more namespace nodes having the same name but different string-values (that is, 
namespace nodes that map the same prefix to different namespace URIs).<br><i>&nbsp;&nbsp;&nbsp;&nbsp;Action: </i> The processor
must either signal the error, or must recover by ignoring all conflicting namespace nodes other than the one
that appears last in the result sequence.</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e5636">ERR043</a></p></td><td valign="top"><p>It is a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> if
the result sequence contains a namespace node with no name and the <a title="current destination node" href="#dt-current-destination-node">current destination node</a>
is an element with a null namespace URI (that is, to define a default namespace when the element is in no namespace).
<br><i>&nbsp;&nbsp;&nbsp;&nbsp;Action: </i>In both cases the <a title="processor" href="#dt-processor">processor</a> must either signal the error,
    or must recover by ignoring the offending namespace node.</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e5684">ERR044</a></p></td><td valign="top"><p>It is a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> 
if the result sequence  [produced by the <a href="#element-comment"><code>xsl:comment</code></a>, <a href="#element-attribute"><code>xsl:attribute</code></a>, 
<a href="#element-processing-instruction"><code>xsl:processing-instruction</code></a>, <a href="#element-text"><code>xsl:text</code></a>,
 or <a href="#element-namespace"><code>xsl:namespace</code></a> elements]  contains nodes other
than text nodes. 
							<br><i>&nbsp;&nbsp;&nbsp;&nbsp;Action: </i>The <a title="processor" href="#dt-processor">processor</a> must either signal the error, or must recover by ignoring
the non-text nodes together with their content.</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e5876">ERR045</a></p></td><td valign="top"><p>It is a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> if 
 [
							<a href="#element-apply-templates"><code>xsl:apply-templates</code></a> with no <code>select attribute</code> is evaluated when] 
the <a title="context item" href="#dt-context-item">context item</a> is not a node. 

					<br><i>&nbsp;&nbsp;&nbsp;&nbsp;Action: </i>The <a title="processor" href="#dt-processor">processor</a> must either signal the error, or
must recover by returning an empty sequence.</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e5933">ERR046</a></p></td><td valign="top"><p>It is a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> if 
the sequence returned by the <code>select</code> expression 
 [of <a href="#element-apply-templates"><code>xsl:apply-templates</code></a>
						] 
contains an item that is not a node.

					<br><i>&nbsp;&nbsp;&nbsp;&nbsp;Action: </i>The <a title="processor" href="#dt-processor">processor</a> must either signal the error, or must recover by ignoring the offending
items.</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e6201">ERR049</a></p></td><td valign="top"><p>It is a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> if
 this  [the conflict resolution algorithm for template rules] 
 leaves more than one matching template
rule.  
					<br><i>&nbsp;&nbsp;&nbsp;&nbsp;Action: </i>The <a title="processor" href="#dt-processor">processor</a> must either signal the error, or must recover by choosing, from amongst the matching
template rules that are left, the one that occurs last in
<a title="declaration order" href="#dt-declaration-order">declaration order</a>.</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e6522">ERR051</a></p></td><td valign="top"><p>It is an error if the <a href="#element-apply-imports"><code>xsl:apply-imports</code></a>
instruction is evaluated when the <a title="context item" href="#dt-context-item">context item</a> 
is not a node. 
					<br><i>&nbsp;&nbsp;&nbsp;&nbsp;Action: </i>The <a title="processor" href="#dt-processor">processor</a>
must either signal the error, or must recover by returning an empty sequence.</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e6552">ERR052</a></p></td><td valign="top"><p>It is a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> if
<a href="#element-apply-imports"><code>xsl:apply-imports</code></a> is evaluated when the
 <a title="current template rule" href="#dt-current-template-rule">current template rule</a> is null. 
 
					<br><i>&nbsp;&nbsp;&nbsp;&nbsp;Action: </i>The <a title="processor" href="#dt-processor">processor</a> must signal the error.</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e7534">ERR059</a></p></td><td valign="top"><p>If schema validation is requested and the document
 is not well-formed (that is, if it contains text nodes as children of the document node, or
 if the number of element children of the document root is not exactly one), a dynamic
 error occurs. 
					<br><i>&nbsp;&nbsp;&nbsp;&nbsp;Action: </i>The processor must signal the error.</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e7543">ERR060</a></p></td><td valign="top"><p>If schema validation is requested and the schema
 validity assessment concludes that the document is invalid, a dynamic
 error occurs. 
					<br><i>&nbsp;&nbsp;&nbsp;&nbsp;Action: </i>The processor must signal the error.</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e7955">ERR062</a></p></td><td valign="top"><p>In general, a <a title="circularity" href="#dt-circularity">circularity</a>
 in a stylesheet is a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a>.

					<br><i>&nbsp;&nbsp;&nbsp;&nbsp;Action: </i>The <a title="processor" href="#dt-processor">processor</a> must signal the error.</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e8263">ERR066</a></p></td><td valign="top"><p>In the case of <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> and
<a href="#element-apply-imports"><code>xsl:apply-imports</code></a>, it is a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> if
the template that is invoked declares a <a title="template parameter" href="#dt-template-parameter">template parameter</a>
 with <code>required="yes"</code> and no value for
this parameter is supplied by the calling instruction. <br><i>&nbsp;&nbsp;&nbsp;&nbsp;Action: </i>The processor must signal 
the error.</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e8417">ERR068</a></p></td><td valign="top"><p>It is a
 <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> if use
of <code>use-attribute-sets</code> attributes on
<a href="#element-attribute-set"><code>xsl:attribute-set</code></a> elements causes an attribute set to
use itself, directly or indirectly. 

					<br><i>&nbsp;&nbsp;&nbsp;&nbsp;Action: </i>The <a title="processor" href="#dt-processor">processor</a> must signal the error</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e8549">ERR069</a></p></td><td valign="top"><p>It
is a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> if there
 are two attribute sets that have the same
<a title="expanded-QName" href="#dt-expanded-qname">expanded-QName</a> and equal import precedence and that both contain
the same attribute, unless there is a definition of the attribute set
with higher <a title="import precedence" href="#dt-import-precedence">import
precedence</a> that also contains the attribute.  
					<br><i>&nbsp;&nbsp;&nbsp;&nbsp;Action: </i>The <a title="processor" href="#dt-processor">processor</a>
 must either signal the error, or
must recover by choosing from amongst the definitions that specify the
attribute that have the highest import precedence the one that was
specified last in <a title="declaration order" href="#dt-declaration-order">declaration
 order</a>.</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e8865">ERR074</a></p></td><td valign="top"><p>It is an <a title="static error" href="#dt-static-error">static error</a> if the
number of arguments supplied in the function call is different from the number of
							<a href="#element-param"><code>xsl:param</code></a> elements in the function definition.</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e8928">ERR075</a></p></td><td valign="top"><p>Within the body of a stylesheet function, the
<a title="focus" href="#dt-focus">focus</a>
 is initially undefined; this means that any attempt to reference the context item, context position,
 or context size is a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a>. 
						<br><i>&nbsp;&nbsp;&nbsp;&nbsp;Action: </i>The processor must signal the error.</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e9167">ERR078</a></p></td><td valign="top"><p>When the <code>xsl:type-annotation</code> attribute is used on a literal result
element, it is a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> to construct an element node
as a child of the new element. Type annotations can be added only to element nodes that have simple 
content. 
						<br><i>&nbsp;&nbsp;&nbsp;&nbsp;Action: </i>The processor must signal the error.</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e9181">ERR079</a></p></td><td valign="top"><p>When the <code>xsl:type-annotation</code> attribute is used on a literal result
element, it is a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> if the string-value of the
new element cannot be converted to the named type under the rules of the XPath <code>cast</code>
expression. These rules are defined in <a href="#FANDO">[Functions and Operators]</a>.

						<br><i>&nbsp;&nbsp;&nbsp;&nbsp;Action: </i>The processor must signal the error.</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e9603">ERR081</a></p></td><td valign="top"><p>It is an <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> if
 the <a title="effective value" href="#dt-effective-value">effective value</a>
						 [of the <code>name</code> attribute of the
<a href="#element-element"><code>xsl:element</code></a> instruction]  is not a <a title="QName" href="#dt-qname">QName</a>.
  
					<br><i>&nbsp;&nbsp;&nbsp;&nbsp;Action: </i>The <a title="processor" href="#dt-processor">processor</a> must either signal
the error, or must recover by making the result
 of evaluating the <a href="#element-element"><code>xsl:element</code></a>
element be the sequence of nodes created by evaluating
the content of the  <a href="#element-element"><code>xsl:element</code></a> element, excluding
any initial attribute nodes.</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e9636">ERR082</a></p></td><td valign="top"><p>In the case of an <a href="#element-element"><code>xsl:element</code></a> instruction
with no <code>namespace</code> attribute, 
it is a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> if
 the <a title="effective value" href="#dt-effective-value">effective value</a>
of the <code>name</code> attribute is a <a title="QName" href="#dt-qname">QName</a>
whose prefix is not declared in an in-scope namespace declaration for the <a href="#element-element"><code>xsl:element</code></a> instruction.
  
					<br><i>&nbsp;&nbsp;&nbsp;&nbsp;Action: </i>The <a title="processor" href="#dt-processor">processor</a> must either signal
the error, or must recover by ignoring the prefix part of the QName.</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e9766">ERR084</a></p></td><td valign="top"><p>When the <code>type-annotation</code> attribute is used 
 [on the <a href="#element-element"><code>xsl:element</code></a> instruction, ] 
it is a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> to construct an element node
as a child of the new element. Type annotations can be added only to element nodes that have simple 
content. 
						<br><i>&nbsp;&nbsp;&nbsp;&nbsp;Action: </i>The processor must signal the error.</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e9786">ERR085</a></p></td><td valign="top"><p>When the <code>type-annotation</code> attribute is used
 [on the <a href="#element-element"><code>xsl:element</code></a> instruction, ] 
it is a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> if the string-value of the
new element cannot be converted to the named type under the rules of the XPath <code>cast</code>
expression. These rules are defined in <a href="#FANDO">[Functions and Operators]</a>.

						<br><i>&nbsp;&nbsp;&nbsp;&nbsp;Action: </i>The processor must signal the error.</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e9872">ERR086</a></p></td><td valign="top"><p>It is a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> if 
the <a title="effective value" href="#dt-effective-value">effective value</a>
						 [of the <code>name</code> attribute of an 
<a href="#element-attribute"><code>xsl:attribute</code></a> instruction]  
is not a <a title="QName" href="#dt-qname">QName</a> or is the string
<code>xmlns</code>.  
					<br><i>&nbsp;&nbsp;&nbsp;&nbsp;Action: </i>The <a title="processor" href="#dt-processor">processor</a> must either signal the error, 
or must recover by not adding the attribute
to the result tree.</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e9903">ERR087</a></p></td><td valign="top"><p>In the case of an <a href="#element-attribute"><code>xsl:attribute</code></a> instruction
with no <code>namespace</code> attribute, 
it is a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> if
 the <a title="effective value" href="#dt-effective-value">effective value</a>
of the <code>name</code> attribute is a <a title="QName" href="#dt-qname">QName</a>
whose prefix is not declared in an in-scope namespace declaration for the <a href="#element-attribute"><code>xsl:attribute</code></a> instruction.
  
					<br><i>&nbsp;&nbsp;&nbsp;&nbsp;Action: </i>The <a title="processor" href="#dt-processor">processor</a> must either signal
the error, or must recover by ignoring the prefix part of the QName.</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e10016">ERR088</a></p></td><td valign="top"><p>It is a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> to evaluate
the <a href="#element-attribute"><code>xsl:attribute</code></a> instruction when the
 <a title="current destination node" href="#dt-current-destination-node">current destination node</a>
 is not an element. <br><i>&nbsp;&nbsp;&nbsp;&nbsp;Action: </i>The recovery action (if any) depends
on the instruction that makes use of the constructed node sequence.</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e10073">ERR090</a></p></td><td valign="top"><p>When the <code>type-annotation</code> attribute is used
 [on the <a href="#element-attribute"><code>xsl:attribute</code></a> instruction, ] 
it is a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> if the string-value of the
new attribute cannot be converted to the named type under the rules of the XPath <code>cast</code>
expression. These rules are defined in <a href="#FANDO">[Functions and Operators]</a>.

						<br><i>&nbsp;&nbsp;&nbsp;&nbsp;Action: </i>The processor must signal the error.</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e10250">ERR092</a></p></td><td valign="top"><p>It is a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> if the
 <a title="effective value" href="#dt-effective-value">effective value</a> of the
<code>name</code> attribute  [of the <a href="#element-processing-instruction"><code>xsl:processing-instruction</code></a> 
instruction]  is not both an <u>NCName</u> and a <u>PITarget</u>.
  
					<br><i>&nbsp;&nbsp;&nbsp;&nbsp;Action: </i>The <a title="processor" href="#dt-processor">processor</a> must either signal
the error, or must recover by
returning an empty sequence.</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e10293">ERR093</a></p></td><td valign="top"><p>It is a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> if
 the result of evaluating the content of the
<a href="#element-processing-instruction"><code>xsl:processing-instruction</code></a> contains the string
<code>?&gt;</code>.  
					<br><i>&nbsp;&nbsp;&nbsp;&nbsp;Action: </i>The <a title="processor" href="#dt-processor">processor</a> must either signal the error, or
 must recover by inserting a space after any
occurrence of <code>?</code> that is followed by a <code>&gt;</code>
						</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e10369">ERR094</a></p></td><td valign="top"><p>It is a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> if the
<a title="effective value" href="#dt-effective-value">effective value</a> of the
<code>name</code> attribute  [of the <a href="#element-namespace"><code>xsl:namespace</code></a> instruction] 
is neither a zero-length string  nor an <u>NCName</u>.  

					<br><i>&nbsp;&nbsp;&nbsp;&nbsp;Action: </i>The <a title="processor" href="#dt-processor">processor</a> must either signal the error,
or must recover by returning an empty sequence.</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e10398">ERR095</a></p></td><td valign="top"><p>It is an <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> if
 evaluating the content of
<a href="#element-namespace"><code>xsl:namespace</code></a> results in a zero-length string .

					<br><i>&nbsp;&nbsp;&nbsp;&nbsp;Action: </i>The <a title="processor" href="#dt-processor">processor</a> must either signal the error, 
or must recover by returning an empty sequence.</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e10414">ERR096</a></p></td><td valign="top"><p>It is a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> to evaluate
the <a href="#element-namespace"><code>xsl:namespace</code></a> instruction when the
 <a title="current destination node" href="#dt-current-destination-node">current destination node</a>
 is not an element. <br><i>&nbsp;&nbsp;&nbsp;&nbsp;Action: </i>The recovery action (if any) depends
on the instruction that makes use of the constructed node sequence.</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e10497">ERR097</a></p></td><td valign="top"><p>It is a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> if
 the result of evaluating the content of the
<a href="#element-comment"><code>xsl:comment</code></a> contains the string <code>--</code> or ends
with <code>-</code>.  
					<br><i>&nbsp;&nbsp;&nbsp;&nbsp;Action: </i>The <a title="processor" href="#dt-processor">processor</a> must either signal the error,
or must recover by inserting a space after
any occurrence of <code>-</code> that is followed by another
<code>-</code> or that ends the comment.</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e10626">ERR098</a></p></td><td valign="top"><p>When the context item is an attribute node, then if it would be a
 <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a>
to use <a href="#element-attribute"><code>xsl:attribute</code></a> to create an attribute with the same
name as the context item, then it is also a
 <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> to use
<a href="#element-copy"><code>xsl:copy</code></a> (see <a href="#creating-attributes"><b>11.3 Creating Attribute Nodes using xsl:attribute
				</b></a>).

						<br><i>&nbsp;&nbsp;&nbsp;&nbsp;Action: </i>The <a title="processor" href="#dt-processor">processor</a> must either signal the error, or must recover by
returning an empty sequence.</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e11171">ERR099</a></p></td><td valign="top"><p>It is a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> 
if any item in the sequence  [supplied as the value of the <code>value</code>
 attribute of <a href="#element-number"><code>xsl:number</code></a>
						] 
 cannot be converted to an integer, or if the resulting integer is less than 1 (one). 

					<br><i>&nbsp;&nbsp;&nbsp;&nbsp;Action: </i>The <a title="processor" href="#dt-processor">processor</a> must either signal the error,
or must recover by converting that member to a
string as if by a call to the <u>fn:string</u> function
and inserting the resulting string into the formatted result string in
 its proper position.</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e11238">ERR100</a></p></td><td valign="top"><p>It is a
<a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> if the
<a href="#element-number"><code>xsl:number</code></a> instruction is evaluated, with no <code>value</code> attribute,
when the <a title="context item" href="#dt-context-item">context item</a> is not a node. 

					<br><i>&nbsp;&nbsp;&nbsp;&nbsp;Action: </i>The <a title="processor" href="#dt-processor">processor</a> must either signal the error,
or must recover by returning an empty sequence.</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e12124">ERR102</a></p></td><td valign="top"><p>The target  type for each <a href="#element-sort"><code>xsl:sort</code></a> element is determined
 by the <a title="effective value" href="#dt-effective-value">effective value</a> of its
 <code>as</code> attribute. 

This must be the name of an atomic data type that is available
in the static context: that is, either the name of a built-in atomic type defined in <a href="#XMLSCHEMA">[XML Schema]</a>,
or the name of a type derived from such a type by restriction, defined in an imported schema. 
It is a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> if any other value is
supplied. 
					<br><i>&nbsp;&nbsp;&nbsp;&nbsp;Action: </i>The <a title="processor" href="#dt-processor">processor</a> must either signal the error, 
or must recover
by continuing as if the <code>as</code> attribute were not specified.</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e12232">ERR103</a></p></td><td valign="top"><p>It
 is a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> if any value 
 (other than the empty sequence) obtained by
 evaluating the <code>select</code> attribute of an <a href="#element-sort"><code>xsl:sort</code></a> element
 cannot be converted to the target  type. 
 
					<br><i>&nbsp;&nbsp;&nbsp;&nbsp;Action: </i>The <a title="processor" href="#dt-processor">processor</a> must either signal the error, 
 or must recover by treating the value as 
 an exception value.
 </p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e12283">ERR104</a></p></td><td valign="top"><p>It is a
 <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> if, for any
  <a title="sort key definition" href="#dt-sort-key-definition">sort key definition</a>,
 the set of <a title="sort key" href="#dt-sort-key">sort keys</a> evaluated for all the items in the
 <a title="initial sequence" href="#dt-initial-sequence">initial sequence</a>, after any type conversion requested,
 contains a pair of ordinary values for which the result of the
 XPath <code>lt</code> operator is an error or an empty sequence. 
 
					<br><i>&nbsp;&nbsp;&nbsp;&nbsp;Action: </i>The <a title="processor" href="#dt-processor">processor</a> must either signal the error, 
 or must recover by assigning an arbitrary ordering to any such
 pair of values.</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e12406">ERR105</a></p></td><td valign="top"><p>It is a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> if
  the <a title="effective value" href="#dt-effective-value">effective value</a>
 of the <code>as</code> attribute of the <a href="#element-sort"><code>xsl:sort</code></a> element is
  a  type for which no ordering
 relation is defined
						
					<br><i>&nbsp;&nbsp;&nbsp;&nbsp;Action: </i>The <a title="processor" href="#dt-processor">processor</a> must signal the error, or must recover by
  continuing as if the <code>as</code> attribute were omitted.</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e12684">ERR107</a></p></td><td valign="top"><p>It is a 
<a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> if the first argument of the <a href="#function-sort"><b>sort</b></a>
function does not match the name of any <a title="named sort specification" href="#dt-named-sort-key">named sort specification</a> in the stylesheet.

						<br><i>&nbsp;&nbsp;&nbsp;&nbsp;Action: </i>The <a title="processor" href="#dt-processor">processor</a> must signal the error.</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e12974">ERR112</a></p></td><td valign="top"><p>It is a <a title="type errors" href="#dt-type-error">type error</a>
if the result of evaluating the <code>group-by</code> or <code>group-adjacent</code> attribute,
for any item in the population, cannot be converted to the required type using the
 <a title="argument conversion rules" href="#dt-argument-conversion-rules">argument conversion rules</a>.
 This includes the case where the result is an empty sequence, or a sequence containing
more than one item. <br><i>&nbsp;&nbsp;&nbsp;&nbsp;Action: </i>The processor must signal the error.</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e13060">ERR113</a></p></td><td valign="top"><p>It is a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> if the
result of evaluating the <code>select</code> expression  [of the <a href="#element-for-each-group"><code>xsl:for-each-group</code></a>
instruction, with a <code>group-starting-with</code> attribute,]  
contains an item that is not a node.

							<br><i>&nbsp;&nbsp;&nbsp;&nbsp;Action: </i>The <a title="processor" href="#dt-processor">processor</a> must signal the error.</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e13101">ERR114</a></p></td><td valign="top"><p>It is a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> if the
result of evaluating the <code>select</code> expression  [of the <a href="#element-for-each-group"><code>xsl:for-each-group</code></a>
instruction, with a <code>group-ending-with</code> attribute,]  
contains an item that is not a node.

							<br><i>&nbsp;&nbsp;&nbsp;&nbsp;Action: </i>The <a title="processor" href="#dt-processor">processor</a> must signal the error.</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e13542">ERR115</a></p></td><td valign="top"><p>It is a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> if the 
<a title="effective value" href="#dt-effective-value">effective value</a> of the <code>regex</code> attribute 
 [of the <a href="#element-analyze-string"><code>xsl:analyze-string</code></a> instruction] 
does not conform to the required syntax for
regular expressions, as specified in <a href="#FANDO">[Functions and Operators]</a>, or if the effective value of the <code>flags</code> attribute 
has a value other than the values defined in <a href="#FANDO">[Functions and Operators]</a>.

				<br><i>&nbsp;&nbsp;&nbsp;&nbsp;Action: </i>The processor must signal the error. If the regular expression and/or flags are known
statically (for example, if the attributes do not contain any <a title="expression" href="#dt-expression">expressions</a> enclosed in curly braces)
then the processor may signal the error as a <a title="static error" href="#dt-static-error">static error</a>.</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e13578">ERR116</a></p></td><td valign="top"><p>It is a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> if the 
<a title="effective value" href="#dt-effective-value">effective value</a> of the <code>regex</code> attribute 
 [of the <a href="#element-analyze-string"><code>xsl:analyze-string</code></a> instruction] 
is a regular expression that matches a zero-length string .

				<br><i>&nbsp;&nbsp;&nbsp;&nbsp;Action: </i>The processor must signal the error. If the regular expression is known
statically (for example, if the attribute does not contain any <a title="expression" href="#dt-expression">expressions</a> enclosed in curly braces)
then the processor may signal the error as a <a title="static error" href="#dt-static-error">static error</a>.</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e13802">ERR117</a></p></td><td valign="top"><p>It is a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a>
if a URI 
 [supplied in the first argument to the <a href="#function-unparsed-text"><b>unparsed-text</b></a> function] 
cannot be used to retrieve a resource containing text.

					<br><i>&nbsp;&nbsp;&nbsp;&nbsp;Action: </i>The <a title="processor" href="#dt-processor">processor</a> must either signal the error,
or must recover by treating the URI
as if it referenced a resource containing a zero-length string.</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e13822">ERR118</a></p></td><td valign="top"><p>It is a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a>
if a resource 
 [retrieved using the <a href="#function-unparsed-text"><b>unparsed-text</b></a> function] 
contains characters that are not permitted XML characters. 

					<br><i>&nbsp;&nbsp;&nbsp;&nbsp;Action: </i>The <a title="processor" href="#dt-processor">processor</a> must either signal the error,
or must recover in a <a title="implementation-defined" href="#dt-implementation-defined">implementation-defined</a> way; one possible outcome is that
the <a title="processor" href="#dt-processor">processor</a> will produce an output file that is
not well-formed XML.</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e13853">ERR119</a></p></td><td valign="top"><p>It is a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a>
if a resource 
 [retrieved using the <a href="#function-unparsed-text"><b>unparsed-text</b></a> function] 
contains bytes that cannot be decoded into permitted XML characters
using the specified encoding. This includes the case where the
 <a title="processor" href="#dt-processor">processor</a> does not support
the requested encoding.

					<br><i>&nbsp;&nbsp;&nbsp;&nbsp;Action: </i>The <a title="processor" href="#dt-processor">processor</a> must signal the error.</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e13876">ERR120</a></p></td><td valign="top"><p>It is a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a>
if the second argument of the <a href="#function-unparsed-text"><b>unparsed-text</b></a> function is omitted and the
 <a title="processor" href="#dt-processor">processor</a> cannot infer the encoding using
external information.
					<br><i>&nbsp;&nbsp;&nbsp;&nbsp;Action: </i>The <a title="processor" href="#dt-processor">processor</a> must signal the error.</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e14191">ERR125</a></p></td><td valign="top"><p>It is a dynamic error if the result of evaluating the <code>use</code> expression
 [of the <a href="#element-key"><code>xsl:key</code></a> element] ,
for any node that matches the pattern specified in the <code>match</code> attribute, cannot be converted
to the  type specified by the <code>as</code> attribute.

						<br><i>&nbsp;&nbsp;&nbsp;&nbsp;Action: </i>The processor may signal the error, or may recover by ignoring the existence of the value
that cannot be converted.</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e14248">ERR126</a></p></td><td valign="top"><p>It is a 
<a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> if the value 
 [of the first argument to the <a href="#function-key"><b>key</b></a> function]  is
not a valid QName, or if there is no
 namespace declaration in scope for the prefix of the QName, or if the
 name obtained by expanding the QName is not the same as the expanded
 name of any <a href="#element-key"><code>xsl:key</code></a> declaration in the stylesheet. 
						<br><i>&nbsp;&nbsp;&nbsp;&nbsp;Action: </i>The <a title="processor" href="#dt-processor">processor</a> must
 signal these errors.</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e14524">ERR127</a></p></td><td valign="top"><p>It is a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a>
					to call the <a href="#function-key"><b>key</b></a> function if there is no <a title="context node" href="#dt-context-node">context node</a>.
					<br><i>&nbsp;&nbsp;&nbsp;&nbsp;Action: </i>The <a title="processor" href="#dt-processor">processor</a> must signal the error.</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e14589">ERR128</a></p></td><td valign="top"><p>It is a 
<a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> if the stylesheet
does not contain a declaration of the decimal-format with the 
<a title="expanded-QName" href="#dt-expanded-qname">expanded-QName</a> specified as the
<code>$decimal-format-name</code> argument [ to the <a href="#function-format-number"><b>format-number</b></a> function] .

					<br><i>&nbsp;&nbsp;&nbsp;&nbsp;Action: </i>The <a title="processor" href="#dt-processor">processor</a> must either signal the error,
 or must recover by ignoring the <code>$decimal-format-name</code> argument.</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e14969">ERR131</a></p></td><td valign="top"><p>The <a title="picture string" href="#dt-picture-string">picture string</a>
							 [supplied to the <a href="#function-format-number"><b>format-number</b></a> function] 
must  conform to the following rules [see full specification] .
It is a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> if the picture string
does not satisfy these rules. 
						<br><i>&nbsp;&nbsp;&nbsp;&nbsp;Action: </i>The <a title="processor" href="#dt-processor">processor</a> must either signal the error,
or must recover by ignoring those characters in the
supplied picture string that make the picture string invalid. If a valid picture
string cannot be constructed, the <a title="processor" href="#dt-processor">processor</a> may recover by returning
the string obtained by applying the <u>fn:string</u> function to the supplied
number.</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e15612">ERR132</a></p></td><td valign="top"><p>It is a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a>
if  [[while processing the <a href="#function-format-number"><b>format-number</b></a> function]] 
the absolute value of the <var>adjusted number</var> is numerically greater 
than or equal to the <var>overflow-threshold</var>. 
								<br><i>&nbsp;&nbsp;&nbsp;&nbsp;Action: </i>The processor may
signal the error, or may recover by formatting the number as if the sub-picture were extended
to the left (after any prefix) with a sufficient number of <var>digit-sign</var> characters to accommodate
the <var>adjusted number</var>, with the addition of <var>grouping-separator</var>
characters at each multiple of <var>N</var> characters, if and only if the existing
<var>whole-part-grouping-positions</var> sequence satisfies the rule that the <var>M</var>th
integer in the sequence is in all cases equal to <var>M * N</var>.
									</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e15886">ERR133</a></p></td><td valign="top"><p>It is a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a>
if the <a href="#function-unparsed-entity-uri"><b>unparsed-entity-uri</b></a> is called when there is no current node. <br><i>&nbsp;&nbsp;&nbsp;&nbsp;Action: </i>The
processor must signal the error.</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e15915">ERR134</a></p></td><td valign="top"><p>It is a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a>
if the <a href="#function-unparsed-entity-public-id"><b>unparsed-entity-public-id</b></a> is called when there is no current node. <br><i>&nbsp;&nbsp;&nbsp;&nbsp;Action: </i>The
processor must signal the error.</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e15981">ERR136</a></p></td><td valign="top"><p>It is a 
<a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> if the value 
 [supplied as the <code>$property-name</code> argument to the
 <a href="#function-system-property"><b>system-property</b></a> function]  is
not a valid QName, or if there is no
 namespace declaration in scope for the prefix of the QName. 

						<br><i>&nbsp;&nbsp;&nbsp;&nbsp;Action: </i>The <a title="processor" href="#dt-processor">processor</a> must signal these errors.</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e16356">ERR137</a></p></td><td valign="top"><p>It is a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> 
if the argument 
 [passed to the <a href="#function-function-available"><b>function-available</b></a> function] 
does not evaluate to a string that is a valid <a title="QName" href="#dt-qname">QName</a>,
or if there is no namespace declaration in scope for the prefix of the <a title="QName" href="#dt-qname">QName</a>.

						<br><i>&nbsp;&nbsp;&nbsp;&nbsp;Action: </i>The <a title="processor" href="#dt-processor">processor</a> must either signal the error,
 or must recover by returning the value false.</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e16385">ERR138</a></p></td><td valign="top"><p>It is a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> if
a <u>FunctionCall</u> within an XPath <a title="expression" href="#dt-expression">expression</a>
is evaluated, when the function in question is not available.

						<br><i>&nbsp;&nbsp;&nbsp;&nbsp;Action: </i>The <a title="processor" href="#dt-processor">processor</a> must
signal the error.</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e16428">ERR139</a></p></td><td valign="top"><p>It is a <a title="dynamic error" href="#dt-dynamic-error">dynamic
error</a> if the arguments supplied to a call on an extension function do
not satisfy the rules defined for that particular extension function, or if the
extension function reports an error, or if the result of the extension function
cannot be converted to an XPath value.
						<br><i>&nbsp;&nbsp;&nbsp;&nbsp;Action: </i>The processor must signal the
error.</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e16617">ERR141</a></p></td><td valign="top"><p>It is a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> 
if the argument 
 [passed to the <a href="#function-element-available"><b>element-available</b></a> function] 
does not evaluate to a string that is a valid <a title="QName" href="#dt-qname">QName</a>,
or if there is no namespace declaration in scope for the prefix of the <a title="QName" href="#dt-qname">QName</a>. 

						<br><i>&nbsp;&nbsp;&nbsp;&nbsp;Action: </i>The <a title="processor" href="#dt-processor">processor</a> must either signal the error,
 or must recover by returning the value false.</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e16678">ERR142</a></p></td><td valign="top"><p>When a <a title="processor" href="#dt-processor">processor</a> performs fallback for an
<a title="instruction" href="#dt-instruction">instruction</a> element, if the instruction 
element has one or more
<a href="#element-fallback"><code>xsl:fallback</code></a> children, then the content of each of the
<a href="#element-fallback"><code>xsl:fallback</code></a> children must be evaluated; it is a
 <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a>
if it has no <a href="#element-fallback"><code>xsl:fallback</code></a> children. 

						<br><i>&nbsp;&nbsp;&nbsp;&nbsp;Action: </i>This error must be signaled.</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e17174">ERR146</a></p></td><td valign="top"><p>It is a <a title="dynamic error" href="#dt-dynamic-error">dynamic
error</a> to evaluate the <a href="#element-result-document"><code>xsl:result-document</code></a> instruction when
the 
						
							<a title="current destination node" href="#dt-current-destination-node">current destination node</a>
is not a node belonging to a result tree (for example, when it is a node belonging to a
temporary tree). 
					<br><i>&nbsp;&nbsp;&nbsp;&nbsp;Action: </i>The
<a title="processor" href="#dt-processor">processor</a> must signal the error.</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e17221">ERR147</a></p></td><td valign="top"><p>It is a <a title="dynamic error" href="#dt-dynamic-error">dynamic
error</a> for a transformation to generate two or more result trees with the same URI. 

					<br><i>&nbsp;&nbsp;&nbsp;&nbsp;Action: </i>The <a title="processor" href="#dt-processor">processor</a> must signal the error.</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e17256">ERR148</a></p></td><td valign="top"><p>It is a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a>
for a stylesheet to write to an external resource and read from the same resource during a single
transformation, whether or not the same URI is used to access the resource in both cases. 
					<br><i>&nbsp;&nbsp;&nbsp;&nbsp;Action: </i>The
effect of this error is implementation-dependent: implementations are not obliged to detect
it.</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e17437">ERR150</a></p></td><td valign="top"><p>It is a 
<a title="dynamic error" href="#dt-dynamic-error">dynamic error</a>
if two <a href="#element-output"><code>xsl:output</code></a> declarations within an
<a title="output definition" href="#dt-output-definition">output definition</a> specify
explicit values for the same attribute (other than <code>cdata-section-elements</code>), 
with the values of the attributes being not equal, 
and with neither of these declarations being overridden
by an <a href="#element-output"><code>xsl:output</code></a> declaration with higher import precedence that specifies
an explicit value for the same attribute.

				<br><i>&nbsp;&nbsp;&nbsp;&nbsp;Action: </i>The <a title="processor" href="#dt-processor">processor</a> must either signal the error,
or must recover by using the value that occurs last in 
<a title="declaration order" href="#dt-declaration-order">declaration order</a>.
</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e18808">ERR157</a></p></td><td valign="top"><p>It is a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> for
 output escaping to be disabled for a text node
that is used for something other than a text node in the result tree.
Thus, it is an error to disable output escaping for an
<a href="#element-value-of"><code>xsl:value-of</code></a> or <a href="#element-text"><code>xsl:text</code></a> element that is
used to generate the string-value of a comment, processing instruction
or attribute node; it is also a
 <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> to convert a node to a 
 number or a string if the node is, or contains, a text node for which escaping
was disabled.  
					<br><i>&nbsp;&nbsp;&nbsp;&nbsp;Action: </i>In both cases, the <a title="processor" href="#dt-processor">processor</a> must either signal the error,
or must recover by ignoring the
<code>disable-output-escaping</code> attribute.</p></td></tr></table><p><b>Serialization errors</b></p><table><tr><td width="10%" valign="top"><p><a href="#d5e17523">ERR151</a></p></td><td valign="top"><p>The value 
 [of the <code>method</code> attribute on
 <a href="#element-output"><code>xsl:output</code></a>
					] 
must be a valid <a title="QName" href="#dt-qname">QName</a>.  
If the <a title="QName" href="#dt-qname">QName</a> does not have a prefix, then it
identifies a method specified in this document and must be one of
<code>xml</code>, <code>html</code>, <code>xhtml</code>, 
 or <code>text</code>.</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e17868">ERR152</a></p></td><td valign="top"><p>It is a
 <a title="serialization error" href="#dt-serialization-error">serialization error</a>
 to request the output of a document type declaration, or of a  
 <code>standalone</code> attribute, if the result tree contains
 text nodes or multiple element nodes as children of the root node.
 
					<br><i>&nbsp;&nbsp;&nbsp;&nbsp;Action: </i>The processor may signal the error, or may recover
 by ignoring the request to output a document type declaration
 or <code>standalone</code> attribute.</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e17913">ERR153</a></p></td><td valign="top"><p>A <a title="serialization error" href="#dt-serialization-error">serialization error</a>
occurs when an output encoding other than <code>UTF-8</code> or <code>UTF-16</code> is requested,
if the implementation does not support that encoding. 

					<br><i>&nbsp;&nbsp;&nbsp;&nbsp;Action: </i>The <a title="processor" href="#dt-processor">processor</a> may
signal the error, or may recover by using <code>UTF-8</code> or
<code>UTF-16</code> instead.</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e17960">ERR154</a></p></td><td valign="top"><p>A <a title="serialization error" href="#dt-serialization-error">serialization error</a>
occurs if such a character
 [a character that cannot be represented in the
encoding that the processor is using for output] 
appears in a context where character references are not allowed
(for example if the character occurs in the name of an element).

					<br><i>&nbsp;&nbsp;&nbsp;&nbsp;Action: </i>The
<a title="processor" href="#dt-processor">processor</a> should signal the 
error.</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e18629">ERR155</a></p></td><td valign="top"><p>It is possible that the result tree 
will contain a character that
cannot be represented in the encoding that the <a title="processor" href="#dt-processor">processor</a> is using
for output.  In this case, if the character occurs in a context where
HTML recognizes character references, then the character should be
output as a character entity reference or decimal numeric character
reference; otherwise (for example, in a
<code>script</code> or <code>style</code> element or in a comment),
the processor should signal a
 <a title="serialization error" href="#dt-serialization-error">serialization error</a>.</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e18733">ERR156</a></p></td><td valign="top"><p>If
the result tree contains a character that cannot be represented in the
encoding that the <a title="processor" href="#dt-processor">processor</a> is using for output, the implementation
 should signal a <a title="serialization error" href="#dt-serialization-error">serialization error</a>.
</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e18910">ERR158</a></p></td><td valign="top"><p>It is 
 a <a title="serialization error" href="#dt-serialization-error">serialization error</a>
 if an
<a href="#element-value-of"><code>xsl:value-of</code></a> or <a href="#element-text"><code>xsl:text</code></a> instruction specifies that
output escaping should be disabled and the implementation does not
support this. 
					<br><i>&nbsp;&nbsp;&nbsp;&nbsp;Action: </i>The <a title="processor" href="#dt-processor">processor</a> must either signal the error,
of must recover by not disabling output escaping.</p></td></tr><tr><td width="10%" valign="top"><p><a href="#d5e18932">ERR159</a></p></td><td valign="top"><p>It is 
 a <a title="serialization error" href="#dt-serialization-error">serialization error</a>
if output escaping is disabled for a character that is not
representable in the encoding that the <a title="processor" href="#dt-processor">processor</a> is using for
output. 
					<br><i>&nbsp;&nbsp;&nbsp;&nbsp;Action: </i>The processor must either signal the error,
of must recover by not disabling output escaping.</p></td></tr></table></div><div class="div1">
<h2><a name="implementation-defined-features" id="implementation-defined-features"></a>E Checklist of Implementation-Defined Features (Non-Normative)</h2><p>This appendix provides a summary of XSLT language features whose effect is
explicitly <a title="implementation-defined" href="#dt-implementation-defined">implementation-defined</a>.
Vendors should provide documentation with each implementation that explains how
these choices have been exercised.</p><ul><li><p>The way in which an XSLT processor is invoked, and the specification of
the source document, starting node, and values for
 <a title="stylesheet parameter" href="#dt-stylesheet-parameter">stylesheet parameters</a>, are implementation-defined. (See <a href="#initiating"><b>2.3 Initiating a Transformation</b></a>)</p></li><li><p>The mechanisms for creating new extension instructions and extension
functions are implementation-defined. (See <a href="#extensibility"><b>2.7 Extensibility</b></a>)</p></li><li><p>Where the specification provides a choice between signaling a dynamic
 error or recovering, the decision that is made
 (but not the recovery action itself) is implementation-defined. (See <a href="#errors"><b>2.9 Error Handling</b></a>)</p></li><li><p>It is implementation-defined whether type errors are reported statically. (See <a href="#errors"><b>2.9 Error Handling</b></a>)</p></li><li><p>The handling of serialization errors is implementation-defined. (See <a href="#errors"><b>2.9 Error Handling</b></a>)</p></li><li><p>The set of namespaces that are recognized for additional
 attributes on XSLT instructions is implementation-defined. (See <a href="#xslt-namespace"><b>3.1 XSLT Namespace</b></a>)</p></li><li><p>An implementation may reserve one or more namespaces for use by the implementation,
provided these follow accepted practice to avoid naming collisions. (See <a href="#xslt-namespace"><b>3.1 XSLT Namespace</b></a>)</p></li><li><p>The set of namespaces that are specially recognized for user-defined
 data elements (other than the XSLT namespace) is implementation-defined. (See <a href="#user-defined-top-level"><b>3.4.1 User-defined Data Elements</b></a>)</p></li><li><p>It is implementation-defined whether an XSLT 2.0 processor supports
backwards-compatible behavior. (See <a href="#backwards"><b>3.6 Backwards-Compatible Processing</b></a>)</p></li><li><p>The forms of fragment identifier permitted on the URI reference passed
to the <a href="#element-include"><code>xsl:include</code></a> and <a href="#element-import"><code>xsl:import</code></a> elements, as well as the
<u>fn:document</u> function, are implementation-defined. (See <a href="#include"><b>3.8.1 Stylesheet Inclusion</b></a>)</p></li><li><p>The precise way in which an implementation uses the <code>namespace</code>
and/or <code>schema-location</code> attributes of the <a href="#element-import-schema"><code>xsl:import-schema</code></a> declaration
to locate schema definitions is implementation-defined. (See <a href="#import-schema"><b>3.10 Importing Schema Components</b></a>)</p></li><li><p>The set of URI references that may be used to identify collations, and the
choice of default collation, are implementation-defined. (See <a href="#expressions"><b>5.2 Expressions</b></a>)</p></li><li><p>The numbering sequences supported by the <a href="#element-number"><code>xsl:number</code></a>
instructions, beyond those defined in this specification, is implementation-defined. (See <a href="#convert"><b>12.3 Number to String Conversion Attributes</b></a>)</p></li><li><p>There may be implementation-defined upper bounds on the numbers that
can be formatted by <a href="#element-number"><code>xsl:number</code></a> using any particular numbering sequence. (See <a href="#convert"><b>12.3 Number to String Conversion Attributes</b></a>)</p></li><li><p>The set of
languages for which numbering is supported by <a href="#element-number"><code>xsl:number</code></a> is 
implementation-defined. (See <a href="#convert"><b>12.3 Number to String Conversion Attributes</b></a>)</p></li><li><p>The facilities for defining collations and allocating URIs to identify them,
 including facilities for defining the default collation, are implementation-defined. (See <a href="#collating-sequences"><b>13.1 Collating Sequences</b></a>)</p></li><li><p>If the <code>data-type</code> attribute of the <a href="#element-sort"><code>xsl:sort</code></a> element
has a value other than <code>text</code> or <code>number</code>, the effect is implementation-defined. (See <a href="#sorting"><b>13 Sorting</b></a>)</p></li><li><p>The mechanisms used to define collations are implementation-defined. (See <a href="#sorting"><b>13 Sorting</b></a>)</p></li><li><p>The algorithm used by <a href="#element-sort"><code>xsl:sort</code></a> to select a collation,
 given the values of the <code>lang</code> and <code>case-order</code> attributes,
 is implementation-defined. (See <a href="#sorting"><b>13 Sorting</b></a>)</p></li><li><p>The recovery action when the resource identified by the
<a href="#function-unparsed-text"><b>unparsed-text</b></a> function contains characters not permitted by the XML Recommendation
is implementation-defined. (See <a href="#unparsed-text"><b>16.2 Reading Text Files</b></a>)</p></li><li><p>The values returned by the <a href="#function-system-property"><b>system-property</b></a>
function, and the names of the additional properties that are recognized, are implementation-defined. (See <a href="#system-property"><b>16.5.5 system-property</b></a>)</p></li><li><p>The destination and formatting of messages written using the
<a href="#element-message"><code>xsl:message</code></a> instruction are implementation-defined. (See <a href="#message"><b>17 Messages</b></a>)</p></li><li><p>The effect of an extension function returning a string containing
characters that are not legal in XML is implementation-defined. (See <a href="#extension-functions"><b>18.1 Extension Functions</b></a>)</p></li><li><p>The way in which external objects are represented in the type
system is implementation-defined. (See <a href="#external-objects"><b>18.1.3 External Objects</b></a>)</p></li><li><p>The way in which a  result tree is delivered to an
application is implementation-defined. (See <a href="#result-trees"><b>19 Result Trees</b></a>)</p></li><li><p>If serialization is supported, then the location to which a  result tree
is serialized is implementation-defined, subject to the constraint that relative URIs used to reference
one tree from another remain valid. (See <a href="#serialization"><b>20 Serialization</b></a>)</p></li><li><p>It is implementation-defined whether, and under what circumstances,
disabling output escaping is supported. (See <a href="#disable-output-escaping"><b>20.5 Disabling Output Escaping</b></a>)</p></li></ul></div><div class="div1">
<h2><a name="schema-for-xslt" id="schema-for-xslt"></a>F Schema for XSLT Stylesheets (Non-Normative)</h2><p>The following schema describes the structure of an XSLT stylesheet module. It does
not define all the constraints that apply to stylesheet (for example, it does not attempt
to define a data type that precisely represents attributes containing XPath <a title="expression" href="#dt-expression">expressions</a>),
but every valid stylesheet module should conform to this schema.</p><pre>&lt;?xml version="1.0" ?&gt;

&lt;schema xmlns="http://www.w3.org/2001/XMLSchema"
        targetNamespace="http://www.w3.org/1999/XSL/Transform"
        elementFormDefault="qualified"
        xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

&lt;!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ --&gt;
&lt;annotation&gt;
  &lt;documentation&gt;
  
    This is a schema for XSLT 2.0 stylesheets.
    
    It defines all the elements that appear in the XSLT namespace; it also
    provides hooks that allow the inclusion of user-defined literal result elements,
    extension instructions, and top-level data elements.
    
    The schema is derived (with kind permission) from a schema for XSLT 1.0 stylesheets
    produced by Asir S Vedamuthu of WebMethods Inc.
    
    This schema is available for use under the conditions of the W3C Software License
    published at http://www.w3.org/Consortium/Legal/copyright-software-19980720
    
    The schema is organized as follows:
    
    PART A: definitions of complex types and model groups used as the basis 
            for element definitions
    PART B: definitions of individual XSLT elements
    PART C: definitions for literal result elements
    PART D: definitions of simple types used in attribute definitions
    
    This schema does not attempt to define all the constraints that apply to a valid
    XSLT 2.0 stylesheet. It is the intention that all valid stylesheets should conform
    to this schema; however, the schema is non-normative and in the event of any
    conflict, the text of the Recommendation takes precedence.
    
    This version is dated 2002-07-19
    Author: Michael H Kay, Software AG
    
  &lt;/documentation&gt;
&lt;/annotation&gt;   
&lt;!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ --&gt;
&lt;!-- 

The declaration of xml:space and xml:lang has been commented out because
of problems processing the schema using various tools
      
&lt;import namespace="http://www.w3.org/XML/1998/namespace" 
  schemaLocation="http://www.w3.org/2001/xml.xsd"/&gt;
  
--&gt;
&lt;!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ --&gt;
&lt;annotation&gt;
  &lt;documentation&gt;
    PART A: definitions of complex types and model groups used as the basis 
            for element definitions
  &lt;/documentation&gt;
&lt;/annotation&gt;   
&lt;!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ --&gt;

&lt;complexType name="generic-element-type"&gt;
  &lt;attribute name="extension-element-prefixes" type="xsl:tokens"/&gt;
  &lt;attribute name="exclude-result-prefixes" type="xsl:tokens"/&gt;
  &lt;attribute name="default-xpath-namespace" type="anyURI"/&gt;
  &lt;!--attribute ref="xml:space"/--&gt;      
  &lt;!--attribute ref="xml:lang"/--&gt;    
  &lt;anyAttribute namespace="##other" processContents="skip"/&gt;
&lt;/complexType&gt;

&lt;complexType name="versioned-element-type"&gt;
  &lt;complexContent&gt;
    &lt;extension base="xsl:generic-element-type"&gt;    
      &lt;attribute name="version" type="decimal" use="optional"/&gt;
    &lt;/extension&gt;
  &lt;/complexContent&gt;
&lt;/complexType&gt;

&lt;complexType name="content-constructor" mixed="true"&gt;
  &lt;complexContent&gt;
    &lt;extension base="xsl:versioned-element-type"&gt;    
      &lt;group ref="xsl:content-constructor-group" minOccurs="0" maxOccurs="unbounded"/&gt;
    &lt;/extension&gt;
  &lt;/complexContent&gt;
&lt;/complexType&gt;

&lt;group name="content-constructor-group"&gt;
  &lt;sequence&gt;
  &lt;choice minOccurs="0" maxOccurs="unbounded"&gt;
    &lt;element ref="xsl:variable"/&gt;
    &lt;element ref="xsl:instruction"/&gt;
    &lt;group ref="xsl:result-elements"/&gt;
  &lt;/choice&gt;
  &lt;/sequence&gt;
&lt;/group&gt;

&lt;element name="declaration" type="xsl:generic-element-type" abstract="true"/&gt;

&lt;element name="instruction" type="xsl:versioned-element-type" abstract="true"/&gt;

&lt;!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ --&gt;
&lt;annotation&gt;
  &lt;documentation&gt;
    PART B: definitions of individual XSLT elements    
    Elements are listed in alphabetical order.    
  &lt;/documentation&gt;
&lt;/annotation&gt;   
&lt;!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ --&gt;

&lt;element name="analyze-string" substitutionGroup="xsl:instruction"&gt;
  &lt;complexType&gt;
    &lt;complexContent&gt;
      &lt;extension base="xsl:versioned-element-type"&gt;
        &lt;sequence&gt;
          &lt;element ref="xsl:matching-substring" minOccurs="0" maxOccurs="1"/&gt;
          &lt;element ref="xsl:non-matching-substring" minOccurs="0" maxOccurs="1"/&gt;
          &lt;element ref="xsl:fallback" minOccurs="0" maxOccurs="unbounded"/&gt;
        &lt;/sequence&gt;
      &lt;/extension&gt;
    &lt;/complexContent&gt;
  &lt;/complexType&gt;
&lt;/element&gt;

&lt;element name="apply-imports" substitutionGroup="xsl:instruction"&gt;
  &lt;complexType&gt;
    &lt;complexContent&gt;
      &lt;extension base="xsl:versioned-element-type"&gt;
        &lt;sequence minOccurs="0" maxOccurs="unbounded"&gt;
          &lt;element ref="xsl:with-param"/&gt;
        &lt;/sequence&gt;
      &lt;/extension&gt;
    &lt;/complexContent&gt;
  &lt;/complexType&gt;
&lt;/element&gt;

&lt;element name="apply-templates" substitutionGroup="xsl:instruction"&gt;
  &lt;complexType&gt;
    &lt;complexContent&gt;
      &lt;extension base="xsl:versioned-element-type"&gt;
        &lt;choice minOccurs="0" maxOccurs="unbounded"&gt;
          &lt;element ref="xsl:sort"/&gt;
          &lt;element ref="xsl:with-param"/&gt;
        &lt;/choice&gt;
        &lt;attribute name="select" type="xsl:expression" use="optional" default="child::node()"/&gt;
        &lt;attribute name="mode" type="xsl:mode"/&gt;
      &lt;/extension&gt;
    &lt;/complexContent&gt;
  &lt;/complexType&gt;
&lt;/element&gt;

&lt;element name="attribute" substitutionGroup="xsl:instruction"&gt;
  &lt;complexType mixed="true"&gt;
    &lt;complexContent&gt;
      &lt;extension base="xsl:content-constructor"&gt;
        &lt;attribute name="name" type="xsl:avt" use="required"/&gt;
        &lt;attribute name="namespace" type="xsl:avt"/&gt;
        &lt;attribute name="disable-output-escaping" type="xsl:yes-or-no"/&gt;
        &lt;attribute name="type-annotation" type="QName"/&gt;
      &lt;/extension&gt;
    &lt;/complexContent&gt;
  &lt;/complexType&gt;
&lt;/element&gt;        

&lt;element name="attribute-set" substitutionGroup="xsl:declaration"&gt;
  &lt;complexType&gt;
    &lt;complexContent&gt;
      &lt;extension base="xsl:versioned-element-type"&gt;
        &lt;sequence minOccurs="0" maxOccurs="unbounded"&gt;
          &lt;element ref="xsl:attribute"/&gt;
        &lt;/sequence&gt;
        &lt;attribute name="name" type="QName" use="required"/&gt;
        &lt;attribute name="use-attribute-sets" type="xsl:QNames" use="optional"/&gt;
      &lt;/extension&gt;
    &lt;/complexContent&gt;
  &lt;/complexType&gt;
&lt;/element&gt;

&lt;element name="call-template" substitutionGroup="xsl:instruction"&gt;
  &lt;complexType&gt;
    &lt;complexContent&gt;
      &lt;extension base="xsl:versioned-element-type"&gt;
        &lt;sequence minOccurs="0" maxOccurs="unbounded"&gt;
          &lt;element ref="xsl:with-param"/&gt;
        &lt;/sequence&gt;
        &lt;attribute name="name" type="QName" use="required"/&gt;
      &lt;/extension&gt;
    &lt;/complexContent&gt;
  &lt;/complexType&gt;
&lt;/element&gt;

&lt;element name="choose" substitutionGroup="xsl:instruction"&gt;
  &lt;complexType&gt;
    &lt;complexContent&gt;
      &lt;extension base="xsl:versioned-element-type"&gt;
        &lt;sequence&gt;
          &lt;element ref="xsl:when" minOccurs="1" maxOccurs="unbounded"/&gt;
          &lt;element ref="xsl:otherwise" minOccurs="0" maxOccurs="1"/&gt;
        &lt;/sequence&gt;
      &lt;/extension&gt;
    &lt;/complexContent&gt;
  &lt;/complexType&gt;
&lt;/element&gt;

&lt;element name="comment" substitutionGroup="xsl:instruction" type="xsl:content-constructor"/&gt;

&lt;element name="copy" substitutionGroup="xsl:instruction"&gt;
  &lt;complexType mixed="true"&gt;
    &lt;complexContent&gt;
      &lt;extension base="xsl:content-constructor"&gt;
        &lt;attribute name="copy-namespaces" type="xsl:yes-or-no" use="optional"/&gt;
        &lt;attribute name="use-attribute-sets" type="xsl:QNames" use="optional"/&gt;
      &lt;/extension&gt;
    &lt;/complexContent&gt;
  &lt;/complexType&gt;
&lt;/element&gt;

&lt;element name="copy-of" substitutionGroup="xsl:instruction"&gt;
  &lt;complexType mixed="true"&gt;
    &lt;complexContent&gt;
      &lt;extension base="xsl:versioned-element-type"&gt;
        &lt;attribute name="select" type="xsl:expression" use="required"/&gt;
        &lt;attribute name="separator" type="xsl:avt" use="optional"/&gt;
        &lt;attribute name="copy-namespaces" type="xsl:yes-or-no" use="optional"/&gt;
        &lt;attribute name="copy-type-annotations" type="xsl:yes-or-no" use="optional"/&gt;
      &lt;/extension&gt;
    &lt;/complexContent&gt;
  &lt;/complexType&gt;
&lt;/element&gt;

&lt;element name="decimal-format" substitutionGroup="xsl:declaration"&gt;
  &lt;complexType&gt;
    &lt;complexContent&gt;
      &lt;extension base="xsl:versioned-element-type"&gt;
        &lt;attribute name="name" type="QName"/&gt;
        &lt;attribute name="decimal-separator" type="xsl:char" use="optional" default="."/&gt;
        &lt;attribute name="grouping-separator" type="xsl:char" use="optional" default=","/&gt;
        &lt;attribute name="infinity" type="string" use="optional" default="Infinity"/&gt;
        &lt;attribute name="minus-sign" type="xsl:char" use="optional" default="-"/&gt;
        &lt;attribute name="NaN" type="string" use="optional" default="NaN"/&gt;
        &lt;attribute name="percent" type="xsl:char" use="optional" default="%"/&gt;
        &lt;attribute name="per-mille" type="xsl:char" use="optional" default="&amp;#x2030;"/&gt;
        &lt;attribute name="zero-digit" type="xsl:char" use="optional" default="0"/&gt;
        &lt;attribute name="digit" type="xsl:char" use="optional" default="#"/&gt;
        &lt;attribute name="pattern-separator" type="xsl:char" use="optional" default=";"/&gt;
      &lt;/extension&gt;
    &lt;/complexContent&gt;
  &lt;/complexType&gt;
&lt;/element&gt;

&lt;element name="element" substitutionGroup="xsl:instruction"&gt;
  &lt;complexType mixed="true"&gt;
    &lt;complexContent&gt;
      &lt;extension base="xsl:content-constructor"&gt;
        &lt;attribute name="name" type="xsl:avt" use="required"/&gt;
        &lt;attribute name="namespace" type="xsl:avt" use="optional"/&gt;
        &lt;attribute name="use-attribute-sets" type="xsl:QNames" use="optional"/&gt;
        &lt;attribute name="type-annotation" type="QName"/&gt;
      &lt;/extension&gt;
    &lt;/complexContent&gt;
  &lt;/complexType&gt;
&lt;/element&gt;

&lt;element name="fallback" substitutionGroup="xsl:instruction" type="xsl:content-constructor"/&gt;

&lt;element name="for-each" substitutionGroup="xsl:instruction"&gt;
  &lt;complexType mixed="true"&gt;
    &lt;complexContent&gt;
      &lt;extension base="xsl:versioned-element-type"&gt;
        &lt;sequence&gt;
          &lt;element ref="xsl:sort" minOccurs="0" maxOccurs="unbounded"/&gt;
          &lt;group ref="xsl:content-constructor-group"/&gt;
        &lt;/sequence&gt;
        &lt;attribute name="select" type="xsl:expression" use="required"/&gt;
      &lt;/extension&gt;
    &lt;/complexContent&gt;
  &lt;/complexType&gt;
&lt;/element&gt;

&lt;element name="for-each-group" substitutionGroup="xsl:instruction"&gt;
  &lt;complexType mixed="true"&gt;
    &lt;complexContent&gt;
      &lt;extension base="xsl:versioned-element-type"&gt;
        &lt;sequence&gt;
          &lt;element ref="xsl:sort" minOccurs="0" maxOccurs="unbounded"/&gt;
          &lt;group ref="xsl:content-constructor-group"/&gt;
        &lt;/sequence&gt;
        &lt;attribute name="select" type="xsl:expression" use="required"/&gt;
        &lt;attribute name="group-by" type="xsl:expression"/&gt;
        &lt;attribute name="group-adjacent" type="xsl:expression"/&gt;            
        &lt;attribute name="group-starting-with" type="xsl:pattern"/&gt;            
        &lt;attribute name="group-ending-with" type="xsl:pattern"/&gt;            
        &lt;attribute name="collation" type="anyURI"/&gt;            
        &lt;attribute name="as" type="QName"/&gt;                
      &lt;/extension&gt;
    &lt;/complexContent&gt;
  &lt;/complexType&gt;
&lt;/element&gt;

&lt;element name="function" substitutionGroup="xsl:declaration"&gt;
  &lt;complexType&gt;
    &lt;complexContent&gt;
      &lt;extension base="xsl:versioned-element-type"&gt;
        &lt;sequence&gt;
          &lt;element ref="xsl:param" minOccurs="0" maxOccurs="unbounded"/&gt;
          &lt;choice&gt;
            &lt;element ref="xsl:variable"/&gt;
            &lt;element ref="xsl:message"/&gt;
          &lt;/choice&gt;
          &lt;element ref="xsl:result"/&gt;
        &lt;/sequence&gt;
        &lt;attribute name="name" type="QName" use="required"/&gt;
        &lt;attribute name="override" type="xsl:yes-or-no" default="yes"/&gt;
      &lt;/extension&gt;
    &lt;/complexContent&gt;
  &lt;/complexType&gt;
&lt;/element&gt;

&lt;element name="if" substitutionGroup="xsl:instruction"&gt;
  &lt;complexType mixed="true"&gt;
    &lt;complexContent&gt;
      &lt;extension base="xsl:content-constructor"&gt;
        &lt;attribute name="test" type="xsl:expression" use="required"/&gt;
      &lt;/extension&gt;
    &lt;/complexContent&gt;
  &lt;/complexType&gt;
&lt;/element&gt;

&lt;element name="import"&gt;
  &lt;complexType&gt;
    &lt;complexContent&gt;
      &lt;extension base="xsl:versioned-element-type"&gt;
        &lt;attribute name="href" type="anyURI" use="required"/&gt;
      &lt;/extension&gt;
    &lt;/complexContent&gt;
  &lt;/complexType&gt;
&lt;/element&gt;

&lt;element name="import-schema" substitutionGroup="xsl:declaration"&gt;
  &lt;complexType&gt;
    &lt;complexContent&gt;
      &lt;extension base="xsl:versioned-element-type"&gt;
        &lt;attribute name="namespace" type="anyURI"/&gt;
        &lt;attribute name="schema-location" type="anyURI"/&gt;                  
      &lt;/extension&gt;
    &lt;/complexContent&gt;
  &lt;/complexType&gt;
&lt;/element&gt;

&lt;element name="include" substitutionGroup="xsl:declaration"&gt;
    &lt;complexType&gt;
      &lt;complexContent&gt;
        &lt;extension base="xsl:versioned-element-type"&gt;
          &lt;attribute name="href" type="anyURI" use="required"/&gt;
        &lt;/extension&gt;
      &lt;/complexContent&gt;
  &lt;/complexType&gt;
&lt;/element&gt;

&lt;element name="key" substitutionGroup="xsl:declaration"&gt;
  &lt;complexType&gt;
    &lt;complexContent&gt;
      &lt;extension base="xsl:versioned-element-type"&gt;
        &lt;attribute name="name" type="QName" use="required"/&gt;
        &lt;attribute name="match" type="xsl:pattern" use="required"/&gt;
        &lt;attribute name="use" type="xsl:expression" use="required"/&gt;
        &lt;attribute name="collation" type="anyURI"/&gt;            
        &lt;attribute name="as" type="QName"/&gt;    
      &lt;/extension&gt;
    &lt;/complexContent&gt;
  &lt;/complexType&gt;
&lt;/element&gt;

&lt;element name="matching-substring" type="xsl:content-constructor"/&gt;

&lt;element name="message" substitutionGroup="xsl:instruction"&gt;
  &lt;complexType mixed="true"&gt;
    &lt;complexContent&gt;
      &lt;extension base="xsl:content-constructor"&gt;
        &lt;attribute name="terminate" default="no" type="xsl:avt"/&gt;
      &lt;/extension&gt;
    &lt;/complexContent&gt;
  &lt;/complexType&gt;
&lt;/element&gt;

&lt;element name="namespace" substitutionGroup="xsl:instruction"&gt;
  &lt;complexType mixed="true"&gt;
    &lt;complexContent&gt;
      &lt;extension base="xsl:content-constructor"&gt;
        &lt;attribute name="name" type="xsl:avt" use="required"/&gt;
      &lt;/extension&gt;
    &lt;/complexContent&gt;
  &lt;/complexType&gt;
&lt;/element&gt;

&lt;element name="namespace-alias" substitutionGroup="xsl:declaration"&gt;
  &lt;complexType&gt;
    &lt;complexContent&gt;
      &lt;extension base="xsl:versioned-element-type"&gt;
        &lt;attribute name="stylesheet-prefix" type="xsl:prefix-or-default" use="required"/&gt;
        &lt;attribute name="result-prefix" type="xsl:prefix-or-default" use="required"/&gt;
      &lt;/extension&gt;
    &lt;/complexContent&gt;
  &lt;/complexType&gt;
&lt;/element&gt;

&lt;element name="non-matching-substring" type="xsl:content-constructor"/&gt;

&lt;element name="number" substitutionGroup="xsl:instruction"&gt;
  &lt;complexType&gt;
    &lt;complexContent&gt;
      &lt;extension base="xsl:versioned-element-type"&gt;
        &lt;attribute name="level" type="xsl:level" default="single"/&gt;
        &lt;attribute name="count" type="xsl:pattern"/&gt;
        &lt;attribute name="from" type="xsl:pattern"/&gt;
        &lt;attribute name="value" type="xsl:expression"/&gt;
        &lt;attribute name="format" type="xsl:avt" use="optional" default="1"/&gt;
        &lt;attribute name="lang" type="xsl:avt"/&gt;
        &lt;attribute name="letter-value" type="xsl:avt"/&gt;
        &lt;attribute name="grouping-separator" type="xsl:avt"/&gt;
        &lt;attribute name="grouping-size" type="xsl:avt"/&gt;
      &lt;/extension&gt;
    &lt;/complexContent&gt;
  &lt;/complexType&gt;
&lt;/element&gt;

&lt;element name="output" substitutionGroup="xsl:declaration"&gt;
  &lt;complexType&gt;
    &lt;complexContent&gt;
      &lt;extension base="xsl:generic-element-type"&gt;
        &lt;attribute name="method" type="xsl:method"/&gt;
        &lt;attribute name="version" type="NMTOKEN"/&gt;
        &lt;attribute name="encoding" type="string"/&gt;
        &lt;attribute name="omit-xml-declaration" type="xsl:yes-or-no"/&gt;
        &lt;attribute name="standalone" type="xsl:yes-or-no"/&gt;
        &lt;attribute name="doctype-public" type="string"/&gt;
        &lt;attribute name="doctype-system" type="string"/&gt;
        &lt;attribute name="cdata-section-elements" type="xsl:QNames"/&gt;
        &lt;attribute name="escape-uri-attributes" type="xsl:yes-or-no"/&gt;
        &lt;attribute name="include-content-type" type="xsl:yes-or-no"/&gt;
        &lt;attribute name="indent" type="xsl:yes-or-no"/&gt;
        &lt;attribute name="media-type" type="string"/&gt;
        &lt;attribute name="normalize-unicode" type="xsl:yes-or-no"/&gt;
      &lt;/extension&gt;
    &lt;/complexContent&gt;
  &lt;/complexType&gt;
&lt;/element&gt;

&lt;element name="otherwise" type="xsl:content-constructor"/&gt;

&lt;element name="param"&gt;
  &lt;complexType mixed="true"&gt;
    &lt;complexContent&gt;
      &lt;extension base="xsl:content-constructor"&gt;
        &lt;attribute name="name" type="QName" use="required"/&gt;
        &lt;attribute name="select" type="xsl:expression"/&gt;
        &lt;attribute name="as" type="xsl:sequence-type"/&gt;
        &lt;attribute name="type-information" type="xsl:type-information-type"/&gt;
        &lt;attribute name="required" type="xsl:yes-or-no"/&gt;
      &lt;/extension&gt;
    &lt;/complexContent&gt;
  &lt;/complexType&gt;
&lt;/element&gt;

&lt;element name="preserve-space" substitutionGroup="xsl:declaration"&gt;
  &lt;complexType&gt;
    &lt;complexContent&gt;
      &lt;extension base="xsl:versioned-element-type"&gt;
        &lt;attribute name="elements" type="xsl:nametests" use="required"/&gt;
      &lt;/extension&gt;
    &lt;/complexContent&gt;
  &lt;/complexType&gt;
&lt;/element&gt;

&lt;element name="processing-instruction" substitutionGroup="xsl:instruction"&gt;
  &lt;complexType mixed="true"&gt;
    &lt;complexContent&gt;
      &lt;extension base="xsl:content-constructor"&gt;
        &lt;attribute name="name" type="xsl:avt" use="required"/&gt;
      &lt;/extension&gt;
    &lt;/complexContent&gt;
  &lt;/complexType&gt;
&lt;/element&gt;

&lt;element name="result"&gt;
  &lt;complexType mixed="true"&gt;
    &lt;complexContent&gt;
      &lt;extension base="xsl:content-constructor"&gt;
        &lt;attribute name="select" type="xsl:expression" use="optional"/&gt;
        &lt;attribute name="as" type="xsl:sequence-type" use="optional"/&gt;
        &lt;attribute name="type-information" type="xsl:type-information-type"/&gt;
      &lt;/extension&gt;
    &lt;/complexContent&gt;
  &lt;/complexType&gt;
&lt;/element&gt;

&lt;element name="result-document" substitutionGroup="xsl:instruction"&gt;
  &lt;complexType&gt;
    &lt;complexContent&gt;
      &lt;extension base="xsl:versioned-element-type"&gt;
        &lt;attribute name="format" type="QName"/&gt;
        &lt;attribute name="href" type="xsl:avt"/&gt;
        &lt;attribute name="type-information" type="xsl:type-information-type"/&gt;
      &lt;/extension&gt;
    &lt;/complexContent&gt;
  &lt;/complexType&gt;
&lt;/element&gt;

&lt;element name="sort"&gt;
  &lt;complexType&gt;
    &lt;complexContent&gt;
      &lt;extension base="xsl:versioned-element-type"&gt;
        &lt;attribute name="select" type="xsl:expression" use="optional" default="."/&gt;  
        &lt;attribute name="lang" type="xsl:avt"/&gt;        
        &lt;attribute name="data-type" type="xsl:avt" use="optional" default="text"/&gt;        
        &lt;attribute name="order" type="xsl:avt" use="optional" default="ascending"/&gt;        
        &lt;attribute name="case-order" type="xsl:avt"/&gt;
        &lt;attribute name="as" type="xsl:avt"/&gt;
        &lt;attribute name="collation" type="xsl:avt"/&gt;
      &lt;/extension&gt;
    &lt;/complexContent&gt;
  &lt;/complexType&gt;
&lt;/element&gt;

&lt;element name="sort-key" substitutionGroup="xsl:declaration"&gt;
  &lt;complexType&gt;
    &lt;complexContent&gt;
      &lt;extension base="xsl:versioned-element-type"&gt;
        &lt;sequence minOccurs="1" maxOccurs="unbounded"&gt;
          &lt;element ref="xsl:sort"/&gt;
        &lt;/sequence&gt;
        &lt;attribute name="name" type="QName" use="required"/&gt;
      &lt;/extension&gt;
    &lt;/complexContent&gt;
  &lt;/complexType&gt;
&lt;/element&gt;

&lt;element name="strip-space" substitutionGroup="xsl:declaration"&gt;
  &lt;complexType&gt;
    &lt;complexContent&gt;
      &lt;extension base="xsl:versioned-element-type"&gt;
        &lt;attribute name="elements" type="xsl:nametests" use="required"/&gt;
      &lt;/extension&gt;
    &lt;/complexContent&gt;
  &lt;/complexType&gt;
&lt;/element&gt;

&lt;element name="stylesheet" substitutionGroup="xsl:transform"/&gt;

&lt;element name="template" substitutionGroup="xsl:declaration"&gt;
  &lt;complexType mixed="true"&gt;
    &lt;complexContent&gt;
      &lt;extension base="xsl:versioned-element-type"&gt;
        &lt;sequence&gt;
          &lt;element ref="xsl:param" minOccurs="0" maxOccurs="unbounded"/&gt;
          &lt;group ref="xsl:content-constructor-group"/&gt;
        &lt;/sequence&gt;
        &lt;attribute name="match" type="xsl:pattern"/&gt;
        &lt;attribute name="priority" type="decimal"/&gt;
        &lt;attribute name="mode" type="xsl:modes"/&gt;
        &lt;attribute name="name" type="QName"/&gt;
      &lt;/extension&gt;
    &lt;/complexContent&gt;
  &lt;/complexType&gt;
&lt;/element&gt;

&lt;element name="text" substitutionGroup="xsl:instruction"&gt;
  &lt;complexType mixed="true"&gt;
    &lt;complexContent&gt;
      &lt;extension base="xsl:content-constructor"&gt;
        &lt;attribute name="disable-output-escaping" type="xsl:yes-or-no" default="no"/&gt;
      &lt;/extension&gt;
    &lt;/complexContent&gt;
  &lt;/complexType&gt;
&lt;/element&gt;

&lt;element name="transform"&gt;
  &lt;complexType&gt;
    &lt;complexContent&gt;
      &lt;extension base="xsl:generic-element-type"&gt;
        &lt;sequence&gt;
          &lt;element ref="xsl:import" minOccurs="0" maxOccurs="unbounded"/&gt;
          &lt;choice  minOccurs="0" maxOccurs="unbounded"&gt;
            &lt;element ref="xsl:declaration"/&gt;
            &lt;element ref="xsl:variable"/&gt;
            &lt;element ref="xsl:param"/&gt;              
            &lt;any namespace="##other" processContents="skip"/&gt; &lt;!-- weaker than XSLT 1.0 --&gt;
          &lt;/choice&gt;
        &lt;/sequence&gt;
        &lt;attribute name="id" type="ID"/&gt;
        &lt;attribute name="version" type="decimal" use="required"/&gt;
      &lt;/extension&gt;
    &lt;/complexContent&gt;
  &lt;/complexType&gt;
&lt;/element&gt;

&lt;element name="value-of" substitutionGroup="xsl:instruction"&gt;
  &lt;complexType&gt;
    &lt;complexContent&gt;
      &lt;extension base="xsl:versioned-element-type"&gt;
        &lt;attribute name="select" type="xsl:expression" use="required"/&gt;
        &lt;attribute name="separator" type="xsl:avt"/&gt;            
        &lt;attribute name="disable-output-escaping" type="xsl:yes-or-no" default="no"/&gt;
      &lt;/extension&gt;
    &lt;/complexContent&gt;
  &lt;/complexType&gt;
&lt;/element&gt;

&lt;element name="variable"&gt;
  &lt;complexType mixed="true"&gt;
    &lt;complexContent&gt;
      &lt;extension base="xsl:content-constructor"&gt;
        &lt;attribute name="name" type="QName" use="required"/&gt;
        &lt;attribute name="select" type="xsl:expression" use="optional"/&gt;
        &lt;attribute name="as" type="xsl:sequence-type" use="optional"/&gt;
        &lt;attribute name="type-information" type="xsl:type-information-type"/&gt;
      &lt;/extension&gt;
    &lt;/complexContent&gt;
  &lt;/complexType&gt;
&lt;/element&gt;

&lt;element name="when"&gt;
  &lt;complexType mixed="true"&gt;
    &lt;complexContent&gt;
      &lt;extension base="xsl:content-constructor"&gt;
        &lt;attribute name="test" type="xsl:expression" use="required"/&gt;
      &lt;/extension&gt;
    &lt;/complexContent&gt;
  &lt;/complexType&gt;
&lt;/element&gt;

&lt;element name="with-param"&gt;
  &lt;complexType mixed="true"&gt;
    &lt;complexContent&gt;
      &lt;extension base="xsl:content-constructor"&gt;
        &lt;attribute name="name" type="QName" use="required"/&gt;
        &lt;attribute name="select" type="xsl:expression" use="optional"/&gt;
        &lt;attribute name="type-information" type="xsl:type-information-type"/&gt;
      &lt;/extension&gt;
    &lt;/complexContent&gt;
  &lt;/complexType&gt;
&lt;/element&gt;

&lt;!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ --&gt;
&lt;annotation&gt;
  &lt;documentation&gt;
    PART C: definition of literal result elements
    
    There are three ways to define the literal result elements
    permissible in a stylesheet.
    
    (a) do nothing. This allows any element to be used as a literal
        result element, provided it is not in the XSLT namespace
    
    (b) declare all permitted literal result elements as members
        of the xsl:literal-result-element substitution group
        
    (c) redefine the model group xsl:result-elements to accommodate
        all permitted literal result elements.
        
    Literal result elements are allowed to take certain attributes
    in the XSLT namespace. These are defined in the attribute group
    literal-result-element-attributes, which can be included in the
    definition of any literal result element.
    
  &lt;/documentation&gt;
&lt;/annotation&gt;   
&lt;!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ --&gt;

&lt;element name="literal-result-element" abstract="true" type="anyType"/&gt;

&lt;attributeGroup name="literal-result-element-attributes"&gt;
    &lt;attribute name="extension-element-prefixes" form="qualified" type="string"/&gt;
    &lt;attribute name="exclude-result-prefixes" form="qualified" type="string"/&gt;
    &lt;attribute name="default-xpath-namespace" form="qualified" type="anyURI"/&gt;    
    &lt;attribute name="use-attribute-sets" form="qualified" type="xsl:QNames"/&gt;
    &lt;attribute name="version" form="qualified" type="decimal"/&gt;
    &lt;attribute name="type-annotation" form="qualified" type="QName"/&gt;
    &lt;anyAttribute namespace="##other" processContents="skip"/&gt;
&lt;/attributeGroup&gt;

&lt;group name="result-elements"&gt;
  &lt;choice&gt;
    &lt;element ref="xsl:literal-result-element"/&gt;
    &lt;any namespace="##other" processContents="skip"/&gt;
  &lt;/choice&gt;
&lt;/group&gt;


&lt;!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ --&gt;
&lt;annotation&gt;
  &lt;documentation&gt;
    PART D: definitions of simple types used in stylesheet attributes 
  &lt;/documentation&gt;
&lt;/annotation&gt;   
&lt;!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ --&gt;

&lt;simpleType name="avt"&gt;
  &lt;annotation&gt;
    &lt;documentation&gt;
      This type is used for all attributes that allow an attribute value template.
      The general rules for the syntax of attribute value templates, and the specific
      rules for each such attribute, are described in the XSLT 2.0 Recommendation.
    &lt;/documentation&gt;
  &lt;/annotation&gt;
  &lt;restriction base="string"/&gt;
&lt;/simpleType&gt;

&lt;simpleType name="char"&gt;
  &lt;annotation&gt;
    &lt;documentation&gt;
      A string containing exactly one character.
    &lt;/documentation&gt;
  &lt;/annotation&gt;
  &lt;restriction base="string"&gt;
    &lt;length value="1"/&gt;
  &lt;/restriction&gt;
&lt;/simpleType&gt;

&lt;simpleType name="expression"&gt;
  &lt;annotation&gt;
    &lt;documentation&gt;
      An XPath 2.0 expression.
    &lt;/documentation&gt;
  &lt;/annotation&gt;
  &lt;restriction base="string"&gt;
    &lt;pattern value=".+"/&gt;
  &lt;/restriction&gt;
&lt;/simpleType&gt;

&lt;simpleType name="level"&gt;
  &lt;annotation&gt;
    &lt;documentation&gt;
      The level attribute of xsl:number: 
      one of single, multiple, or any.
    &lt;/documentation&gt;
  &lt;/annotation&gt;
  &lt;restriction base="NCName"&gt;
    &lt;enumeration value="single"/&gt;
    &lt;enumeration value="multiple"/&gt;
    &lt;enumeration value="any"/&gt;
  &lt;/restriction&gt;
&lt;/simpleType&gt;

&lt;simpleType name="mode"&gt;
  &lt;annotation&gt;
    &lt;documentation&gt;
      The mode attribute of xsl:apply-templates: 
      either a QName, or #current, or #default.
    &lt;/documentation&gt;
  &lt;/annotation&gt;
  &lt;union memberTypes="QName"&gt;
    &lt;simpleType&gt;
      &lt;restriction base="string"&gt;
        &lt;enumeration value="#default"/&gt;
        &lt;enumeration value="#current"/&gt;
      &lt;/restriction&gt;
    &lt;/simpleType&gt;
  &lt;/union&gt;
&lt;/simpleType&gt;

&lt;simpleType name="modes"&gt;
  &lt;annotation&gt;
    &lt;documentation&gt;
      The mode attribute of xsl:template: 
      a list, each member being either a QName, or #default.
    &lt;/documentation&gt;
  &lt;/annotation&gt;
  &lt;list&gt;
    &lt;simpleType&gt;
      &lt;union memberTypes="QName"&gt;
        &lt;simpleType&gt;
          &lt;restriction base="string"&gt;
            &lt;enumeration value="#default"/&gt;
          &lt;/restriction&gt;
        &lt;/simpleType&gt;
      &lt;/union&gt;
    &lt;/simpleType&gt;
  &lt;/list&gt;
&lt;/simpleType&gt;

&lt;simpleType name="nametests"&gt;
  &lt;annotation&gt;
    &lt;documentation&gt;
      A list of NameTests, as defined in the XPath 2.0 Recommendation.
      Each NameTest is either a QName, or "*", or "prefix:*", or "*:localname"
    &lt;/documentation&gt;
  &lt;/annotation&gt;
  &lt;list&gt;
    &lt;simpleType&gt;
      &lt;union memberTypes="QName"&gt;
        &lt;simpleType&gt;
          &lt;restriction base="string"&gt;
            &lt;pattern value="\*"/&gt;
            &lt;pattern value="\i\c*:\*"/&gt;
            &lt;pattern value="\*:\i\c*"/&gt;            
          &lt;/restriction&gt;
        &lt;/simpleType&gt;
      &lt;/union&gt;
    &lt;/simpleType&gt;
  &lt;/list&gt;
&lt;/simpleType&gt;

&lt;simpleType name="tokens"&gt;
  &lt;list itemType="token"/&gt;
&lt;/simpleType&gt;

&lt;simpleType name="method"&gt;
  &lt;annotation&gt;
    &lt;documentation&gt;
      The method attribute of xsl:output:
      Either one of the recognized names "xml", "xhtml", "html", "text",
      or a QName that must include a prefix.
    &lt;/documentation&gt;
  &lt;/annotation&gt;
  &lt;union&gt;
    &lt;simpleType&gt;
      &lt;restriction base="NCName"&gt;
        &lt;enumeration value="xml"/&gt;
        &lt;enumeration value="xhtml"/&gt;
        &lt;enumeration value="html"/&gt;
        &lt;enumeration value="text"/&gt;
      &lt;/restriction&gt;
    &lt;/simpleType&gt;
    &lt;simpleType&gt;
      &lt;restriction base="QName"&gt;
        &lt;pattern value="\c*:\c*"/&gt;
      &lt;/restriction&gt;
    &lt;/simpleType&gt;
  &lt;/union&gt;
&lt;/simpleType&gt;

&lt;simpleType name="pattern"&gt;
  &lt;annotation&gt;
    &lt;documentation&gt;
      A match pattern as defined in the XSLT 2.0 Recommendation.
      The syntax for patterns is a restricted form of the syntax for
      XPath 2.0 expressions.
    &lt;/documentation&gt;
  &lt;/annotation&gt;
  &lt;restriction base="xsl:expression"/&gt;
&lt;/simpleType&gt;

&lt;simpleType name="prefix-or-default"&gt;
  &lt;annotation&gt;
    &lt;documentation&gt;
      Either a namespace prefix, or #default.
      Used in the xsl:namespace-alias element.
    &lt;/documentation&gt;
  &lt;/annotation&gt;
  &lt;union memberTypes="NCName"&gt;
    &lt;simpleType&gt;
      &lt;restriction base="string"&gt;
        &lt;enumeration value="#default"/&gt;
      &lt;/restriction&gt;
    &lt;/simpleType&gt;
  &lt;/union&gt;
&lt;/simpleType&gt;

&lt;simpleType name="QNames"&gt;
  &lt;annotation&gt;
    &lt;documentation&gt;
      A list of QNames.
      Used in the [xsl:]use-attribute-sets attribute of various elements,
      and in the cdata-section-elements attribute of xsl:output
    &lt;/documentation&gt;
  &lt;/annotation&gt;
  &lt;list itemType="QName"/&gt;          
&lt;/simpleType&gt;

&lt;simpleType name="sequence-type"&gt;
  &lt;annotation&gt;
    &lt;documentation&gt;
      The description of a data type, conforming to the
      SequenceType production defined in the XPath 2.0 Recommendation
    &lt;/documentation&gt;
  &lt;/annotation&gt;
  &lt;restriction base="string"&gt;
      &lt;pattern value=".+"/&gt;      
  &lt;/restriction&gt;
&lt;/simpleType&gt;

&lt;simpleType name="type-information-type"&gt;
  &lt;annotation&gt;
    &lt;documentation&gt;
      Describes different ways of handling type information in a newly constructed tree.
    &lt;/documentation&gt;
  &lt;/annotation&gt;
  &lt;restriction base="string"&gt;
    &lt;enumeration value="strict"/&gt;
    &lt;enumeration value="lax"/&gt;
    &lt;enumeration value="preserve"/&gt;
    &lt;enumeration value="none"/&gt;    
  &lt;/restriction&gt;
&lt;/simpleType&gt;

&lt;simpleType name="yes-or-no"&gt;
  &lt;annotation&gt;
    &lt;documentation&gt;
      One of the values "yes" or "no".
    &lt;/documentation&gt;
  &lt;/annotation&gt;
  &lt;restriction base="string"&gt;
    &lt;enumeration value="yes"/&gt;
    &lt;enumeration value="no"/&gt;
  &lt;/restriction&gt;
&lt;/simpleType&gt;

&lt;/schema&gt;</pre></div><div class="div1">
<h2><a name="lexical-representation" id="lexical-representation"></a>G Representation of Lexical XML Constructs (Non-Normative)</h2><p>Sometimes it is useful, when performing a transformation, to retain 
lexical detail from the source document within the result document. Examples
of such details include entity references and CDATA section boundaries.
Since these details do not form part of the data model, they are normally
lost in the course of transformation, which can make subsequent editing
of the document more difficult.</p><p>This appendix therefore defines a way in which these lexical details can
be represented within the data model, by means of elements in a special namespace,
specifically <code>http://www.w3.org/2002/04/XSL/Transform/LexicalMapping</code>,
with a conventional prefix of <code>lex</code>.
The process that builds a source tree for a transformation may use
this mapping to represent lexical constructs encountered in the source document,
and the serializer may interpret the elements in this namespace as directives
to reproduce these lexical constructs on output.
 There is no requirement that XSLT processors must support this mapping. 
 The transformation itself does not treat these elements
 specially; they will be visible to the stylesheet in the same way as any other
 element, and what happens to them is entirely under the control of the
 stylesheet author. A stylesheet is free to copy these elements, or to ignore them,
 or to create new elements in this namespace as directives to the serializer.</p><p>If an implementation chooses to support these mappings, it is suggested
that this should be done by means of a user option that causes the tree
construction process to create the relevant elements, and
the serializer to interpret them. This option should not be the default
mode of processing.</p><p>The elements are listed below:</p><table><thead><tr><th align="left" rowspan="1" colspan="1">Element Name</th><th align="left" rowspan="1" colspan="1">Attributes</th><th align="left" rowspan="1" colspan="1">Meaning</th></tr></thead><tbody><tr><td valign="top" rowspan="1" colspan="1">
							<code>lex:cdata-section</code>
						</td><td valign="top" rowspan="1" colspan="1">None</td><td valign="top" rowspan="1" colspan="1">Defines a CDATA section. The content of the CDATA section
is represented in the form of child nodes of the <code>lex:cdata-section</code> 
element.</td></tr><tr><td valign="top" rowspan="1" colspan="1">
							<code>lex:entity-reference</code>
						</td><td valign="top" rowspan="1" colspan="1">name</td><td valign="top" rowspan="1" colspan="1">Marks the point in the source text where a general entity reference
occurred. The <code>name</code> attribute gives the name of the entity. 
The expanded content of the entity is represented in the form of child
nodes of the <code>lex:entity-reference</code> element. Note that
entity references within attribute values cannot be represented
this way.</td></tr><tr><td valign="top" rowspan="1" colspan="1">
							<code>lex:doctype</code>
						</td><td valign="top" rowspan="1" colspan="1">name, public-id, system-id</td><td valign="top" rowspan="1" colspan="1">Marks the point in the source text where the DOCTYPE declaration
occurred. The <code>name</code>
attribute gives the name of the document type. 
The optional <code>system-id</code> attribute gives
the system identifier of the external DTD subset. 
The optional <code>public-id</code> attribute gives
the public identifier of the external DTD subset.</td></tr><tr><td valign="top" rowspan="1" colspan="1">
							<code>lex:element-declaration</code>
						</td><td valign="top" rowspan="1" colspan="1">name, model</td><td valign="top" rowspan="1" colspan="1">Represents an element declaration within the internal DTD subset.
This element will appear only as a child of <code>lex:doctype</code>. 
The <code>name</code>
attribute gives the name of the element type. 
The <code>model</code> attribute gives
the content model of the element type, as an unparsed string. This
may be normalized, for example by expansion of parameter entities, removal
of whitespace, at implementor option.</td></tr><tr><td valign="top" rowspan="1" colspan="1">
							<code>lex:attribute-declaration</code>
						</td><td valign="top" rowspan="1" colspan="1">element-name, attribute-name, attribute-type, optional, default-value</td><td valign="top" rowspan="1" colspan="1">Represents an attribute declaration within the internal DTD subset. 
This element will appear only as a child of <code>lex:doctype</code>. 
The <code>element-name</code>
attribute gives the name of the element. 
The <code>attribute-name</code>
attribute gives the name of the attribute.
The <code>attribute-type</code> attribute gives
the attribute type, for example <code>CDATA</code> or <code>IDREFS</code>.
The <code>optional</code> attribute takes the value <code>FIXED</code>,
<code>REQUIRED</code>, or <code>IMPLIED</code>; it is omitted if none
of these is applicable.
The <code>default-value</code> attribute gives the default value for
the attribute if one has been defined; if not, this attribute is omitted.
</td></tr><tr><td valign="top" rowspan="1" colspan="1">
							<code>lex:notation-declaration</code>
						</td><td valign="top" rowspan="1" colspan="1">name, system-id, public-id</td><td valign="top" rowspan="1" colspan="1">Represents an notation declaration within the internal DTD subset. 
This element will appear only as a child of <code>lex:doctype</code>. 
The <code>name</code>
attribute gives the name of the notation. 
The optional <code>system-id</code> attribute gives
the system identifier of the notation. 
The optional <code>public-id</code> attribute gives
the public identifier of the notation.</td></tr><tr><td valign="top" rowspan="1" colspan="1">
							<code>lex:unparsed-entity-declaration</code>
						</td><td valign="top" rowspan="1" colspan="1">name, system-id, public-id, notation-name</td><td valign="top" rowspan="1" colspan="1">Represents an unparsed entity declaration within the internal DTD subset. 
This element will appear only as a child of <code>lex:doctype</code>. 
The <code>name</code>
attribute gives the name of the unparsed entity. 
The <code>system-id</code> attribute gives
the system identifier of the unparsed entity. 
The optional <code>public-id</code> attribute gives
the public identifier of the unparsed entity.
The <code>notation-name</code>
attribute gives the name of the associated notation. 
</td></tr></tbody></table><p>Note that even when using this representation of the lexical structure of
an XML document, the tree will contain attribute nodes representing attributes
whose values were defaulted from the DTD. A stylesheet that wishes to avoid
outputting such attributes must include the necessary logic to avoid this; it
is not possible from the tree representation to determine whether the attribute
was actually present in the original XML instance.</p></div><div class="div1">
<h2><a name="d5e19410" id="d5e19410"></a>H Acknowledgements (Non-Normative)</h2><p>This specification was developed and approved for publication by the
W3C XSL Working Group (WG). WG approval of this specification does not
necessarily imply that all WG members voted for its approval.</p><p>The current chair of the XSL WG is Sharon Adler, IBM. The
other members of the XSL WG are:</p><table border="1"><thead><tr><th rowspan="1" colspan="1">Principal</th><th rowspan="1" colspan="1">Alternate</th><th rowspan="1" colspan="1">Affiliation</th></tr></thead><tbody><tr><td rowspan="1" colspan="1">Amr Yassin</td><td rowspan="1" colspan="1">-</td><td rowspan="1" colspan="1">Philips Electronics</td></tr><tr><td rowspan="1" colspan="1">Sanjiva Weerawarana</td><td rowspan="1" colspan="1">Anders Berglund</td><td rowspan="1" colspan="1">IBM</td></tr><tr><td rowspan="1" colspan="1">Henry Thompson</td><td rowspan="1" colspan="1">-</td><td rowspan="1" colspan="1">HCRC Language Technology Group, University of Edinburgh</td></tr><tr><td rowspan="1" colspan="1">Bob Lojek</td><td rowspan="1" colspan="1">-</td><td rowspan="1" colspan="1">Mozquito Technologies</td></tr><tr><td rowspan="1" colspan="1">Jeff Caruso</td><td rowspan="1" colspan="1">Andrew Greene</td><td rowspan="1" colspan="1">Pageflex, Inc.</td></tr><tr><td rowspan="1" colspan="1">Paul Grosso</td><td rowspan="1" colspan="1">-</td><td rowspan="1" colspan="1">Arbortext</td></tr><tr><td rowspan="1" colspan="1">Michael Kay</td><td rowspan="1" colspan="1">Juliane Harbarth</td><td rowspan="1" colspan="1">Software AG Inc</td></tr><tr><td rowspan="1" colspan="1">Jeremy Richman</td><td rowspan="1" colspan="1">-</td><td rowspan="1" colspan="1">Interleaf</td></tr><tr><td rowspan="1" colspan="1">Norm Walsh</td><td rowspan="1" colspan="1">Tony Graham</td><td rowspan="1" colspan="1">Sun Microsystems Inc.</td></tr><tr><td rowspan="1" colspan="1">Scott Boag</td><td rowspan="1" colspan="1">-</td><td rowspan="1" colspan="1">Lotus Development Corporation</td></tr><tr><td rowspan="1" colspan="1">Scott Parnell</td><td rowspan="1" colspan="1">-</td><td rowspan="1" colspan="1">Xerox</td></tr><tr><td rowspan="1" colspan="1">Perin Blanchard</td><td rowspan="1" colspan="1">Shon Vella</td><td rowspan="1" colspan="1">Novell, Inc.</td></tr><tr><td rowspan="1" colspan="1">Jonathan Marsh</td><td rowspan="1" colspan="1">Ashok Malhotra</td><td rowspan="1" colspan="1">Microsoft Corporation</td></tr><tr><td rowspan="1" colspan="1">Zarella Rendon</td><td rowspan="1" colspan="1">-</td><td rowspan="1" colspan="1">DataChannel</td></tr><tr><td rowspan="1" colspan="1">Bill Lindsey</td><td rowspan="1" colspan="1">-</td><td rowspan="1" colspan="1">B-Bop</td></tr><tr><td rowspan="1" colspan="1">Chris Maden</td><td rowspan="1" colspan="1">Ray Waldin</td><td rowspan="1" colspan="1">Lexica</td></tr><tr><td rowspan="1" colspan="1">Peter Van der Beken</td><td rowspan="1" colspan="1">-</td><td rowspan="1" colspan="1">Netscape/AOL</td></tr><tr><td rowspan="1" colspan="1">Evan Lenz</td><td rowspan="1" colspan="1">-</td><td rowspan="1" colspan="1">XYZFind Corp.</td></tr><tr><td rowspan="1" colspan="1">Dipak Chopra</td><td rowspan="1" colspan="1">-</td><td rowspan="1" colspan="1">SAP Labs</td></tr><tr><td rowspan="1" colspan="1">Mark Scardina</td><td rowspan="1" colspan="1">K Karun</td><td rowspan="1" colspan="1">Oracle</td></tr><tr><td rowspan="1" colspan="1">Daniela Florescu</td><td rowspan="1" colspan="1">-</td><td rowspan="1" colspan="1">Propel</td></tr><tr><td rowspan="1" colspan="1">Alex Milowski</td><td rowspan="1" colspan="1">-</td><td rowspan="1" colspan="1">Markup Technology Ltd.</td></tr><tr><td rowspan="1" colspan="1">Kristoffer Rose</td><td rowspan="1" colspan="1"></td><td rowspan="1" colspan="1">IBM</td></tr></tbody></table><p>The W3C representative on the XSL WG is Max Froumentin.</p><p>The following individuals made significant contributions to XSLT 2.0 while they were members
 of the WG:</p><blockquote><p>James Clark, Invited Expert<br>Steve Muench, Oracle<br>Steve Zilles, Adobe</p></blockquote><p>The working group wishes to acknowledge the contribution made by David Marston
			of IBM to the new specification of the <a href="#function-format-number"><b>format-number</b></a> function.</p><p>This specification builds on the success of the XSLT 1.0 Recommendation. 
For a list of contributors to XSLT 1.0, see <a href="#XSLT10">[XSLT 1.0]</a>.</p></div><div class="div1">
<h2><a name="d5e19607" id="d5e19607"></a>I Checklist of Requirements (Non-Normative)</h2><p>This section provides a checklist of progress against the published
XSLT 2.0 Requirements document.</p>
				
					<p><b><i>Requirement 1</i></b></p>
						<p>Must&nbsp;Maintain Backwards Compatibility with XSLT 1.1 
         [Read this as "with XSLT 1.0"]</p>
						<p>Any stylesheet whose behavior is fully defined in XSLT
1.0 and which generates no errors will produce the same result tree under
XSLT 2.0</p>
					
					<p><i>Response</i></p>
						<p>See <a href="#incompatibilities"><b>K.1 Incompatible Changes</b></a>
						</p>
					
				
				
					<p><b><i>Requirement 2</i></b></p>
						<p>Must Match Elements with Null Values</p>
						<p>A stylesheet should be able to match elements and attributes whose value
          is explicitly null. </p>
					
					<p><i>Response</i></p>
						<p>This has been handled as an XPath 2.0 requirement.</p>
					
				
				
					<p><b><i>Requirement 3</i></b></p>
						<p>Should&nbsp;Allow Included Documents to "Encapsulate"  Local Stylesheets</p>
						<p>XSLT 2.0 SHOULD define a mechanism to allow the templates in  a stylesheet
          associated with a secondary source document, to be imported and used
           to format the included fragment, taking precedence over any applicable
            templates in the current stylesheet.</p>
					
					<p><i>Response</i></p>
						<p>The facility to define modes has been generalized, making it easier
      to define a distinct set of template rules for processing a particular document.</p>
					
				
				
					<p><b><i>Requirement 4</i></b></p>
						<p>Could&nbsp;Support Accessing Infoset Items for XML Declaration</p>
						<p>A stylesheet COULD be able to access information like the version and
          encoding from the XML declaration of a document.</p>
					
					<p><i>Response</i></p>
						<p>No new facilities have been provided in this area, because
						this information is not available in the Data Model.</p>
					
				
				
					<p><b><i>Requirement 5</i></b></p>
						<p>Could&nbsp;Provide QName Aware String Functions</p>
						<p>Users manipulating documents (e.g. stylesheets, schemas) that have
          QName-valued element or attribute content need functions that take a
string containing a QName as their argument, convert it to an <a title="expanded-QName" href="#dt-expanded-qname">expanded-QName</a>
using either the namespace declarations in scope at that point in the
stylesheet, or the namespace declarations in scope for a specific source
node, and return properties of the <a title="expanded-QName" href="#dt-expanded-qname">expanded-QName</a> such as its namespace URI
and local name.</p>
					
					<p><i>Response</i></p>
						<p>Functions operating on QNames are included in the XPath 2.0 
      Functions and Operators document: see <a href="#FANDO">[Functions and Operators]</a>.</p>
					
				
				
					<p><b><i>Requirement 6</i></b></p>
						<p>Could&nbsp;Enable Constructing a Namespace with Computed Name</p>
						<p>Provide an <a href="#element-namespace"><code>xsl:namespace</code></a> analog to
          <a href="#element-element"><code>xsl:element</code></a> for constructing
          a namespace node with a computed prefix and URI.</p>
					
					<p><i>Response</i></p>
						<p>An <a href="#element-namespace"><code>xsl:namespace</code></a> instruction has been added: see
         <a href="#creating-namespace-nodes"><b>11.6 Creating Namespace Nodes</b></a>.</p>
					
				
				
					<p><b><i>Requirement 7</i></b></p>
						<p>Could&nbsp;Simplify Resolving Prefix Conflicts in QName-Valued Attributes</p>
						<p>XSLT 2.0 could simplify the renaming of conflicting namespace prefixes in
          result tree fragments, particularly for attributes declared in a schema
           as being QNames. Once the processor knows an attribute value
is a QName, an XSLT processor should be able to rename prefixes and
generate namespace declarations to preserve the semantics of that
attribute value, just as it does for attribute names.  </p>
					
					<p><i>Response</i></p>
						<p>If an attribute is typed as a QName in the schema, the
      new XPath 2.0 functions can be used to manipulate it as required at
      application level. This may be sufficient to meet the requirement.</p>
					
				
				
					<p><b><i>Requirement 8</i></b></p>
						<p>Could&nbsp;Support XHTML Output Method</p>
						<p>Complementing the existing output methods for html, xml, and text, an
          xhtml output method could be provided to simplify transformations which
           target XHTML output.</p>
					
					<p><i>Response</i></p>
						<p>An XHTML output method is now provided: see <a href="#xhtml-output"><b>20.2 XHTML Output Method</b></a></p>
					
				
				
					<p><b><i>Requirement 9</i></b></p>
						<p>Must&nbsp;Allow Matching on Default Namespace Without Explicit Prefix</p>
						<p>Many users stumble trying to match an element with a default namespace.</p>
					
					<p><i>Response</i></p>
						<p>A new <code>[xsl:]default-xpath-namespace</code> attribute 
      is provided for this purpose: see <a href="#unprefixed-qnames"><b>5.4 Unprefixed Names in Expressions and Patterns</b></a></p>
					
				
				
					<p><b><i>Requirement 10</i></b></p>
						<p>Must&nbsp;Add Date Formatting Functions</p>
						<p>One of the more frequent requests from XSLT 1.0 users is the ability
          to format date information with similar control  to XSLT's
           format-number. XML Schema introduces several kinds of date
            and time datatypes which will further increase the demand
             for date formatting during transformations. Functionality
              similar to that provided by java.text.SimpleDateFormat.
               A date analog of XSLT's named  xsl:decimal-format may
                be required to handle locale-specific date formatting issues. </p>
					
					<p><i>Response</i></p>
						<p>Date manipulation functions are included in XPath 2.0, but no formatting
      capability is provided yet. The XSL Working Group intends to provide
      such a function in the final Recommendation.</p>
					
				
				
					<p><b><i>Requirement 11</i></b></p>
						<p>Must&nbsp;Simplify Accessing Id's and Key's in Other Documents</p>
						<p>Currently it is cumbersome to lookup nodes by id() or key() in documents
          other than the source document. Users must first use an xsl:for-each
           instruction, selecting the desired document() to make it the current
            node, then relative XPath expressions within the scope of the
             xsl:for-each can refer to id() or key()  as desired.</p>
					
					<p><i>Response</i></p>
						<p>The requirement is met by the generalization of path syntax in XPath 2.0. It is
						now possible to use a path expression such as <code>document('a.xml')/id('A001')</code>.</p>
					
				
				
					<p><b><i>Requirement 12</i></b></p>
						<p>Should&nbsp;Provide Function to Absolutize Relative URIs</p>
						<p>There SHOULD be a way in XSLT 2.0 to create an absolute URI. The 
         functionality should allow passing a node-set and return a string value 
         representing the absolute URI resolved with respect to the base URI of 
         the current node. </p>
					
					<p><i>Response</i></p>
						<p>A function <u>fn:resolve-uri</u> is now defined in 
      <a href="#FANDO">[Functions and Operators]</a>.</p>
					
				
				
					<p><b><i>Requirement 13</i></b></p>
						<p>Should&nbsp;Include Unparsed Text from an External Resource</p>
						<p>Frequently stylesheets must import text from external resources. 
         Today users have to resort to
          <a title="extension function" href="#dt-extension-function">extension functions</a> to accomplish
           this because XSLT 1.0 only provides the document() function which, while useful,
            can only read external resources that are well-formed XML documents.</p>
					
					<p><i>Response</i></p>
						<p>A function <a href="#function-unparsed-text"><b>unparsed-text</b></a> has been added: see
						<a href="#unparsed-text"><b>16.2 Reading Text Files</b></a></p>
					
				
				
					<p><b><i>Requirement 14</i></b></p>
						<p>Should&nbsp;Allow Authoring Extension Functions in XSLT</p>
						<p>As part of the XSLT 1.1 work done on
          <a title="extension function" href="#dt-extension-function">extension functions</a>, a proposal to 
         author XSLT extension functions in XSLT itself was deferred for reconsideration
          in XSLT 2.0. This would allow the functions in an extension namespace to be
           implemented in "pure" XSLT, without resulting to external programming languages.</p>
					
					<p><i>Response</i></p>
						<p>A solution to this requirement, the <a href="#element-function"><code>xsl:function</code></a> element,
      is included in this specification. See <a href="#stylesheet-functions"><b>10.3 Stylesheet Functions</b></a>.</p>
					
				
				
					<p><b><i>Requirement 15</i></b></p>
						<p>Should&nbsp;Output Character Entity References Instead of Numeric Character Entities</p>
						<p>Users have frequently requested the ability to have the output of their transformation
          use (named) character references  instead of the numeric character entity. 
          The ability to control this preference as the level of the whole document 
          is sufficient. For example, rather than seeing &amp;#160; in the output, 
          the user could request to see the equivalent &amp;nbsp; instead.</p>
					
					<p><i>Response</i></p>
						<p>This requirement has not yet been addressed.</p>
					
				
				
					<p><b><i>Requirement 16</i></b></p>
						<p>Should&nbsp;Construct Entity Reference by Name</p>
						<p>Analogous to the ability to create elements and attributes, users
          have expressed a desire to construct named entity references.  </p>
					
					<p><i>Response</i></p>
						<p>An appendix has been added (see <a href="#lexical-representation"><b>G Representation of Lexical XML Constructs</b></a>)
      defining a method of representing
      the lexical structure of an XML document within the data model. If this representation
      is used, elements representing entity references can be constructed in the result tree.</p>
					
				
				
					<p><b><i>Requirement 17</i></b></p>
						<p>Should&nbsp;Support for Unicode String Normalization</p>
						<p>For reliable string comparison of Unicode strings, users need the ability to 
         apply Unicode normalization before comparing the strings.</p>
					
					<p><i>Response</i></p>
						<p>This requirement has been addressed by the provision of the
						<u>fn:normalize-unicode</u> function described in
						<a href="#FANDO">[Functions and Operators]</a>. In addition, a serialization option
						<code>normalize-unicode="yes"|"no"</code> has been added.</p>
					
				
				
					<p><b><i>Requirement 18</i></b></p>
						<p>Should&nbsp;Standardize Extension Element Language Bindings</p>
						<p>XSLT 1.1 undertook the standarization of language bindings for XSLT 
         <a title="extension function" href="#dt-extension-function">extension functions</a>. 
         For XSLT 2.0, analogous bindings should be provided 
         for extension elements [now 
         renamed <a title="extension instruction" href="#dt-extension-instruction">extension instructions</a>].</p>
					
					<p><i>Response</i></p>
						<p>The XSL Working Group has decided not to pursue this requirement,
      and the attempt to standardize language bindings for extension functions that
      appeared in the XSLT 1.1 Working Draft has now been withdrawn. The Working Group
      decided that language bindings would be better published separately from the
      core XSLT specification.</p>
					
				
				
					<p><b><i>Requirement 19</i></b></p>
						<p>Could&nbsp;Improve Efficiency of Transformations on Large Documents</p>
						<p>Many useful transformations take place on large documents consisting of thousands of repeating "sub-documents". Today 
						transformations over these documents are impractical due to the need to have the entire source tree in memory.  Enabling "progressive" transformations, where the processor is able to produce
progressively more output as more input is received,  is tantamount to avoiding the need for XSLT processors to have random access to the entire
source document. This might be accomplished by: </p>
						<p>Identifying a core subset of XPath that does not require random access to the source tree, or</p>
						<p>Consider a "transform all subtrees" mode where the stylesheet
says, "Apply the transformation implied by this stylesheet to each node that
matches XXX, considered as the root of a separate tree, and copy all the
results of these mini-transformations as separate subtrees on to the final
result tree."</p>
					
					<p><i>Response</i></p>
						<p>This requirement has not been addressed.</p>
					
				
				
					<p><b><i>Requirement 20</i></b></p>
						<p>Could&nbsp;Support Reverse IDREF attributes</p>
						<p>Given a particular value of an ID, produce a list of all elements that have an IDREF or IDREFS attribute which refers to this ID.</p>
						<p>This functionality can be accomplished using the current &lt;xsl:key&gt; and key() mechanism.</p>
					
					<p><i>Response</i></p>
						<p>The <u>fn:idref</u> function defined in <a href="#FANDO">[Functions and Operators]</a> has been
						introduced in response to this requirement.</p>
					
				
				
					<p><b><i>Requirement 21</i></b></p>
						<p>Could&nbsp;Support for Case-Insensitive Comparisons</p>
						<p> XSLT 2.0 could expand its comparison functionality  to include support for case-insensitive string comparison.</p>
					
					<p><i>Response</i></p>
						<p>This is an XPath 2.0 requirement. XPath 2.0 includes
      functions to convert strings to uppercase or lowercase, it also includes functions to compare
      strings using a named collating sequence, which provides the option of using a collating
      sequence that treats uppercase and lowercase as equal.</p>
					
				
				
					<p><b><i>Requirement 22</i></b></p>
						<p>Could&nbsp;Support Lexigraphic String Comparisons</p>
						<p>We don't let users compare strings like $x &gt; 'a'. </p>
					
					<p><i>Response</i></p>
						<p>This requirement has been addressed in XPath 2.0.</p>
					
				
				
					<p><b><i>Requirement 23</i></b></p>
						<p>Could&nbsp;Allow Comparing  Nodes Based on Document Order</p>
						<p>Support the ability to test whether one node comes before another in document order.</p>
					
					<p><i>Response</i></p>
						<p>This requirement has been addressed in XPath 2.0, using the operators
						<code>&lt;&lt;</code> and <code>&gt;&gt;</code>.</p>
					
				
				
					<p><b><i>Requirement 24</i></b></p>
						<p>Could&nbsp;Improve Support for Unparsed Entities</p>
						<p>In XSLT 1.0 there is an asymmetry in support for unparsed entities. 
         They can be handled on input but not on output. In particular, there 
         is no way to do an identity transformation that preserves them. 
         At a minimum we need the ability to retrieve the Public ID of an unparsed entity.</p>
					
					<p><i>Response</i></p>
						<p>An appendix has been added (see <a href="#lexical-representation"><b>G Representation of Lexical XML Constructs</b></a>)
      defining a method of representing
      the lexical structure of an XML document within the data model. If this representation
      is used, additional information about unparsed entities is available from the source
      tree, and elements representing unparsed entities can be added to the result tree.
      A function to retrieve the public identifier of an unparsed
      entity has been added.
						</p>
					
				
				
					<p><b><i>Requirement 25</i></b></p>
						<p>Could&nbsp;Allow Processing a Node with the "Next Best Matching" Template</p>
						<p>In the construction of large stylesheets for complex documents, it is often 
         necessary to construct templates that implement special behavior for a particular 
         instance of an element, and then apply the normal styling for that element. 
         Currently this is not possible because <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> specifies 
         that for any given node only a single template will be selected and instantiated.</p>
						<p>Currently the processor determines a list of matching templates and then 
         discards all but the one with the highest priority. In order to support this 
         requirement, the processor would retain the list of matching templates sorted 
         in priority order. A new instruction, for example <code>xsl:next-match</code>, 
         in a template would simply trigger the next template in the list of matching 
         templates. This "next best match"  recursion naturally bottoms out at the
          builtin template which can be seen as the lowest priority matching template
           for every match pattern.
</p>
					
					<p><i>Response</i></p>
						<p>The working group has discussed this requirement but has not yet
      produced a proposal that is ready for publication. The generalization that allows
      template rules to apply to more than one mode may partially meet the requirement.</p>
					
				
				
					<p><b><i>Requirement 26</i></b></p>
						<p>Could&nbsp;Make Coercions Symmetric By Allowing Scalar to Nodeset Conversion</p>
						<p>Presently, no datatype can be coerced or cast to a node-set. By 
         allowing a string value to convert to a node-set, some user "gotchas" 
         could be avoided. </p>
					
					<p><i>Response</i></p>
						<p>The availability of sequences of strings or numbers probably
      meets most of the use-cases envisaged by this requirement.</p>
					
				
				
					<p><b><i>Requirement 27</i></b></p>
						<p>Must&nbsp;Simplify Constructing and Copying Typed Content</p>
						<p>It MUST be possible to construct XML Schema-typed elements and
          attributes. In addition, when copying an element or an attribute to
           the result, it should be possible to preserve the type during the process.</p>
					
					<p><i>Response</i></p>
						<p>Facilities to associate type annotations with constructed and copied
      element and attribute nodes are defined in this specification.</p>
					
				
				
					<p><b><i>Requirement 28</i></b></p>
						<p>Must&nbsp;Support Sorting Nodes Based on XML Schema Type</p>
						<p>XSLT 1.0 supports  sorting based on string-valued and number-valued expressions.
          XML Schema: Datatypes introduces new scalar types (for example, date)
           with well-known sort orders. It MUST be possible to sort based on these
            extended set of scalar data types. Since XML Schema: Datatypes does not
             define an ordering for complex types, this sorting support should only
              be considered for simple types.</p>
						<p>Should be consistent with whatever we define for the matrix of conversion and comparisons.</p>
					
					<p><i>Response</i></p>
						<p>Sorting based on any schema-defined primitive data type is included
      in this specification. </p>
					
				
				
					<p><b><i>Requirement 29</i></b></p>
						<p>Could&nbsp;Support Scientific Notation in Number Formatting</p>
						<p>Several users have requested the ability to have the existing
          format-number() function extended to format numbers using
           Scientific Notation.</p>
					
					<p><i>Response</i></p>
						<p>The specification for the <a href="#function-format-number"><b>format-number</b></a> has
      been rewritten to remove the dependency on the JDK 1.1 specification. The working group
      has decided not to enhance it further to introduce scientific notation. 
      Simple scientific formatting is now
      available through support for the schema-defined <code>xs:float</code> and <code>xs:double</code> data types;
      casting these values to a string produces a representation of the value in scientific notation.</p>
					
				
				
					<p><b><i>Requirement 30</i></b></p>
						<p>Could&nbsp;Provide Ability to Detect Whether "Rich" Schema Information
          is Available</p>
						<p>A stylesheet that requires XML Schema type-related functionality
          could be able to test whether a "rich" Post-Schema-Validated
           Infoset is available from the XML Schema processor, so that
            the stylesheet can provide fallback behavior or choose to exit
             with <code>xsl:message abort="yes"</code>.</p>
					
					<p><i>Response</i></p>
						<p>XPath 2.0 allows expressions to determine the type of element and
      attribute nodes, using information from the schema. The details of
      how these expressions behave when there is no schema are defined in the XPath
      specifications.</p>
					
				
				
					<p><b><i>Requirement 31</i></b></p>
						<p>Must&nbsp;Simplify Grouping</p>
						<p>Grouping is complicated in XSLT 1.0. It MUST be possible for users to group
          nodes in a document based on common string-values, common names, or
          common values for any other expression</p>
						<p>In addition XSLT must  allow grouping based on sequential position, e.g.
selecting groups of adjacent &lt;P&gt; elements. Ideally it should also make it
easier to do fixed-size grouping as well, e.g. groups of three adjacent nodes, for
laying out data in multiple columns.
For each group of nodes identified, it must be possible to instantiate a template for the group. Grouping must be "nestable" to multiple levels so that groups of distinct nodes can be identified, then from among the distinct groups selected, 
further sub-grouping of distinct node in the current group can be done. </p>
					
					<p><i>Response</i></p>
						<p>A new <a href="#element-for-each-group"><code>xsl:for-each-group</code></a> instruction is provided: see
       <a href="#grouping"><b>14 Grouping</b></a>. In addition, many of the new functions and operators provided
       in XPath 2.0 make these algorithms easier to write.</p>
					
				
			</div><div class="div1">
<h2><a name="issues-list" id="issues-list"></a>J Summary of Issues (Non-Normative)</h2><div class="div2">
<h3><a name="d5e20297" id="d5e20297"></a>J.1 Open Issues</h3><p><b><a name="issue-format-date-time">Issue 75</a>: format-date-time</b></p><p><i>Description: </i>There is a need for an additional function to format dates and times.</p><p><i>Suggested resolution: </i>A draft proposal is at
      <a href="http://lists.w3.org/Archives/Member/w3c-xsl-wg/2002Feb/0040.html">http://lists.w3.org/Archives/Member/w3c-xsl-wg/2002Feb/0040.html</a><b> (members only) </b>; see also subsequent
      comments.</p><p><b><a name="issue-result-tree-PSVI">Issue 83</a>: result-tree-PSVI</b></p><p><i>Description: </i>The rules for serialization of the result tree consider it only as an infoset; 
      the rules need to be enhanced to allow for (potential loss of) PSVI information on the tree.</p><p><i>Suggested resolution: </i>Need to discuss this (locus: creating type information in result tree).</p><p><b><a name="issue-type-matching-in-patterns">Issue 110</a>: type-matching-in-patterns</b></p><p><i>Description: </i>The current syntax for matching elements of a particular type is cumbersome,
      for example <code>match="*[. instance of element us-address of type address]"</code>.</p><p><i>Origin: </i>XSL WG meeting, Cannes, Feb 2002</p><p><i>Suggested resolution: </i>A proposal has been made to modify XPath 2.0 with the 
      <code>TypeTest</code> syntax. This might allow the above to be written as
      <code>match="type(address)"</code></p><p><b><a name="issue-global-variables-in-call-mode">Issue 113</a>: global-variables-in-call-mode</b></p><p><i>Description: </i>It's not obvious what the context should be for evaluating global variables when a
       transformation is initiated by calling a named template. The solution adopted for the moment
       is to say that there must be an initial context node; this will be supplied as an empty document
       node if no other initial context node is forthcoming.</p><p><i>Origin: </i>See <a href="http://lists.w3.org/Archives/Member/w3c-xsl-wg/2002Mar/0036.html">http://lists.w3.org/Archives/Member/w3c-xsl-wg/2002Mar/0036.html</a><b> (members only) </b></p><p><b><a name="issue-mixing-versions">Issue 122</a>: mixing-versions</b></p><p><i>Description: </i>Mixing version 1.0 and version 2.0 code in the same stylesheet has considerable
      complications. We probably need to be more restrictive than we are here. </p><p><i>Suggested resolution: </i>Needs further consideration.</p><p><b><a name="issue-copying-type-annotation">Issue 123</a>: copying-type-annotation</b></p><p><i>Description: </i>We need to specify how <a href="#element-copy"><code>xsl:copy</code></a> and <a href="#element-copy-of"><code>xsl:copy-of</code></a>
      handle type annotations on the nodes being copied. (For example, does an ID attribute in the 
      source tree become an ID attribute in the result tree?)</p><p><i>Resolution: </i>In the case of <a href="#element-copy-of"><code>xsl:copy-of</code></a>, we decided to offer users the
      choice of copying the type annotations from the source tree, or removing them.
      In the case of <a href="#element-copy"><code>xsl:copy</code></a> we decided that further study of the requirements
      was needed: the issue therefore remains open. An alternative is that <a href="#element-copy"><code>xsl:copy</code></a>
      should allow a <code>type-annotation</code> attribute to allow an explicit type 
      annotation to be added.</p><p><b><a name="issue-item-in-multiple-groups">Issue 127</a>: item-in-multiple-groups</b></p><p><i>Description: </i>If the <code>group-by</code> attribute evaluates to a sequence, we could interpret
    this as meaning that the item is to be included in several groups. This would be consistent with
    the treatment of <a href="#element-key"><code>xsl:key</code></a>. A new function <code>current-group-value()</code> might
    be needed to determine which group is being processed. See email from Jeni Tennison on public-qt-editors.
    </p><p><b><a name="issue-version-on-xsl-output">Issue 128</a>: version-on-xsl-output</b></p><p><i>Description: </i>Allowing version as a standard attribute on any XSL element, to indicate backwards
    or forwards compatibility resquirements, conflicts with its existing use on the <a href="#element-output"><code>xsl:output</code></a>
    element. See also issue 122.</p><p><i>Resolution: </i>The XSL Working Group has decided in principle to impose
    restrictions in the ability to mix different version attributes on different elements in a
    stylesheet. The form of these restrictions has yet to be decided.</p><p><b><a name="issue-creating-id-and-idref">Issue 131</a>: creating-id-and-idref</b></p><p><i>Description: </i>What are the implications of creating attributes of type ID and IDREF[S] in a result tree?
    What guarantees of uniqueness or referential integrity are provided? Is there a need to create temporary
    trees containing IDREF values that are not resolved within the temporary tree, but will be resolved
    when the nodes are copied to a final result tree? What does the <u>fn:id</u> function do?</p><p><b><a name="issue-nested-d-o-e">Issue 132</a>: nested-d-o-e</b></p><p><i>Description: </i>The <a href="#element-text"><code>xsl:text</code></a> element may now contain (or cause the evaluation of)
    nested <a href="#element-text"><code>xsl:text</code></a> and <a href="#element-value-of"><code>xsl:value-of</code></a> instructions. This makes it
    necessary to define the meaning of nested disable-output-escaping attributes. Should the
    default be that escaping is enabled, or should it be "no change from the previous setting"?</p><p><i>Suggested resolution: </i>One possible definition is that disable-output-escaping on the <a href="#element-text"><code>xsl:text</code></a>
    element should only affect text copied from text nodes that are children of the <a href="#element-text"><code>xsl:text</code></a>
    element in the stylesheet. Another possibility is a more dynamic definition, where the setting affects,
    for example, text output by called templates. A third option is to disallow <code>disable-output-escaping="yes"</code> for an
    <a href="#element-text"><code>xsl:text</code></a> element that contains anything other than a text node. For the time being,
    we have adopted the third option.</p><p><b><a name="issue-qname-for-key-etc">Issue 133</a>: qname-for-key-etc</b></p><p><i>Description: </i>Some XSLT functions such as <a href="#function-key"><b>key</b></a> take an argument whose value is 
    a string containing a lexical QName. Should we allow this argument to have 
    type <code>xs:QName</code>?</p><p><b><a name="issue-tree-to-string-conversion">Issue 135</a>: tree-to-string-conversion</b></p><p><i>Description: </i>The current XPath 2.0 rules for function calling, as well as addition and equality comparison,
    do not allow a document node to be converted to a string.</p><p><b><a name="issue-xslt-media-type">Issue 138</a>: xslt-media-type</b></p><p><i>Description: </i>We may need to define an XSLT media type after all: see the TAG decision at
    <a href="http://www.w3.org/2001/tag/2002/0129-mime">http://www.w3.org/2001/tag/2002/0129-mime</a></p><p><b><a name="issue-nested-xsl-text">Issue 139</a>: nested-xsl-text</b></p><p><i>Description: </i>At XSLT 1.0 the <a href="#element-text"><code>xsl:text</code></a> element only allowed PCDATA content.
    It has been generalized largely for consistency with <a href="#element-comment"><code>xsl:comment</code></a> and
    <a href="#element-attribute"><code>xsl:attribute</code></a>, etc. Is this generalization actually useful?</p><p><b><a name="issue-modified-copy">Issue 140</a>: modified-copy</b></p><p><i>Description: </i>Should we try to provide options for <a href="#element-copy-of"><code>xsl:copy-of</code></a> to produce
    a modified copy, for example, a copy omitting certain attributes? One possibility would be
    to define copy in terms of <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> with a special mode, so that
    template rules for that mode could override the standard action.</p><p><b><a name="issue-annotate-complex-types">Issue 141</a>: annotate-complex-types</b></p><p><i>Description: </i>Should the <code>type-annotation</code> attribute on <a href="#element-element"><code>xsl:element</code></a> (and
    <code>xsl:type-annotation</code> on literal result elements) be extended to support complex
    types?</p><p><b><a name="issue-copy-types-default">Issue 142</a>: copy-types-default</b></p><p><i>Description: </i>What should the default be for the <code>copy-type-annotation</code> attribute on
    the <a href="#element-copy-of"><code>xsl:copy-of</code></a> element?</p><p><b><a name="issue-validation-implies-well-formedness">Issue 143</a>: validation-implies-well-formedness</b></p><p><i>Description: </i>Should we require that when validation of a temporary tree is performed, the tree must
    contain a single top-level element node? It would be possible to define validation without
    requiring this: it could mean that each top-level element is independently validated.</p><p><b><a name="issue-named-template-entry-points">Issue 146</a>: named-template-entry-points</b></p><p><i>Description: </i>The current specification says that any named template can be used as an entry
    point to the transformation. This requires the compiled form of a stylesheet to retain the
    names and the body of all templates, including those that are never referenced. This is bad
    news when a stylesheet imports a large library of general-purpose templates.</p><p><b><a name="issue-default-xpath-keyword">Issue 147</a>: default-xpath-keyword</b></p><p><i>Description: </i>Would it be better to name "default-xpath-namespace" as
    "default-element-namespace"? Raised by Jeni Tennison, see
    <a href="http://lists.w3.org/Archives/Member/w3c-xsl-wg/2002Oct/0006.html">http://lists.w3.org/Archives/Member/w3c-xsl-wg/2002Oct/0006.html</a><b> (members only) </b></p><p><b><a name="issue-static-checks-on-call-template">Issue 150</a>: static-checks-on-call-template</b></p><p><i>Description: </i>We currently state that it is not an error if a parameter is supplied when calling
    a template, and the template does not declare such a parameter. This makes sense on apply-templates.
    On call-template, we could report this as a static error. This is related to the introduction of
    required="yes" on xsl:param, which can (in the case of call-template) lead to a static error.</p><p><b><a name="issue-normalized-output">Issue 151</a>: normalized-output</b></p><p><i>Description: </i>We have added an attribute <code>normalize-unicode="yes|no"</code> to allow
    users to request that the serialized output should be in unicode normalized form, but this
    needs to be reviewed against the W3C character model.</p><p><b><a name="issue-fn-namespace">Issue 155</a>: fn-namespace</b></p><p><i>Description: </i>We need to review how function namespaces are handled in XSLT. Should users
    be able to declare the default namespace for functions? Should user-defined functions be
    allowed to be in no namespace? What namespace should be used for functions such as
    <a href="#function-generate-id"><b>generate-id</b></a> defined in this specification?</p></div><div class="div2">
<h3><a name="d5e20301" id="d5e20301"></a>J.2 Decided Issues</h3><p>These are issues where the working group has made a decision, but the decision is not yet reflected
in this draft.</p><p><b><a name="issue-restrict-d-o-e">Issue 15</a>: restrict-d-o-e</b></p><p><i>Description: </i>It is proposed that we should restrict the use of disable-output-escaping 
      so it can only be used on a final result tree. This would avoid distorting the data model.</p><p><i>Resolution: </i>This issue was re-opened at the Chapel Hill meeting. Allowing disable-output-escaping
      on a temporary tree causes considerable complications for the implementation, and the rules
      for how it behaves have never been fully defined. The Working Group is considering replacing
      this feature with a facility to control how particular characters are represented in the final
      serialized output. This would allow special characters (perhaps Unicode private-use
      characters) to be written to the temporary tree to drive subsequent serialization.
      See also issue 124.</p><p><b><a name="issue-conformance-modules">Issue 86</a>: conformance-modules</b></p><p><i>Description: </i>Should we introduce multiple conformance levels or modules, recognizing that serialization 
      is a separate specification to which processors may or may not conform?</p><p><i>Resolution: </i>The working group has decided in principle to define multiple conformance modules.</p><p><b><a name="issue-NEL-char">Issue 95</a>: NEL-char</b></p><p><i>Description: </i>Should we make provision for XML 1.1 and its introduction of NEL as a whitespace character?</p><p><i>Origin: </i>See <a href="http://lists.w3.org/Archives/Public/xsl-editors/2002JanMar/0112.html">http://lists.w3.org/Archives/Public/xsl-editors/2002JanMar/0112.html</a> 
      </p><p><i>Resolution: </i>In the XML 1.1 Candidate Recommendation, NEL is not a whitespace character; the
      only change to its status is that it is regarded as an end-of-line character, which is normalized
      to x#0A by the XML parser. This change has no effect on XSLT. There are other changes in XML 1.1
      such as changes in the characters permitted in XML Names. These changes have no direct effect
      on XSLT, other than the fact that XSLT will refer to the XML 1.1 specification rather than the
      XML 1.0 Recommendation for the relevant rules.</p><p><b><a name="issue-assert-source-document-type">Issue 106</a>: assert-source-document-type</b></p><p><i>Description: </i>How should a stylesheet assert the schema type of the source documents that
      it is designed to process?</p><p><i>Resolution: </i>Decided to add no new capability. Instead we should add examples showing how 
      to do this using a top-level xsl:variable with a type attribute. Note: this would
      be more convenient if we could say "document of type X" in XPath.</p><p><b><a name="issue-conversion-with-d-o-e">Issue 124</a>: conversion-with-d-o-e</b></p><p><i>Description: </i>The rule prohibiting conversion of a text node to a string or number when the text node
      contains a "sticky d-o-e bit" needs revising, it was originally written for XSLT 1.0 before
      the operations available on temporary trees were generalized.</p><p><i>Suggested resolution: </i>The Working Group has decided in principle to disallow the use of
      disable-output-escaping when writing to a temporary tree. See also issue 15.</p><p><b><a name="issue-schema-conformance">Issue 125</a>: schema-conformance</b></p><p><i>Description: </i>We need to describe a conformance level that does not require schema
      support.</p><p><i>Resolution: </i>We decided that we should define a conformance level in which schema processing
      was not required. The details, however, have not been worked out.</p></div><div class="div2">
<h3><a name="d5e20307" id="d5e20307"></a>J.3 Closed Issues</h3><p>The only issues listed in this section are those whose status has changed since the date of the
				previous working draft, 16 August 2002.</p><p><b><a name="issue-shared-namespace-node-fixup">Issue 13</a>: shared-namespace-node-fixup</b></p><p><i>Description: </i>This section needs to be revised if namespace nodes are to be held at document level.</p><p><i>Resolution: </i>It has been decided that namespace nodes will not be held at document level.</p><p><b><a name="issue-must-namespaces-precede-attributes">Issue 30</a>: must-namespaces-precede-attributes</b></p><p><i>Description: </i>It appears that several implementations currently allow a namespace node to be added <em>after</em> adding attributes (using <a href="#element-copy"><code>xsl:copy</code></a> ). This seems convenient for the user, and the Working Group is inclined to allow it. To achieve this, we will need to define some conflict resolution if the namespace clashes with an existing attribute.</p><p><i>Resolution: </i>We decided to allow namespace nodes and attributes to be intermingled in the
      sequence, though they must still appear before any other kind of node.</p><p><b><a name="issue-xpath-variable-shadowing">Issue 38</a>: xpath-variable-shadowing</b></p><p><i>Description: </i>Can variables declared within an XPath 2.0 expression shadow variables declared 
      at XSLT level? And should variables declared within an XPath expression be allowed to shadow
      each other? If so, should we change the XSLT rules to be the same?</p><p><i>Resolution: </i>2002-09-12: We decided to bring the XSLT rules into line with the XPath rules. That
      is, one local variable will be allowed to shadow another. However, we will add a note
      that this is discouraged and implementations are allowed to issue a warning.</p><p><b><a name="issue-sequences-in-XSLT">Issue 99</a>: sequences-in-XSLT</b></p><p><i>Description: </i>Should we consider extending XSLT to allow construction of arbitrary sequences?</p><p><i>Origin: </i>See Jeni Tennison's proposal at <a href="http://lists.w3.org/Archives/Public/xsl-editors/2002JanMar/0050.html">http://lists.w3.org/Archives/Public/xsl-editors/2002JanMar/0050.html</a> .</p><p><i>Suggested resolution: </i>After considerable discussion, the proposal was rejected on 2002-09-26, with the rationale
      given at <a href="http://lists.w3.org/Archives/Public/public-qt-comments/2002Sep/0042.html">http://lists.w3.org/Archives/Public/public-qt-comments/2002Sep/0042.html</a></p><p><b><a name="issue-sequence-valued-sort-key">Issue 105</a>: sequence-valued-sort-key</b></p><p><i>Description: </i>What happens if the value of a sort key is a sequence?</p><p><i>Origin: </i>See <a href="http://lists.w3.org/Archives/Public/xsl-editors/2002JanMar/0067.html">http://lists.w3.org/Archives/Public/xsl-editors/2002JanMar/0067.html</a> .</p><p><i>Suggested resolution: </i>In XQuery it is an error. An alternative would be to use "lexicographic" sorting, that is, compare the first items in the two sequences, then the second, and so on until an item is found that differs, or one of the sequences is exhausted.</p><p><i>Resolution: </i>The value of the sort key must be either a singleton or an empty sequence.</p><p><b><a name="issue-exclude-namespaces-from-copy">Issue 120</a>: exclude-namespaces-from-copy</b></p><p><i>Description: </i>It would be useful to allow xsl:copy and xsl:copy-of to exclude namespace nodes, for
      example when copying the body of a SOAP message there is no need to copy the SOAP envelope namespace.
      This could be done by overloading the meaning of [xsl:]exclude-result-prefixes</p><p><i>Resolution: </i>We decided not to overload exclude-result-prefixes, but rather to define
      a new attribute [xsl:]exclude-prefixes that covered both xsl:copy-of and literal result
      elements.
      2002-09-12: After applying the above change and seeing the complexities it caused, we
      changed the decision. The attribute [xsl:]exclude-prefixes is dropped, and replaced with
      a new attribute <code>copy-namespaces={yes|no}</code> on <a href="#element-copy"><code>xsl:copy</code></a> and
       <a href="#element-copy-of"><code>xsl:copy-of</code></a>.</p><p><b><a name="issue-xsl-value-of-atomization">Issue 121</a>: xsl-value-of-atomization</b></p><p><i>Description: </i>How should <a href="#element-value-of"><code>xsl:value-of</code></a> handle sequence-valued nodes?
      Should separators be inserted between individual items?</p><p><i>Resolution: </i>We decided to use the atomization process defined in XPath. This means that the
      sequence of nodes and/or atomic values is first reduced to a sequence of atomic values, then
      the atomic values are converted to strings and separators are added.</p><p><b><a name="issue-duplicate-ns-alias-error-type">Issue 126</a>: duplicate-ns-alias-error-type</b></p><p><i>Description: </i>Why is it a dynamic error, rather than a static error, to have duplicate inconsistent
    namespace-alias declarations? (This is unchanged from XSLT 1.0, but seems wrong.)</p><p><i>Resolution: </i>Changed this to a static error.</p><p><b><a name="issue-fallback-on-new-elements">Issue 129</a>: fallback-on-new-elements</b></p><p><i>Description: </i>To allow an XSLT 2.0 stylesheet to be used with an XSLT 1.0 processor, all new
    instructions should allow an <a href="#element-fallback"><code>xsl:fallback</code></a> child element.</p><p><i>Resolution: </i>The only change needed was to allow <a href="#element-fallback"><code>xsl:fallback</code></a> as a child
    of <a href="#element-analyze-string"><code>xsl:analyze-string</code></a>.</p><p><b><a name="issue-xsi-schema-location">Issue 134</a>: xsi-schema-location</b></p><p><i>Description: </i>If an <code>xsi:schemaLocation</code> attribute is present in a constructed
    tree that is subjected to validation, does the attribute have any effect?</p><p><i>Resolution: </i>The semantics of validation are described in terms of a process that nominally
    converts the data model to an InfoSet, and then applies validation to the InfoSet according
    to the rules described in XML Schema Part 1. This process does indeed take account of
    <code>xsi:schemaLocation</code>. Note that it is possible that this process will result in the
    validated tree being annotated using type names that are not present in the static context.
    This leads to the same situation as when the <u>fn:document</u> function loads
    a document that is validated using schema definitions that have not been statically imported.
    The detailed rules covering this situation are still being decided.</p><p><b><a name="issue-default-param-is-string">Issue 136</a>: default-param-is-string</b></p><p><i>Description: </i>The default value of a parameter defined as
    <code>&lt;xsl:param name="x" type="xs:integer"/&gt;</code> is an empty string; this is not a valid
    <code>xs:integer</code>, so an error will be reported.</p><p><i>Resolution: </i>We decided to add an attribute <code>required="yes"|"no"</code> to define whether
    a parmeter is optional, and we decided that a parameter declared as shown should only be an error
    if the parameter is omitted in an actual call.</p><p><b><a name="issue-at-least-one-param">Issue 137</a>: at-least-one-param</b></p><p><i>Description: </i>Since the context is no longer passed to a stylesheet function, it
    doesn't make sense for a function to have no arguments. The content model should be
    changed to require at least one <a href="#element-param"><code>xsl:param</code></a> element.</p><p><i>Resolution: </i>We decided to make no change. There are some circumstances in which functions
    with no arguments can be useful, for example a function that returns the current date and
    time in a particular format.</p><p><b><a name="issue-type-attribute-names">Issue 144</a>: type-attribute-names</b></p><p><i>Description: </i>It is inelegant to have two attributes named <code>type</code> and <code>type-information</code>
    on the same element.</p><p><i>Resolution: </i>In line with changes to the XPath/XQuery syntax for variables, the WG decided to
    rename the "type" attribute "as". Outstanding question: should we make the same change for
    xsl:key, xsl:sort, and xsl:for-each-group?</p><p><b><a name="issue-null-in-keys">Issue 145</a>: null-in-keys</b></p><p><i>Description: </i>The definition of keys (and grouping keys) needs to be clear about what happens
    when the value of a key is the empty sequence or NaN: are such keys considered equal?</p><p><i>Resolution: </i>The issue is resolved as follows. For sort keys, () and NaN are both allowed, and their
    relative order is now defined; NaN is considered equal to NaN;
    multi-item sequences are not allowed. For <a href="#element-key"><code>xsl:key</code></a>,
    sequence-valued keys have existential semantics; NaN is considered equal to NaN. For grouping,
    the grouping key must be a singleton (until issue 127 is resolved); NaN is considered equal to NaN.                             
    </p><p><b><a name="issue-expr-sequence">Issue 148</a>: expr-sequence</b></p><p><i>Description: </i>Should we allow elements such as xsl:value-of to take an ExprSequence rather
    than just an Expr? This would allow <code>&lt;xsl:value-of select="1,2,3"/&gt;</code>
    Raised by Max Froumentin, see: <a href="http://lists.w3.org/Archives/Member/w3c-xsl-wg/2002Sep/0132.html">http://lists.w3.org/Archives/Member/w3c-xsl-wg/2002Sep/0132.html</a><b> (members only) </b></p><p><i>Resolution: </i>We decided that all references to "XPath expressions" in XSLT should allow
    an ExprSequence.</p><p><b><a name="issue-element-qname-error">Issue 149</a>: element-qname-error</b></p><p><i>Description: </i>What should happen if the prefix of the QName supplied as the value of the
    <code>name</code> attribute of <a href="#element-element"><code>xsl:element</code></a> or <a href="#element-attribute"><code>xsl:attribute</code></a>
    does not reference an in-scope namespace, and the instruction has no <code>namespace</code>
    attribute? The specification doesn't say. This omission is present also in XSLT 1.0.</p><p><i>Suggested resolution: </i>We decided that this should be a dynamic error and that the recovery action
    should be to ignore the prefix.</p><p><b><a name="issue-format-number-rounding">Issue 152</a>: format-number-rounding</b></p><p><i>Description: </i>What are the rounding rules for format-number, e.g. if the number 12.345 is formatted
    using the pattern 00.00? XSLT 1.0 apparently uses half-even rounding (0.125 becomes 0.12, 
    while 0.875 becomes 0.88)</p><p><i>Resolution: </i>We decided to specify half-even rounding.</p><p><b><a name="issue-annotation">Issue 153</a>: annotation</b></p><p><i>Description: </i>Should we add an element to allow structured documentation of a stylesheet,
    e.g. <code>xsl:annotation</code>. It's not in the published requirements, but has been
    requested in public comments.</p><p><i>Suggested resolution: </i>From David Rosenborg on xml-dev: Another idea for future XSLT versions:
    have an annotation-element-prefixes attribute on the xsl:stylesheet element and an
   xsl:annotation-element-prefixes attribute that can appear on literal result elements. 
   The effect should be analogous to extension-element-prefixes but in this case the XSLT 
   processor should just ignore the elements.</p><p><i>Resolution: </i>We decided not to offer this facility. It was felt that the mechanisms used
   by XSLT 1.0 users were adequate to meet the requirement, and that it was undesirable to
   add features at this stage that were not included in the XSLT 2.0 requirements list.
   </p><p><b><a name="issue-derived-key-type">Issue 154</a>: derived-key-type</b></p><p><i>Description: </i>There is an inconsistency: for keys and grouping keys, we allow the data type
    to be any atomic type. For sort keys, we require it to be a primitive type. There appears
    to be no good reason for this restriction. There is also a reason to remove the restriction:
    the two data types dayTimeDuration and yearMonthDuration, which were introduced to enable
    sorting of durations, are not primitive.</p><p><i>Resolution: </i>We decided to allow derived types in all three cases.</p></div></div><div class="div1">
<h2><a name="changes" id="changes"></a>K Changes from XSLT 1.0 (Non-Normative)</h2><div class="div2">
<h3><a name="incompatibilities" id="incompatibilities"></a>K.1 Incompatible Changes</h3><p>This section lists all known cases where a stylesheet that was valid (produced no errors)
under XSLT 1.0, and whose behavior was fully specified by XSLT 1.0,
will produce different results under XSLT 2.0.</p><p>Most of the discussion is concerned with compatibility
in the absence of a schema: that is, it is assumed that the source document
being transformed has no schema when processed using XSLT 1.0, and that no
schema is added when moving to XSLT 2.0. Some additional factors that come into
play when a schema is added are noted at the end of the section.</p><div class="div3">
<h4><a name="d5e20323" id="d5e20323"></a>K.1.1 XSLT 2.0 Backwards Compatibility</h4><p>If the source documents supplied as input to a transformation contain
no type information generated from a schema (or by generating a PSVI from information
in the DTD), then the known areas of incompatibility are as follows:</p><ul><li><p>A stylesheet that specifies a version number other than 1.0 was defined
in XSLT 1.0 to execute in forwards-compatible mode; if such a stylesheet used features
that are not defined in XSLT 2.0 then errors may be reported by an XSLT 2.0 processor
that would not be reported by an XSLT 1.0 processor.</p></li><li><p>If the <a href="#element-number"><code>xsl:number</code></a> element was called with a <code>value</code>
attribute whose value was a node-set containing more than one node, then an XSLT 1.0
processor would output the numeric value of the first node in the node-set. An
XSLT 2.0 processor will output the numeric value of every node in the equivalent 
node sequence. If the node-set was empty, an XSLT 1.0 processor would output "NaN";
an XSLT 2.0 processor will output nothing.</p></li><li><p>At XSLT 2.0 it is an error to specify the <code>mode</code>
or <code>priority</code> attribute on an <a href="#element-template"><code>xsl:template</code></a> element having no
<code>match</code> attribute. At XSLT 1.0 the attributes were simply ignored in this
situation.</p></li><li><p>At XSLT 2.0, if the value of an embedded expression in an attribute
value template is a sequence, all the values in the sequence are output, using a single space as
a separator. At XSLT 1.0, if the value was a node-set, all nodes other than the first were ignored.
(To retain the XSLT 1.0 behavior, add the predicate <code>[1]</code> after the expression, adding
parentheses if necessary.)</p></li><li><p>At XSLT 1.0 the <a href="#function-system-property"><b>system-property</b></a> function, when called with a first
argument of <code>"xsl:version"</code>, returned 1.0 as a number. At XSLT 2.0 it returns "2.0"
as a string.</p></li><li><p>When the <code>data-type</code> attribute of <a href="#element-sort"><code>xsl:sort</code></a>
has the value <code>number</code>, an XSLT 1.0 processor would evaluate the sort key as a string,
and convert the result to a number. An XSLT 2.0 processor evaluates the sort key as a number
directly. This only affects the outcome in cases where conversion of a number to a string and then
back to a number does not produce the original number, as is the case for example with the number
<code>Positive Infinity</code>.</p></li><li><p>The specification of the <a href="#function-format-number"><b>format-number</b></a>
function has been rewritten to remove the normative dependency on the Java JDK 1.1
specification. The JDK 1.1 specification left aspects of the behavior undefined; it is
therefore possible that some cases will give different results. The ability to include
literal text in the format picture (enclosed in single quotes) has been removed; any
stylesheet that uses this feature will need to be modified, for example to display the
literal text using the <u>fn:concat</u> function instead.</p></li><li><p>XSLT 1.0 allowed the URI returned by the <a href="#function-unparsed-entity-uri"><b>unparsed-entity-uri</b></a>
function to be derived from some combination of the system identifier and the public identifier
in the source XML. XSLT 2.0 returns the system identifier as defined in the InfoSet, resolved using
the base URI of the source document. A new function is provided to return the public identifier.</p></li><li><p>If no output method is explicitly requested, and the
first element node output appears to be an XHTML document element, the output method
now defaults to XHTML; previously the XML output method would have been used.</p></li><li><p>At XSLT 1.0, if a built-in template rule was invoked with
parameters, the parameters were not passed on to any templates invoked by the built-in rule.
At XSLT 2.0, these parameters are passed through the built-in template rule unchanged.</p></li><li><p>At XSLT 1.0 there were no restrictions on the namespaces that could be
used for the names of user-defined stylesheet objects such as keys, variables, and named templates.
In XSLT 2.0, certain namespaces (for example the XSLT namespace and the XML Schema namespace)
are reserved.</p></li></ul></div><div class="div3">
<h4><a name="d5e20410" id="d5e20410"></a>K.1.2 XPath 2.0 Backwards Compatibility</h4><p>Information about incompatibilities between XPath 2.0 and XPath 1.0
is included in <a href="#XPATH20">[XPath 2.0]</a>
					</p><p>Incompatibilities in the specification of individual functions in the core
function library are listed in <a href="#FANDO">[Functions and Operators]</a>
					</p></div><div class="div3">
<h4><a name="d5e20421" id="d5e20421"></a>K.1.3 Compatibility in the Presence of a Schema</h4><p>An XSLT 1.0 processor ignored all information about data types that might be obtained from
a schema or DTD associated with a source document. An XSLT 2.0 processor will take account of
such information. This may lead to a number of differences in behavior. An implementation
may provide facilities to handle the document as if the schema information were not available.
This section attempts
only to give some examples of the kind of differences that might be expected when schema
information is made available:</p><ul><li><p>Operations such as sorting will be sensitive to the data type of the items
being sorted. For example, if the data type of the sort key is defined in the schema
as a date, then in the absence of a <code>data-type</code> attribute on the 
<a href="#element-sort"><code>xsl:sort</code></a> element, the sequence will be sorted in date order. With XSLT 1.0,
the dates would be compared and sorted as strings.</p></li></ul></div></div><div class="div2">
<h3><a name="d5e20436" id="d5e20436"></a>K.2 Changes since XSLT 1.0</h3><p>This section summarizes the changes that have been made in this draft. These are 
arranged in three groups. Firstly, the changes that pervade the entire text. Secondly,
the major new features introduced. And thirdly, a catalog of minor technical changes.</p><p>Changes since the August 2002 working draft are listed separately: see
<a href="#changes-in-this-draft"><b>K.2.4 Changes since the August 2002 draft</b></a>.</p><p>In addition to these changes, 
reported <a href="http://www.w3.org/1999/11/REC-xslt-19991116-errata/">errors</a>
in XSLT 1.0 have been fixed.</p><div class="div3">
<h4><a name="d5e20450" id="d5e20450"></a>K.2.1 Pervasive changes</h4><ul><li><p>There has been significant re-arrangement of the text.
More terminology definitions have been hyperlinked, and a glossary
(see <a href="#glossary"><b>B Glossary</b></a>) has been added.</p></li><li><p>The specifications of some features (notably keys, <a href="#element-number"><code>xsl:number</code></a>,
the <a href="#function-format-number"><b>format-number</b></a> function, and the <a href="#element-import"><code>xsl:import</code></a>
mechanism) have been rewritten to make them clearer and more precise.</p></li><li><p>A number of changes have been made to support the XPath 2.0 data model,
notably the support for sequences as a replacement for the node-sets of XPath 1.0. This
has affected the specification of elements such as <a href="#element-for-each"><code>xsl:for-each</code></a>, 
<a href="#element-value-of"><code>xsl:value-of</code></a>, and <a href="#element-sort"><code>xsl:sort</code></a>.</p></li><li><p>The processing model is described differently: instead of instructions "writing
to the result tree", they now return nodes or node-sequences. This change is largely one
of terminology: it paves the way to a more formal definition of the language,
sharing a common semantic model with the draft XML Query specifications,
and mapping directly to the constructor functions defined in the data model.</p></li><li><p>The description of the evaluation context has been changed. The concept of
current node and current node list have been replaced by the XPath concepts of context item,
context position, and context size.</p></li><li><p>With the introduction of support for XML Schema within XPath 2.0, XSLT has moved
in the direction of supporting stronger data typing, while retaining backwards compatibility.
In particular, the types of variables and parameters can now be specified explicitly.
Schema validation can be invoked for temporary trees and result trees.</p></li><li><p>The description of error handling has been improved (see <a href="#errors"><b>2.9 Error Handling</b></a>).
This formalizes the difference between static and dynamic errors, and tightens the
rules that define which errors must be reported under which conditions.</p></li><li><p>The terms <a title="implementation-defined" href="#dt-implementation-defined">implementation-defined</a> and
<a title="implementation-dependent" href="#dt-implementation-dependent">implementation-dependent</a> are now defined and used
consistently, and a checklist of implementation-defined features is provided
 (see <a href="#implementation-defined-features"><b>E Checklist of Implementation-Defined Features</b></a>).</p></li></ul></div><div class="div3">
<h4><a name="d5e20508" id="d5e20508"></a>K.2.2 Major Features</h4><ul><li><p>XSLT 2.0 is designed to work with XPath 2.0 rather than XPath 1.0. This brings an enhanced
data model with a type system based on sequences of nodes or atomic values, support for all the
built-in types defined in XML Schema, and a wide range of new functions and operators.</p></li><li><p>The result tree fragment data-type is 
eliminated. <a title="variable-binding element" href="#dt-variable-binding-element">A variable-binding elements</a> with content 
now constructs a <a title="" href="#dt-temporary-tree">temporary tree</a>, and the value of the variable
is the root node of this tree (see <a href="#variable-values"><b>9.3 Values of Variables and Parameters</b></a>). This feature eliminates the need
for the <code>xx:node-set</code> extension function provided by many XSLT 1.0 implementations.</p></li><li><p>Facilities are introduced for grouping of nodes (the <a href="#element-for-each-group"><code>xsl:for-each-group</code></a>
instruction, and the <code>current-group()</code> function). 
See <a href="#grouping"><b>14 Grouping</b></a>
							</p></li><li><p>It is now possible to create user-defined functions within
the stylesheet, that can be called from XPath expressions. See <a href="#stylesheet-functions"><b>10.3 Stylesheet Functions</b></a>.
</p></li><li><p>A transformation is allowed to produce multiple result trees. 
See <a href="#secondary-result-trees"><b>19.1 
					Secondary Result Trees</b></a>.
</p></li><li><p>A new instruction <a href="#element-analyze-string"><code>xsl:analyze-string</code></a> is provided to process text
by matching it against a regular expression.</p></li><li><p>It is possible to declare the types of variables and parameters. The types
may either be built-in types, or user-defined types imported from a schema using a new
<a href="#element-import-schema"><code>xsl:import-schema</code></a> declaration.</p></li><li><p>A stylesheet is able to attach type annotations to elements and attributes in a result
tree, and also in temporary trees, and to make use of any type annotations that exist in a source tree.
Result trees and temporary trees can be validated against a schema.</p></li><li><p>A transformation may now be invoked by calling a named template, supplying input by means of the
new <u>fn:input</u> function defined in <a href="#FANDO">[Functions and Operators]</a>. This creates the
potential for a transformation to process large collections of input documents.</p></li><li><p>Comparisons between values used for grouping, for sorting, and for keys can be performed
using the rules for any supported data type, including the ability to select named collations for
performing string comparison. These complement the new facilities in XPath 2.0, which are also
invoked automatically when matching template rules.</p></li><li><p>The <a href="#element-for-each"><code>xsl:for-each</code></a> instruction is able to process any sequence, not only
a sequence of nodes.</p></li><li><p>An XHTML output method has been added. See <a href="#xhtml-output"><b>20.2 XHTML Output Method</b></a>.
</p></li><li><p>A new <a href="#element-sort-key"><code>xsl:sort-key</code></a> declaration is available to define named
 sort specifications, supporting 
an additional <a href="#function-sort"><b>sort</b></a> to allow a sequence to be sorted from within an XPath
 expression. A <code>collation</code> attribute has been added to
the <a href="#element-sort"><code>xsl:sort</code></a> element to allow sorting using a user-defined collation.</p></li></ul></div><div class="div3">
<h4><a name="d5e20602" id="d5e20602"></a>K.2.3 Minor Changes</h4><ul><li><p>Instead of the allowing the output method complete freedom to
add namespace nodes, a process of namespace fixup is applied to the
result tree before it is output; this same namespace fixup process is
also applied to documents constructed variable-binding elements with
content (see <a href="#namespace-fixup"><b>4.4 Namespace Fixup</b></a>).</p></li><li><p>Support for XML Base has been added.</p></li><li><p>An <a href="#element-apply-imports"><code>xsl:apply-imports</code></a> element is allowed to have
parameters (see <a href="#apply-imports"><b>6.6 Overriding Template Rules</b></a> and <a href="#with-param"><b>10.1.1 Passing Parameters to Templates</b></a>).</p></li><li><p>
								<a title="extension function" href="#dt-extension-function">Extension functions</a> are
 allowed to return external objects, which do not have any of the builtin
XPath types.</p></li><li><p>The specification for patterns (<a href="#patterns"><b>5.3 Patterns</b></a>) has been revised to align it with the
new XPath grammar. The formal semantics of patterns has been simplified: this became possible because
of the extra compositionality now available in the expression grammar. The syntax and semantics
of patterns remains essentially unchanged, except that XPath 2.0 expressions can be used within
predicates.</p></li><li><p>A backwards-compatible processing mode is introduced. See <a href="#backwards"><b>3.6 Backwards-Compatible Processing</b></a>
							</p></li><li><p>The <a href="#function-system-property"><b>system-property</b></a> function now always
returns a string. Two new system properties <code>product-name</code> and
<code>product-version</code> have been defined. See <a href="#system-property"><b>16.5.5 system-property</b></a>.</p></li><li><p>With <code>&lt;xsl:message terminate="yes"&gt;</code>, the processor now
<em>must</em> terminate processing. Previously the word <em>should</em> was
used. See <a href="#message"><b>17 Messages</b></a>.</p></li><li><p>It is now specified that the <code>omit-xml-declaration</code> attribute is ignored
if <code>standalone</code> or <code>encoding</code> needs to be included in the
XML declaration. See <a href="#xml-output"><b>20.1 XML Output Method</b></a>.</p></li><li><p>A new <code>include-content-type</code> attribute has been added to <a href="#element-output"><code>xsl:output</code></a>
to suppress the generation of a <code>meta</code> element in HTML and XHTML output.</p></li><li><p>A new instruction <a href="#element-namespace"><code>xsl:namespace</code></a> is available, for creating
namespace nodes: see <a href="#creating-namespace-nodes"><b>11.6 Creating Namespace Nodes</b></a>.</p></li><li><p>A new <code>[xsl:]default-xpath-namespace</code> attribute is available to define
the default namespace for unqualified names in an XPath expression or XSLT pattern.</p></li><li><p>The attributes <code>[xsl:]version</code>, <code>[xsl:]exclude-result-prefixes</code>,
and <code>[xsl:]extension-element-prefixes</code>, as well as the new
 <code>[xsl:]default-xpath-namespace</code>, can be used on any XSLT element, not only on
<a href="#element-stylesheet"><code>xsl:stylesheet</code></a> and on literal result elements as before. In particular, they
can now be used on the <a href="#element-template"><code>xsl:template</code></a> element.</p></li><li><p>The <a href="#element-text"><code>xsl:text</code></a> instruction has been brought into line with
 <a href="#element-attribute"><code>xsl:attribute</code></a>, <a href="#element-comment"><code>xsl:comment</code></a>, and the like.
 It is now possible to use instructions such as <a href="#element-value-of"><code>xsl:value-of</code></a>
and <a href="#element-if"><code>xsl:if</code></a> within an <a href="#element-text"><code>xsl:text</code></a> element.</p></li><li><p>A new <a href="#function-unparsed-text"><b>unparsed-text</b></a> function is introduced. It allows the contents
of an external text file to be read as a string.</p></li><li><p>Restrictions on the use of variables within patterns and key definitions have been removed; in their place
a more general statement of the restrictions preventing circularity has been formulated. The <a href="#function-current"><b>current</b></a>
function may also now be used within patterns.</p></li><li><p>The built-in templates for element and document nodes now pass any supplied parameter values on
 to the templates that they call.</p></li><li><p>The description of the algorithm for use in the <a href="#function-format-number"><b>format-number</b></a> function has been
 simplified, without changing its effect.</p></li><li><p>The definition of the <u>fn:document</u> function has been transferred to <a href="#FANDO">[Functions and Operators]</a>.</p></li></ul></div><div class="div3">
<h4><a name="changes-in-this-draft" id="changes-in-this-draft"></a>K.2.4 Changes since the August 2002 draft</h4><ul><li><p>The concept of <em>principal result document</em> has been removed; all result trees
now have equal status. If an <a href="#element-result-document"><code>xsl:result-document</code></a> instruction is executed before the
first instruction that outputs a node, then no implicit (or "principal") result document is created
by the transformation.</p></li><li><p>The <code>[xsl:]exclude-prefixes</code> attribute, which allowed the copying
							of namespace nodes by <a href="#element-copy"><code>xsl:copy</code></a> and <a href="#element-copy-of"><code>xsl:copy-of</code></a> to
							be suppressed, has been replaced by an attribute <code>copy-namespaces</code> that
							appears on these two instructions only, and that causes either all namespaces or no
							namespaces to be copied. The option <code>[xsl:]exclude-result-prefixes="#all"</code>,
							which was introduced in an earlier draft, has however been retained.</p></li><li><p>It is now a static error for the stylesheet to contain two conflicting 
						    <a href="#element-namespace-alias"><code>xsl:namespace-alias</code></a> declarations with the same import precedence.</p></li><li><p>A new attribute <code>unicode-normalization</code> has been added
						 to <a href="#element-output"><code>xsl:output</code></a>.</p></li><li><p>The <code>type</code> attribute of several elements has been renamed <code>as</code>.</p></li><li><p>A new attribute <code>required</code> has been added to <a href="#element-param"><code>xsl:param</code></a>,
						to indicate whether a parameter is mandatory. The rules have been clarified concerning the default value in the
						case where the <a href="#element-param"><code>xsl:param</code></a> element is empty and has no <code>select</code>
						attribute. To implement this change in a readable way, the section <a href="#variables-and-parameters"><b>9 Variables and Parameters</b></a>
						has been reorganized.</p></li><li><p>Changes have been made to XPath 2.0 concerning the way that arguments to function calls
						are converted to the required type. These changes have had an effect on XSLT, since various operations
						(for example, the conversion of the supplied value to the required type of a variable) were defined
						by reference to the XPath rules. The XPath concepts of <em>effective boolean value</em> and
						<em>atomization</em> are now used where appropriate.</p></li><li><p>Changes have been made to the rules for namespace fixup (see <a href="#namespace-fixup"><b>4.4 Namespace Fixup</b></a>)
						now that the treatment of namespace nodes in the data model has been firmed up.</p></li><li><p>The <a href="#element-analyze-string"><code>xsl:analyze-string</code></a> element can now have an <a href="#element-fallback"><code>xsl:fallback</code></a>
						child. This will be ignored by an XSLT 2.0 processor, but allows fallback behavior to be defined
						when the stylesheet is processed by an XSLT 1.0 processor in forwards-compatible mode.</p></li><li><p>The notation used for function signatures has been aligned with the notation used in
                        <a href="#FANDO">[Functions and Operators]</a>.</p></li><li><p>A number of issues have been closed: see <a href="#issues-list"><b>J Summary of Issues</b></a> for details.</p></li></ul></div></div></div></div></body></html>