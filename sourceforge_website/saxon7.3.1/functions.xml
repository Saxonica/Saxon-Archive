<!DOCTYPE functions [
  <!ATTLIST xsl:stylesheet id ID #REQUIRED>
]>
<?xml-stylesheet href="#ss" type="text/xsl"?>

<!-- status of function implementations in Saxon 7.x. Note: XSLT functions are not currently listed. -->
<conformance>
<functions>
<function>
    <signature>op:add-dayTimeDuration-to-date( date $srcval1, dayTimeDuration $srcval2) => dateTime</signature>
    <status>n</status>
</function>
<function>    
    <signature>op:add-dayTimeDuration-to-dateTime( dateTime $srcval1, dayTimeDuration $srcval2) => dateTime</signature>
    <status>n</status>
</function>
<function>
    <signature>op:add-dayTimeDuration-to-time( time $srcval1, dayTimeDuration $srcval2) => time</signature>
    <status>n</status>
</function>
<function>
    <signature>op:add-dayTimeDurations( dayTimeDuration $srcval1, dayTimeDuration $srcval2) => dayTimeDuration</signature>
    <status>n</status>
</function>
<function>
    <signature>fn:add-timezone-to-date( date $srcval) => date</signature>
    <status>n</status>
    <description>Sets the timezone information on a date value to the system timezone</description>
</function>
<function>
    <signature>fn:add-timezone-to-date( date $srcval, dayTimeDuration $timezone) => date</signature>
    <status>n</status>
    <description>Sets the timezone information on a date value to $timezone</description>
</function>
<function>
    <signature>fn:add-timezone-to-dateTime( dateTime $srcval) => dateTime</signature>
    <status>n</status>
    <description>Sets the timezone information on a dateTime value to the system timezone</description>    
</function>
<function>
    <signature>fn:add-timezone-to-dateTime( dateTime $srcval, dayTimeDuration $timezone) => dateTime</signature>
    <status>n</status>
    <description>Sets the timezone information on a dateTime value to $timezone</description>    
</function>
<function>
    <signature>fn:add-timezone-to-time( time $srcval) => time</signature>
    <status>n</status>
    <description>Sets the timezone information on a time value to the system timezone</description>    
</function>
<function>
    <signature>fn:add-timezone-to-time( time $srcval, dayTimeDuration $timezone) => time</signature>
    <status>n</status>
    <description>Sets the timezone information on a time value to $timezone</description>
</function>
<function>
    <signature>op:add-yearMonthDuration-to-date( date $srcval1, yearMonthDuration $srcval2) => date</signature>
    <status>n</status>
</function>
<function>
    <signature>op:add-yearMonthDuration-to-dateTime( dateTime $srcval1, yearMonthDuration $srcval2) => dateTime</signature>
    <status>n</status>
</function>
<function>
    <signature>op:add-yearMonthDurations( yearMonthDuration $srcval1, yearMonthDuration $srcval2) => yearMonthDuration</signature>
    <status>n</status>
</function>
<function>
    <signature>op:anyURI-equal(anyURI $srcval1, anyURI $srcval2) => boolean</signature>
    <status>y</status>
</function>
<function>
    <signature>fn:avg(item* $srcval) => double?</signature>
    <status>y</status>
    <description>Returns the average of a set of numbers</description>
</function>
<function>
    <signature>fn:base-uri(node $srcval) => anyURI?,returns String</signature>
    <status>y</status>
    <description>Returns the base URI of a given node</description>
</function>
<function>
    <signature>op:base64-binary-equal( base64Binary $value1, base64Binary $value2) => boolean</signature>
    <status>n</status>
</function>
<function>
    <signature>fn:boolean(item* $srcval) => boolean</signature>
    <status>y</status>
    <description>Obtains the effective boolean value of any expression</description>
</function>
<function>
    <signature>op:boolean-equal(boolean $value1, boolean $value2) => boolean</signature>
    <status>y</status>
</function>
<function>
    <signature>op:boolean-greater-than( boolean $srcval1, boolean $srcval2) => boolean</signature>
    <status>y</status>
</function>
<function>
    <signature>op:boolean-less-than( boolean $srcval1, boolean $srcval2) => boolean</signature>
    <status>y</status>
</function>
<function>
    <signature>fn:ceiling(double? $srcval) => double?</signature>
    <status>y</status>
    <description>Rounds a value towards positive infinity</description>
</function>
<function>
    <signature>fn:codepoints-to-string(integer* codes) => string</signature>
    <status>y</status>
    <description>Converts a sequence of integers representing Unicode characters to the corresponding string</description>
</function>
<function>
    <signature>fn:collection(string $srcval) => node*</signature>
    <status>n</status>
    <description>Loads an external collection of nodes identified by the URI of the collection</description>
</function>
<function>
    <signature>fn:compare(string? $comparand1, string? $comparand2) => integer?</signature>
    <status>y</status>
    <description>Compares two strings using the default collation</description>
</function>
<function>
    <signature>fn:compare(string? $comparand1, string? $comparand2, anyURI $collationLiteral) => integer?</signature>
    <status>y (collation is a string)</status>
    <description>Compares two strings using a specified collation</description>
    <notes>In Saxon, the collation is represented as a string</notes>
    <see-also>extensions.html#saxon:collation</see-also>
</function>
<function>
    <signature>fn:concat(string $arg1, ...) => string</signature>
    <status>y</status>
    <description>Concatenates the string-values of the arguments into a single string</description>
</function>
<function>
    <signature>op:concatenate(item* $seq1, item* $seq2) => item*</signature>
    <status>y</status>
</function>
<function>
    <signature>fn:contains(string? $operand1, string? $operand2) => boolean?</signature>
    <status>y</status>
    <description>Returns true if the second string is a substring of the first</description>
    <notes>Currently implemented by comparing Unicode code-points</notes>
</function>
<function>
    <signature>fn:contains(string? $operand1, string? $operand2, anyURI $collationLiteral) => boolean?</signature>
    <status>n</status>
</function>
<function>
    <signature>op:context-document() => document?</signature>
    <status>y</status>
</function>
<function>
    <signature>fn:context-item() => item?</signature>
    <status>n</status>
</function>
<function>
    <signature>fn:copy(node? $srcval) => node?</signature>
    <status>n</status>
</function>
<function>
    <signature>fn:count(item* $srcval) => unsignedInt</signature>
    <status>y</status>
    <description>Counts the number of items in a sequence</description>
    <notes>Currently returns an integer, not an unsignedInt</notes>
</function>
<function>
    <signature>fn:current-date() => date</signature>
    <status>y</status>
    <description>Returns the current date</description>
</function>
<function>
    <signature>fn:current-dateTime() => dateTime</signature>
    <status>y</status>
    <description>Returns the current date and time</description>
</function>
<function>
    <signature>fn:current-time() => time</signature>
    <status>y</status>
    <description>Returns the current time</description>
</function>
<function>
    <signature>fn:data(node $srcval) => atomic value*</signature>
    <status>y</status>
    <description>Returns the typed value of a node</description>
</function>
<function>
    <signature>op:date-equal(date $operand1, date $operand2) => boolean</signature>
    <status>y</status>
</function>
<function>
    <signature>op:date-greater-than( date $operand1, date $operand2) => boolean</signature>
    <status>y</status>
</function>
<function>
    <signature>op:date-less-than( date $operand1, date $operand2) => boolean</signature>
    <status>y</status>
</function>
<function>
    <signature>op:dateTime-equal( dateTime $operand1, dateTime $operand2) => boolean</signature>
    <status>y</status>
</function>
<function>
    <signature>op:dateTime-greater-than( dateTime $operand1, dateTime $operand2) => boolean</signature>
    <status>y</status>
</function>
<function>
    <signature>op:dateTime-less-than( dateTime $operand1, dateTime $operand2) => boolean</signature>
    <status>y</status>
</function>
<function>
    <signature>op:dayTimeDuration-equal( dayTimeDuration $operand1, dayTimeDuration $operand2) => boolean</signature>
    <status>y</status>
</function>
<function>
    <signature>op:dayTimeDuration-greater-than( dayTimeDuration $operand1, dayTimeDuration $operand2) => boolean</signature>
    <status>y</status>
</function>
<function>
    <signature>op:dayTimeDuration-less-than( dayTimeDuration $operand1, dayTimeDuration $operand2) => boolean</signature>
    <status>y</status>
</function>
<function>
    <signature>fn:deep-equal(node $parameter1, node $parameter2) => boolean</signature>
    <status>y</status>
    <description>Compares two nodes for deep equality: the names and contents must be identical</description>
</function>
<function>
    <signature>fn:deep-equal(node $parameter1, node $parameter2, anyURI $collation) => boolean</signature>
    <status>y</status>
    <description>Compares two nodes for deep equality; string values are compared using the named collation</description>
    <notes>Untested</notes>
</function>
<function>
    <signature>fn:distinct-nodes( node* $srcval) => node*</signature>
    <status>y</status>
    <description>Eliminates nodes with duplicate values</description>
</function>
<function>
    <signature>fn:distinct-values( item* $srcval) => item*</signature>
    <status>n</status>
    <description>Returns the set of distinct values present in a given sequence</description>
</function>
<function>
    <signature>fn:distinct-values( item* $srcval, anyURI $collationLiteral) => item*</signature>
    <status>n</status>
    <description>Returns the set of distinct values present in a given sequence,
    comparing strings using a named collation.</description>    
</function>
<function>
    <signature>op:divide-dayTimeDuration( dayTimeDuration $srcval1, decimal $srcval2) => dayTimeDuration"</signature>
    <status>y</status>
</function>
<function>
    <signature>op:divide-yearMonthDuration( yearMonthDuration $srcval1, decimal $srcval2) => yearMonthDuration</signature>
    <status>y</status>
</function>
<function>
    <signature>fn:document(item* $srcval1) => node*</signature>
    <status>y</status>
    <description>Loads one or more documents identified by their URIs</description>
</function>
<function>
    <signature>fn:document(item* $srcval1, node* $srcval2) => node*</signature>
    <status>y</status>
    <description>Loads one or more documents identified by their URIs, using the base URI of the
    node given in the second argument to resolve any relative URIs</description>
</function>
<function>
    <signature>op:duration-equal( duration $operand1, duration $operand2) => boolean</signature>
    <status>y (check spec),</status>
</function>
<function>
    <signature>fn:empty(item* $srcval) => boolean</signature>
    <status>y</status>
    <description>Returns true if the given sequence is empty</description>
</function>
<function>
    <signature>fn:ends-with(string? $operand1, string? $operand2) => boolean?</signature>
    <status>y</status>
    <description>Returns true if the first string ends with the second string</description>
    <notes>Currently compares string using Unicode codepoint matching</notes>
</function>
<function>
    <signature>fn:ends-with(string? $operand1, string? $operand2, anyURI $collationLiteral) => boolean?</signature>
    <status>n</status>
    <description>Returns true if the first string ends with the second string, when
    compared using the named collation</description>
</function>
<function>
    <signature>fn:error()</signature>
    <status>n</status>
    <description>Raises an error</description>
</function>
<function>
    <signature>fn:error(item $srcval)</signature>
    <status>n</status>
    <description>Raises an error</description>    
</function>
<function>
    <signature>fn:escape-uri(string $uri-part, boolean $escape-reserved) => string</signature>
    <status>y</status>
    <description>Applies the %HH escaping convention to a URI</description>
</function>
<function>
    <signature>op:except(node* $parameter1, node* $parameter2) => node*</signature>
    <status>y</status>
</function>
<function>
    <signature>fn:exists(item* $srcval) => boolean</signature>
    <status>y</status>
    <description>Returns true if the given sequence is not empty</description>
</function>
<function>
    <signature>fn:expanded-QName( string $paramURI, string $paramLocal) => QName</signature>
    <status>y</status>
    <description>Constructs a QName value from a URI and local name</description>
</function>
<function>
    <signature>fn:false() => boolean</signature>
    <status>y</status>
    <description>Returns the boolean value false</description>
</function>
<function>
    <signature>fn:floor(double? $srcval) => double?</signature>
    <status>y</status>
    <description>Rounds a number towards minus infinity</description>
</function>
<function>
    <signature>op:gDay-equal(gDay $operand1, gDay $operand2) => boolean</signature>
    <status>n</status>
</function>
<function>
    <signature>fn:get-day-from-date( date? $srcval) => integer?</signature>
    <status>y</status>
    <description>Extracts the day component of a date value</description>
</function>
<function>
    <signature>fn:get-day-from-dateTime( dateTime? $srcval) => integer?</signature>
    <status>y</status>
    <description>Extracts the day component of a dateTime value</description>
</function>
<function>
    <signature>fn:get-days-from-dayTimeDuration( dayTimeDuration? $srcval) => integer?</signature>
    <status>n</status>
    <description>Extracts the days component of a dayTimeDuration value</description>
</function>
<function>
    <signature>fn:get-dayTimeDuration-from-dateTimes( dateTime $srcval1, dateTime $srcval2) => dayTimeDuration</signature>
    <status>n</status>
    <description>Returns the difference between two dateTimes in the form of a dayTimeDuration</description>
</function>
<function>
    <signature>fn:get-hours-from-dateTime( dateTime? $srcval) => integer?</signature>
    <status>y</status>
    <description>Extracts the hour component of a dateTime value</description>
</function>
<function>
    <signature>fn:get-hours-from-dayTimeDuration( dayTimeDuration? $srcval) => integer?</signature>
    <status>n</status>
    <description>Extracts the hours component of a dayTimeDuration value</description>
</function>
<function>
    <signature>fn:get-hours-from-time( time? $srcval) => integer?</signature>
    <status>y</status>
    <description>Extracts the hours component of a time value</description>
</function>
<function>
    <signature>fn:get-local-name-from-QName( QName? $srcval) => string?</signature>
    <status>y</status>
    <description>Extracts the local name component of a QName value</description>
</function>
<function>
    <signature>fn:get-minutes-from-dateTime( dateTime? $srcval) => integer?</signature>
    <status>y</status>
    <description>Extracts the minutes component of a dateTime value</description>
</function>
<function>
    <signature>fn:get-minutes-from-dayTimeDuration( dayTimeDuration? $srcval) => integer?</signature>
    <status>n</status>
    <description>Extracts the minutes component of a dayTimeDuration value</description>
</function>
<function>
    <signature>fn:get-minutes-from-time( time? $srcval) => integer?</signature>
    <status>y</status>
    <description>Extracts the minutes component of a time value</description>
</function>
<function>
    <signature>fn:get-month-from-date( date? $srcval) => integer?</signature>
    <status>y</status>
    <description>Extracts the month component of a date value</description>
</function>
<function>
    <signature>fn:get-month-from-dateTime( dateTime? $srcval) => integer?</signature>
    <status>y</status>
    <description>Extracts the month component of a dateTime value</description>
</function>
<function>
    <signature>fn:get-months-from-yearMonthDuration( yearMonthDuration? $srcval) => integer?</signature>
    <status>n</status>
    <description>Extracts the months component of a yearMonthDuration value</description>
</function>
<function>
    <signature>fn:get-namespace-from-QName( QName? $srcval) => anyURI?</signature>
    <status>y</status>
    <description>Extracts the namespace URI component of a QName value</description>
</function>
<function>
    <signature>fn:get-seconds-from-dateTime( dateTime? $srcval) => decimal?</signature>
    <status>y</status>
    <description>Extracts the seconds component of a dateTime value</description>
</function>
<function>
    <signature>fn:get-seconds-from-dayTimeDuration( dayTimeDuration? $srcval) => integer?</signature>
    <status>n</status>
    <description>Extracts the seconds component of a dayTime value</description>
</function>
<function>
    <signature>fn:get-seconds-from-time( time? $srcval) => decimal?</signature>
    <status>y</status>
    <description>Extracts the seconds component of a time value</description>
</function>
<function>
    <signature>fn:get-timezone-from-date( date? $srcval) => string?</signature>
    <status>y</status>
    <description>Extracts the timezone component of a date value</description>
</function>
<function>
    <signature>fn:get-timezone-from-dateTime( dateTime? $srcval) => string?</signature>
    <status>y</status>
    <description>Extracts the timezone component of a dateTime value</description>
</function>
<function>
    <signature>fn:get-timezone-from-time( time? $srcval) => string?</signature>
    <status>y</status>
    <description>Extracts the timezone component of a time value</description>
</function>
<function>
    <signature>fn:get-year-from-date( date? $srcval) => integer?</signature>
    <status>y</status>
    <description>Extracts the year component of a date value</description>
</function>
<function>
    <signature>fn:get-year-from-dateTime( dateTime? $srcval) => integer?</signature>
    <status>y</status>
    <description>Extracts the year component of a dateTime value</description>
</function>
<function>
    <signature>fn:get-yearMonthDuration-from-dateTimes( dateTime $srcval1, dateTime $srcval2) => yearMonthDuration</signature>
    <status>n</status>
    <description>Returns the difference between two dateTime values in the form of a yearMonthDuration</description>
</function>
<function>
    <signature>fn:get-years-from-yearMonthDuration( yearMonthDuration? $srcval) => integer?</signature>
    <status>n</status>
    <description>Extracts the years component of a yearMonthDuration value</description>
</function>
<function>
    <signature>op:gMonth-equal(gMonth $operand1, gMonth $operand2) => boolean</signature>
    <status>n</status>
</function>
<function>
    <signature>op:gMonthDay-equal( gMonthDay $operand1, gMonthDay $operand2) => boolean</signature>
    <status>n</status>
</function>
<function>
    <signature>op:gYear-equal(gYear $operand1, gYear $operand2) => boolean</signature>
    <status>n</status>
</function>
<function>
    <signature>op:gYearMonth-equal( gYearMonth $operand1, gYearMonth $operand2) => boolean</signature>
    <status>n</status>
</function>
<function>
    <signature>op:hex-binary-equal( hexBinary $value1, hexBinary $value2) => boolean</signature>
    <status>n</status>
</function>
<function>
    <signature>fn:id(IDREF* $srcval) => element*</signature>
    <status>y</status>
    <description>Finds the elements with given ID attribute values</description>
    <notes>Implemented according to the XPath 1.0 specification</notes>
</function>
<function>
    <signature>fn:idref(string* $srcval) => element*</signature>
    <status>n</status>
    <description>Finds the elements that link to the element with a given ID value</description>
</function>
<function>
    <signature>fn:if-absent(node? $node, anySimpleType $value) => anySimpleType*</signature>
    <status>n</status>
    <description>Evaluates the second argument if the first is an empty sequence</description>
</function>
<function>
    <signature>fn:if-empty(node? $node, anySimpleType $value) => anySimpleType*</signature>
    <status>n</status>
    <description>Evaluates the second argument if the first is an element with empty content</description>
</function>
<function>
    <signature>fn:index-of(item* $seqParam, item $srchParam) => unsignedInt*</signature>
    <status>n</status>
    <description>Finds the positions of items in a sequence that match the second argument</description>
</function>
<function>
    <signature>fn:index-of(item* $seqParam, item $srchParam, anyURI $collationLiteral) => unsignedInt*</signature>
    <status>n</status>
    <description>Finds the positions of items in a sequence that match the second argument, using
    a named collation for the comparison</description>
</function>
<function>
    <signature>fn:input() => node*</signature>
    <status>n</status>
    <description>Return the sequence of nodes established by the calling environment as the current
    input collection</description>
</function>
<function>
    <signature>fn:insert(item* $target, decimal $position, item* $inserts) => item*</signature>
    <status>y</status>
    <description>Insert an item into a sequence</description>
</function>
<function>
    <signature>op:intersect(node* $parameter1, node* $parameter2) => node*</signature>
    <status>y</status>
</function>
<function>
    <signature>fn:item-at(item* $seqParam, decimal $posParam) => item?</signature>
    <status>y</status>
    <description>Return the item at a given position in a sequence</description>
    <notes>Currently returns an empty sequence rather than raising an error if the index is
    out of range</notes>
</function>
<function>
    <signature>fn:lang(string $testlang) => boolean</signature>
    <status>y</status>
    <description>Returns true if the xml:lang value for the context node matches the given language</description>
</function>
<function>
    <signature>fn:last() => unsignedInt?</signature>
    <status>y</status>
    <description>Returns the context size (the size of the sequence of items currently being processed)</description>
</function>
<function>
    <signature>fn:local-name() => string</signature>
    <status>y</status>
    <description>Returns the local part of the name of the context node</description>
</function>
<function>
    <signature>fn:local-name(node? $srcval) => string</signature>
    <status>y</status>
    <description>Returns the local part of the name of a given node</description>
</function>
<function>
    <signature>fn:lower-case(string? $srcval) => string?</signature>
    <status>y</status>
    <description>Translates characters in a string to lower case</description>
</function>
<function>
    <signature>fn:matches(string? $input, string? $pattern) => boolean?</signature>
    <status>y</status>
    <description>Returns true if the given string matches the given regular expression</description>
</function>
<function>
    <signature>fn:matches(string? $input, string? $pattern, string? $flags) => boolean?</signature>
    <status>y</status>
    <description>Returns true if the given string matches the given regular expression,
    specifying flags to control the way pattern matching is performed</description>    
</function>
<function>
    <signature>fn:max(item* $srcval) => anySimpleType?</signature>
    <status>y</status>
    <description>Returns the highest value in a sequence of comparable items</description>
</function>
<function>
    <signature>fn:max(item* $srcval, anyURI $collationLiteral) => anySimpleType?</signature>
    <status>n</status>
    <description>Returns the highest value in a sequence of strings, using a specified collation to
    perform the comparisons</description>
</function>
<function>
    <signature>fn:min(item* $srcval) => anySimpleType?</signature>
    <status>y</status>
    <description>Returns the lowest value in a sequence of comparable items</description>
</function>
<function>
    <signature>fn:min(item* $srcval, anyURI $collationLiteral) => anySimpleType?</signature>
    <status>n</status>
    <description>Returns the lowest value in a sequence of strings, using a specified collation to
    perform the comparisons</description>    
</function>
<function>
    <signature>op:multiply-dayTimeDuration( dayTimeDuration $srcval1, decimal $srcval2) => dayTimeDuration</signature>
    <status>y</status>
</function>
<function>
    <signature>op:multiply-yearMonthDuration( yearMonthDuration $srcval1, decimal $srcval2) => yearMonthDuration</signature>
    <status>y</status>
</function>
<function>
    <signature>fn:name() => string</signature>
    <status>y</status>
    <description>Returns the name of the context node, as a string in the lexical form of a QName</description>
</function>
<function>
    <signature>fn:name(node? $srcval) => string</signature>
    <status>y</status>
    <description>Returns the name of a given node, as a string in the lexical form of a QName</description>
</function>
<function>
    <signature>fn:namespace-uri() => string</signature>
    <status>y</status>
    <description>Returns the namespace URI of the name of the context node</description>
</function>
<function>
    <signature>fn:namespace-uri(node? $srcval) => string</signature>
    <status>y</status>
    <description>Returns the namespace URI of the name of a given node</description>
</function>
<function>
    <signature>op:node-after(node $parameter1, node $parameter2) => boolean</signature>
    <status>y</status>
</function>
<function>
    <signature>op:node-before(node $parameter1, node $parameter2) => boolean</signature>
    <status>y</status>
</function>
<function>
    <signature>op:node-equal(node $parameter1, node $parameter2) => boolean</signature>
    <status>y</status>
</function>
<function>
    <signature>fn:node-kind(node $srcval) => string</signature>
    <status>y</status>
    <description>Identifies what kind of node the argument is, as a string, for example "element" or
    "attribute"</description>
</function>
<function>
    <signature>fn:node-name(node $srcval) => QName?</signature>
    <status>n</status>
    <description>Returns the name of the given node, as a QName value (that is, a namespace URI plus
    local name)</description>
</function>
<function>
    <signature>fn:normalize-space( string? $srcval) => string?</signature>
    <status>y</status>
    <description>Eliminates redundant spaces from a string</description>
</function>
<function>
    <signature>fn:normalize-unicode( string? $srcval) => string?</signature>
    <status>n</status>
    <description>Converts a string to Unicode normalized form NFC by modifying the way in which
    combining characters are represented</description>
</function>
<function>
    <signature>fn:normalize-unicode( string? $srcval, string $normalizationForm) => string?</signature>
    <status>n</status>
    <description>Converts a string to a given Unicode normalized form by modifying the way in which
    combining characters are represented</description>    
</function>
<function>
    <signature>fn:not(item* $srcval) => boolean</signature>
    <status>y</status>
    <description>Returns true if the effective boolean value of the argument is false, and vice versa</description>
</function>
<function>
    <signature>op:NOTATION-equal( NOTATION $srcval1, NOTATION $srcval2) => boolean</signature>
    <status>n</status>
</function>
<function>
    <signature>fn:number() => double</signature>
    <status>y</status>
    <description>Converts the string value of the context node to a number</description>
</function>
<function>
    <signature>fn:number(node $srcval) => double</signature>
    <status>y</status>
    <description>Converts the string value of the given node to a number</description>
    <notes>Implementation follows the XPath 1.0 specification</notes>
</function>
<function>
    <signature>op:numeric-add(numeric $operand1, numeric $operand2) => numeric</signature>
    <status>y</status>
</function>
<function>
    <signature>op:numeric-divide( numeric $operand1, numeric $operand2) => numeric</signature>
    <status>y</status>
</function>
<function>
    <signature>op:numeric-equal(numeric $operand1, numeric $operand2) => boolean</signature>
    <status>y</status>
</function>
<function>
    <signature>op:numeric-greater-than( numeric $operand1, numeric $operand2) => boolean</signature>
    <status>y</status>
</function>
<function>
    <signature>op:numeric-integer-divide( integer $operand1, integer $operand2) => integer</signature>
    <status>y</status>
</function>
<function>
    <signature>op:numeric-less-than( numeric $operand1, numeric $operand2) => boolean</signature>
    <status>y</status>
</function>
<function>
    <signature>op:numeric-mod(numeric $operand1, numeric $operand2) => numeric</signature>
    <status>y</status>
</function>
<function>
    <signature>op:numeric-multiply( numeric $operand1, numeric $operand2) => numeric</signature>
    <status>y</status>
</function>
<function>
    <signature>op:numeric-subtract( numeric $operand1, numeric $operand2) => numeric</signature>
    <status>y</status>
</function>
<function>
    <signature>op:numeric-unary-minus( numeric $operand) => numeric</signature>
    <status>y</status>
</function>
<function>
    <signature>op:numeric-unary-plus( numeric $operand) => numeric</signature>
    <status>y</status>
</function>
<function>
    <signature>fn:position() => unsignedInt?</signature>
    <status>y</status>
    <description>Returns the context position (that is, the position of the context item in the sequence
    currenly being processed)</description>
</function>
<function>
    <signature>op:QName-equal(QName $srcval1, QName $srcval2) => boolean</signature>
    <status>y</status>
</function>
<function>
    <signature>fn:remove(item* $target, decimal $position) => item*</signature>
    <status>y</status>
    <description>Removes the item at a given position in a sequence</description>
</function>
<function>
    <signature>fn:remove-timezone-from-dateTime( dateTime $srcval) => dateTime</signature>
    <status>n</status>
    <description>Removes the timezone information from a dateTime value</description>
</function>
<function>
    <signature>fn:remove-timezone-from-dateTime( dateTime $srcval, dayTimeDuration $timezone) => dateTime</signature>
    <status>n</status>
    <description>Removes the timezone information from a dateTime value, substituting the given timezone</description>
</function>
<function>
    <signature>fn:remove-timezone-from-time( time $srcval) => time</signature>
    <status>n</status>
    <description>Removes the timezone information from a time value</description>
</function>
<function>
    <signature>fn:remove-timezone-from-time( time $srcval, dayTimeDuration $timezone) => time</signature>
    <status>n</status>
    <description>Removes the timezone information from a time value, substituting the given timezone</description>
</function>
<function>
    <signature>fn:replace(string? $input, string? $pattern, string? $replacement) => string?</signature>
    <status>y</status>
    <description>Replaces sequences of characters within a string that match a given regular expression</description> 
</function>
<function>
    <signature>fn:replace(string? $input, string? $pattern, string? $replacement, string? $flags) => string?</signature>
    <status>y</status>
    <description>Replaces sequences of characters within a string that match a given regular expression,
    specifying flags to control the way the regular expression is matched</description> 
</function>
<function>
    <signature>fn:resolve-uri(anyURI $base, anyURI $relative) => anyURI</signature>
    <status>n</status>
    <description>Resolves a relative URI against a given base URI</description>
</function>
<function>
    <signature>fn:root(node $srcval) => node</signature>
    <status>y</status>
    <description>Returns the root node (document node) of the tree containing the given node</description>
</function>
<function>
    <signature>fn:round(double? $srcval) => double?</signature>
    <status>y</status>
    <description>Rounds a numeric value to the nearest whole number</description>
</function>
<function>
    <signature>fn:sequence-deep-equal( item* $parameter1, item* $parameter2) => boolean?</signature>
    <status>y</status>
    <description>Tests whether two sequences contain items that are pairwise deep-equal</description>
</function>
<function>
    <signature>fn:sequence-deep-equal( item* $parameter1, item* $parameter2, anyURI $collationLiteral) => boolean?</signature>
    <status>y</status>
    <description>Tests whether two sequences contain items that are pairwise deep-equal, using
    the given collation to compare string values</description>
</function>
<function>
    <signature>fn:sequence-node-equal( node* $parameter1, node* $parameter2) => boolean?</signature>
    <status>y</status>
    <description>Tests whether two sequences contain identical nodes in identical positions</description>
</function>
<function>
    <signature>fn:starts-with(string? $operand1, string? $operand2) => boolean?</signature>
    <status>y</status>
    <description>Tests whether one string starts with another string</description>
    <notes>Currently compares the strings using Unicode code-point matching</notes>
</function>
<function>
    <signature>fn:starts-with(string? $operand1, string? $operand2, anyURI $collationLiteral) => boolean?</signature>
    <status>n</status>
    <description>Tests whether one string starts with another string, using the given
    collation for comparison</description>
</function>
<function>
    <signature>fn:string() => string</signature>
    <status>y</status>
    <description>Returns the string value of the context node</description>
</function>
<function>
    <signature>fn:string(item $srcval) => string</signature>
    <status>y</status>
    <description>Returns the string value of the argument</description>
</function>
<function>
    <signature>fn:string-join(string* $sequence, string $separator) => string</signature>
    <status>y</status>
    <description>Concatenates all the strings in the given sequence, separated by the given separator</description>
</function>
<function>
    <signature>fn:string-length(string? $srcval) => integer?</signature>
    <status>y</status>
    <description>Returns the number of characters in the given string</description>
</function>
<function>
    <signature>fn:string-pad(string? $padString, decimal? $padCount) => string?</signature>
    <status>y</status>
    <description>Returns a string obtained by concatenating $padCount occurrences of $padString</description>
</function>
<function>
    <signature>fn:string-to-codepoints(string $srcval) => integer*</signature>
    <status>y</status>
    <description>Returns a sequence of integers representing the Unicode codepoints of the 
    characters in the supplied string</description>
</function>
<function>
    <signature>fn:subsequence(item* $sourceSeq, decimal $startingLoc) => item*</signature>
    <status>y</status>
    <description>Returns those items in the given sequence from the given starting position
    to the end of the sequence</description>
</function>
<function>
    <signature>fn:subsequence(item* $sourceSeq, decimal $startingLoc, decimal $length) => item*</signature>
    <status>y</status>
    <description>Returns those items in the given sequence from the given starting position
    up to the position implied by the given length</description>
</function>
<function>
    <signature>fn:substring(string? $sourceString, decimal? $startingLoc) => string?</signature>
    <status>y</status>
    <description>Returns a substring of a given string starting at the given starting position
    and continuing to the end of the string</description>
</function>
<function>
    <signature>fn:substring(string? $sourceString, decimal? $startingLoc, decimal? $length) => string?</signature>
    <status>y</status>
    <description>Returns a subtring of a given string, starting at a given position and
    continuing up to a given length</description>
</function>
<function>
    <signature>fn:substring-after( string? $operand1, string? $operand2) => string?</signature>
    <status>y</status>
    <description>Returns that part of the given input string that occurs after the first occurrence
    of the string given in $operand2</description>
</function>
<function>
    <signature>fn:substring-after( string? $operand1, string? $operand2, anyURI $collationLiteral) => string?</signature>
    <status>n</status>
    <description>Returns that part of the given input string that occurs after the first occurrence
    of the string given in $operand2, using the given collation to compare strings</description>
</function>
<function>
    <signature>fn:substring-before( string? $operand1, string? $operand2) => string?</signature>
    <status>y</status>
    <description>Returns that part of the given input string that occurs before the first occurrence
    of the string given in $operand2</description>
</function>
<function>
    <signature>fn:substring-before( string? $operand1, string? $operand2, anyURI $collationLiteral) => string?</signature>
    <status>n</status>
    <description>Returns that part of the given input string that occurs before the first occurrence
    of the string given in $operand2, using the given collation to compare strings</description>    
</function>
<function>
    <signature>op:subtract-dates( date $srcval1, date $srcval2) => dayTimeDuration</signature>
    <status>n</status>
</function>
<function>
    <signature>op:subtract-dayTimeDuration-from-date( date $srcval1, dayTimeDuration $srcval2) => date</signature>
    <status>n</status>
</function>
<function>
    <signature>op:subtract-dayTimeDuration-from-dateTime( dateTime $srcval1, dayTimeDuration $srcval2) => dateTime</signature>
    <status>n</status>
</function>
<function>
    <signature>op:subtract-dayTimeDuration-from-time( time $srcval1, dayTimeDuration $srcval2) => time</signature>
    <status>n</status>
</function>
<function>
    <signature>op:subtract-dayTimeDurations( dayTimeDuration $srcval1, dayTimeDuration $srcval2) => dayTimeDuration</signature>
    <status>n</status>
</function>
<function>
    <signature>op:subtract-times( time $srcval1, time $srcval2) => dayTimeDuration</signature>
    <status>n</status>
</function>
<function>
    <signature>op:subtract-yearMonthDuration-from-date( date $srcval1, yearMonthDuration $srcval2) => date</signature>
    <status>n</status>
</function>
<function>
    <signature>op:subtract-yearMonthDuration-from-dateTime( dateTime $srcval1, yearMonthDuration $srcval2) => dateTime</signature>
    <status>n</status>
</function>
<function>
    <signature>op:subtract-yearMonthDurations( yearMonthDuration $srcval1, yearMonthDuration $srcval2) => yearMonthDuration</signature>
    <status>n</status>
</function>
<function>
    <signature>fn:sum(item* $srcval) => double</signature>
    <status>y</status>
    <description>Returns the total of a sequence of numbers</description>
</function>
<function>
    <signature>op:time-equal(time $operand1, time $operand2) => boolean</signature>
    <status>y</status>
</function>
<function>
    <signature>op:time-greater-than( dateTime $operand1, dateTime $operand2) => boolean</signature>
    <status>y</status>
</function>
<function>
    <signature>op:time-less-than( time $operand1, time $operand2) => boolean</signature>
    <status>y</status>
</function>
<function>
    <signature>op:to(decimal $firstval, decimal $lastval) => integer+</signature>
    <status>y</status>
</function>
<function>
    <signature>fn:tokenize(string? $input, string? $pattern) => string*</signature>
    <status>y</status>
    <description>Returns a sequence of strings formed by breaking the input string at any substring
    that matches the given regular expression</description>
</function>
<function>
    <signature>fn:tokenize(string? $input, string? $pattern, string? $flags) => string*</signature>
    <status>y</status>
    <description>Returns a sequence of strings formed by breaking the input string at any substring
    that matches the given regular expression, using flags to control the way regular expression matching
    is performed</description>    
</function>
<function>
    <signature>fn:translate(string? $srcval, string? $mapString, string? $transString) => string?</signature>
    <status>y</status>
    <description>Returns a string formed by replacing individual characters that appear in the second
    argument with the characters that appear at the corresponding position in the third argument</description>
</function>
<function>
    <signature>fn:true() => boolean</signature>
    <status>y</status>
    <description>Return the boolean value true</description>
</function>
<function>
    <signature>op:union(node* $parameter1, node* $parameter2) => node*</signature>
    <status>y</status>
</function>
<function>
    <signature>fn:unique-ID(node $srcval) => ID?</signature>
    <status>n</status>
    <description>Return the value of the ID attribute of an element, if it has one</description>
</function>
<function>
    <signature>fn:upper-case(string? $srcval) => string?</signature>
    <status>y</status>
    <description>Converts a string to upper case</description>
</function>
<function>
    <signature>op:yearMonthDuration-equal( yearMonthDuration $operand1, yearMonthDuration $operand2) => boolean</signature>
    <status>y</status>
</function>
<function>
    <signature>op:yearMonthDuration-greater-than( yearMonthDuration $operand1, yearMonthDuration $operand2) => boolean</signature>
    <status>y</status>
</function>
<function>
    <signature>op:yearMonthDuration-less-than( yearMonthDuration $operand1, yearMonthDuration $operand2) => boolean</signature>
    <status>y</status>
</function>

</functions>

<xsl:stylesheet id="ss"  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
 version="2.0">
 
 <xsl:template match="xsl:stylesheet"/>
 
 <xsl:template match="functions">
   <html>
    <head>
    <title>XPath 2.0 Functions</title>
    <link rel="stylesheet" type="text/css" href="saxon-style.css"/>
    </head>   
   
   <body>
    <div align="right"><a href="index.html">Saxon home page</a></div>

   <h1>XPath 2.0 Functions</h1>
   <p>The list on this page indicates which XPath 2.0 functions are implemented in this Saxon release,
   and any restrictions in the current implementation.</p>
   
   <p>Functions defined in the XSLT 2.0 specification are not currently listed.</p>
   
   <xsl:apply-templates select="function[starts-with(signature, 'fn:')]"/>

<p align="center"><a HREF="mailto:michael.h.kay@ntlworld.com">Michael H. Kay</a> <br/>
15 November 2002</p>

   </body></html>
 </xsl:template>
 
 <xsl:template match="function">
      <xsl:apply-templates select="signature"/>
      <p><i><xsl:copy-of select="description"/></i></p>
      <xsl:variable name="fname" select="substring-before(substring-after(signature,':'),'(')"/>
      <p><a href="http://www.w3.org/TR/xquery-operators/#function-{$fname}">XPath 2.0 Specification</a></p>
      <xsl:apply-templates select="status"/>
      <xsl:apply-templates select="notes"/>
      <hr/>
 </xsl:template>
 
 <xsl:template match="function[starts-with(signature, 'op:')]"/>

 <xsl:template match="signature">
   <p><b><xsl:apply-templates/></b></p>
 </xsl:template>
 
 <xsl:template match="status">
   <xsl:apply-templates/>
 </xsl:template>
 
  <xsl:template match="status[.='y']"/>
 
  <xsl:template match="status[.='n']">
   <p>** Not yet implemented **</p>
 </xsl:template>
 
  <xsl:template match="notes">
   <p><b>Note: </b><xsl:apply-templates/></p>
 </xsl:template>
 
 </xsl:stylesheet> 

</conformance>
