<html>

<head>
  <title>XPath 2.0 Expression Syntax</title>
  <link rel="stylesheet" type="text/css" href="saxon-style.css">
</head>
<body>
<div align=right><a href="index.html">Saxon home page</a></div>

<h1>XPath 2.0 Expression Syntax</h1>


<hr>


<table width="100%">
  <tr>
    <td width="100%" colspan="2" class="head"><b>Contents</b></td>
  </tr>

  <tr>
    <td VALIGN="top" class="body" width="50%">
    <a href="#Introduction">Introduction</a><br>
    <a href="#Literals">Constants</a><br>
    <a href="#VariableReferences">Variable References</a><br>
    <a href="#FunctionCalls">Function Calls</a><br>
    <a href="#AxisSteps">Axis Steps</a><br>
    <a href="#Parentheses">Parentheses and operator precedence</a><br>
    <a href="#Filter">Filter Expressions</a><br>
    <a href="#Path">Path expressions</a><br>
    <a href="#cast">Cast as, Treat as</a><br>
    <a href="#except">Set difference and intersection</a><br>    
    <a href="#union">Set union</a><br>
    </td><td VALIGN="top" class="body" width="50%">
    <a href="#unary">Unary minus</a><br>
    <a href="#multiplication">Multiplication and Division</a><br>
    <a href="#addition">Addition and Subtraction</a><br>
    <a href="#range">Range Expressions</a><br>
    <a href="#comparisons">Comparisons</a><br>
    <a href="#instanceof">Instance of, Castable as</a><br>    
    <a href="#conditionals">Conditional Expressions</a><br>
    <a href="#quantified">Quantified Expressions</a><br>
    <a href="#for">For Expressions</a><br>
    <a href="#and">And Expressions</a><br>
    <a href="#or">Or Expressions</a><br>
    <a href="#sequence">Sequence Expressions</a><br>                            
    </td>

  </tr>
</table>

<h2><a name="Introduction">Introduction</a></h2>

<p>This document is an informal guide to the syntax of XPath 2.0 expressions, which are used in Saxon both within
XSLT stylesheets, and in the Java API. For formal specifications, see the
 <a href="http://www.w3.org/TR/xpath20">XPath 2.0 specification</a>,
except where differences are noted here.</p>


<p>XPath expressions may be used either in an XSL stylesheet, or as a parameter to various Java
interfaces. The syntax is the same in both cases. In the Java interface, expressions are handled
using the <code>net.sf.saxon.xpath.XPathEvaluator</code> class, and are parsed using a call such as
<code>XPathEvaluator.createExpression("$a + $b")</code>. This returns an object of class <code>net.sf.saxon.xpath.XPathExpression</code>,
which provides two methods for evaluating the expression: <code>evaluate()</code>, which returns the value
of the expression, and <code>iterator()</code>, which allows iteration over the items in the sequence
returned by the expression. For further details of these methods, see the API documentation.</p>

<p>An important change in XPath 2.0 is that all values are now considered as sequences. A sequence
consists of zero or more items; an item may be a node or a simple-value. Examples of simple-values
are integers, strings, booleans, and dates. A single value such as
a number is considered as a sequence of length 1. The empty sequence is written as <code>()</code>;
a singleton sequence may be written as <code>"a"</code> or <code>("a")</code>, and a general
sequence is written as <code>("a", "b", "c")</code>.</p>

<p>The node-sets of XPath 1.0 are replaced in XPath 2.0 by sequences of nodes. Path expressions
will return node sequences whose nodes are in document order with no duplicates, but other kinds
of expression may return sequences of nodes in any order, with duplicates permitted.</p> 

<p>This page summarizes the syntactic constructs and operators provided in XPath 2.0. The functions
provided in the function library are listed separately: see <a href="functions.html">functions.html</a>.</p>
<hr>

<a name="Literals"><h2>Constants</h2></a>

<p><b>String literals</b> are written as "London" or 'Paris'. In each case you can use the opposite
kind of quotation mark within the string: 'He said "Boo"', or "That's rubbish". In a stylesheet
XSL expressions always appear within XML attributes, so it is usual to use one kind of delimiter for
the attribute and the other kind for the literal. Anything else can be written using XML character
entities. In XPath 2.0, string delimiters can be doubled within the string to represent the
delimiter itself: for example <code>&lt;xsl:value-of select='"He said, ""Go!"""'/&gt;</code></p>

<p><b>Numeric constants</b> follow the Java rules for decimal literals: for example, <code>12</code> or <code>3.05</code>; a
negative number can be written as (say) <code>-93.7</code>, though technically the minus sign is not part of the
literal. (Also, note that you may need a space before the minus sign to avoid it being treated as
a hyphen within a preceding name). The numeric literal is taken as a double precision floating 
point number if it uses scientific notation (e.g. <code>1.0e7</code>), as fixed point decimal
if it includes a full stop, or as a integer otherwise. Decimal values in Saxon have unlimited 
precision, integers are limited to 64 bits. Note that a value such as <code>3.5</code> was
handled as a double-precision floating point number in XPath 1.0, but as a decimal number in
XPath 2.0: this may affect the precision of arithmetic results. Saxon implements decimal arithmetic
using the Java class <code>java.math.BigDecimal</code></p>

<p>There are no boolean constants as such: instead use the function calls <code>true()</code> and 
<code>false()</code>.</p>

<p>Constants of other data types can be written using constructors, which look like function calls
but require a string literal as their argument. For example, <code>xs:float("10.7")</code> produces
a single-precision floating point number. Saxon implements constructors for many of the built-in data types
defined in XML Schema Part 2: for a full list see <a href="conformance.html">conformance.html</a>.</p>

<p>An example for <b>date</b> and <b>dateTime</b> values: 
you can write constants for these data types as <code>xs:date("2002-04-30")</code>
or <code>xs:dateTime("1966-07-31T15:00:00Z")</code>.</p>

<p><i>The latest (November 2002) draft of XPath 2.0 allows the argument to a constructor to
contain whitespace, as determined by the whitespace facet for the target data type. This feature
is not implemented in Saxon 7.3</i></p>

<hr>
<a name="VariableReferences"><h2>Variable References</h2></a>

<p>The value of a variable (local or global variable, local or global parameter) may be referred to
using the construct <code>$<i>name</i></code>, where <i>name</i> is the variable name.</p>

<p>The variable is always evaluated at the textual place where the expression containing it appears;
for example a variable used within an <code>xsl:attribute-set</code> must be in scope at the point where the
 attribute-set is defined, not the point where it is used.</p>

<p>A variable may take a value of any data type, and in general it is not possible to 
determine its data type statically.</p>

<p>It is an error to refer to a variable that has not been declared.</p>

<p>Starting with XPath 2.0, variables (known as range variables) may be declared within
an XPath expression, not only using <code>xsl:variable</code> elements in the stylesheet. The
expressions that declare variables are the <code>for</code>, <code>some</code>, and <code>every</code>
expressions.</p>


<hr />

<a name="FunctionCalls"><h2>Function Calls</h2></a>

<p>A function call in XPath 2.0 takes the form <code>F ( arg1, arg2, ...) </code>. In general, the
function name is a QName. A library of core functions is defined in the XPath 2.0 and XSLT 2.0
specifications. For details of these functions, including notes on their implementation
in this Saxon release, see <a href="functions.html">functions.html</a>. 
Additional functions are available (in a special namespace) as Saxon extensions:
these are listed in <a href="extensions.html">extensions.html</a>. Further functions may be
implemented by the user, either as XSLT <i>stylesheet functions</i> (see <a href="xsl-elements.html#xsl:function">xsl:function</a>),
or as Java <i>extension functions</i> (see <a href="extensibility.html">extensibility.html</a>).</p>

<p><i>In Saxon 7.3, the core function library is in no namespace; the functions are referenced
without using a namespace prefix.</i></p>

<p><i>Saxon 7.3 implements function calls using the XPath 1.0 function call rules rather than the
more restrictive XPath 2.0 rules. Essentially, this means that the supplied value is implicitly
cast to the required type.</i></p>

<hr />

<a name="AxisSteps"><h2>Axis steps</h2></a>

<p>The basic primitive for accessing a source document is the <i>axis step</i>. Axis steps 
may be combined into path expressions using the path operators <code>/</code> and <code>//</code>,
and they may be filtered using filter expressions in the same way as the result of any other
expression.</p>

<p>An axis step has the basic form <code>axis :: node-test</code>, and selects nodes on a given axis
that satisfy the node-test. The axes available are:

<table><tr><td>ancestor</td><td>Selects ancestor nodes starting with the current node and ending
with the document node</td></tr>
<tr><td>ancestor-or-self</td><td>Selects the current node plus all ancestor nodes</td></tr>
<tr><td>attribute</td><td>Selects all attributes of the current node (if it is an element)</td></tr>
<tr><td>child</td><td>Selects the children of the current node, in documetn order</td></tr>
<tr><td>descendant</td><td>Selects the children of the current node and their children, recursively
(in document order)</td></tr>
<tr><td>descendant-or-self</td><td>Selects the current node plus all descendant nodes</td></tr>
<tr><td>following</td><td>Selects the nodes that follow the current node in document order,
other than its descendants</td></tr>
<tr><td>following-sibling</td><td>Selects all subsequent child nodes of the same
parent node</td></tr>
<tr><td>parent</td><td>Selects the parent of the current node</td></tr>
<tr><td>preceding</td><td>Selects the nodes that precede the current node in document order,
other than its ancestors</td></tr>
<tr><td>preceding-sibling</td><td>Selects all preceding child nodes of the same
parent node</td></tr>
<tr><td>self</td><td>Selects the current node</td></tr></table>

<p>When the child axis is used, <code>child::</code> may be omitted, and when the attribute
axis is used, <code>attribute::</code> may be abbviated to <code>@</code>. The expression
<code>parent::node()</code> may be shortened to <code>..</code></p>

<p><i>The expression <code>.</code> is no longer synonymous with <code>self::node()</code>,
since it may now select items that are not nodes. If the context item is not a node, any use of a
path expression will raise an error.</i></p>

        <p>The node-test may be:</p>

            <ul><li>a node name</li>
            <li><code>prefix:*</code> to select nodes in a given namespace</li>
            <li><code>*:localname</code> to select nodes with a given local name, regardless of namespace</li>
            <li><code>text()</code> (to select text nodes)</li>
            <li><code>node()</code> (to select any node)</li>
            <li><code>processing-instruction()</code> (to select any processing instruction)</li>
            <li><code>processing-instruction('literal')</code> to select processing instructions with the given name
            (target)</li>
            <li><code>comment()</code> to select comment nodes</li></ul>

<hr />

<a name="Parentheses"><h2>Parentheses and operator precedence</h2></a>

<p>In general an expression may be enclosed in parentheses without changing its meaning.</p>

<p>If parentheses are not used, operator precedence follows the sequence below, starting with the
operators that bind most tightly. Within each group the operators are evaluated left-to-right</p>

<table>
<tr><td width=200><b>Operator</b></td><td><b>Meaning</b></td></tr>
<tr><td>[]</td><td>predicate</td></tr>
<tr><td>/, //</td><td>path operator</td></tr>
<tr><td>cast as, treat as</td><td>type conversion</td></tr>
<tr><td>except, intersect</td><td>set difference and intersection</td></tr>
<tr><td>|, union</td><td>union operation on sets</td></tr>
<tr><td>unary -</td><td>unary minus</td></tr>
<tr><td>*, div, idiv, mod</td><td>multiply, divide, integer divide, modulo</td></tr>
<tr><td>+, -</td><td>plus, minus</td></tr>
<tr><td>to</td><td>range expression</td></tr>
<tr><td>=, !=, is, isnot, &lt;, &lt=;, &gt;, &gt=;, eq, ne, lt, le, gt, ge</td><td>comparisons</td></tr>
<tr><td>instance of, castable as</td><td>type tests</td></tr>
<tr><td>if</td><td>conditional expressions</td></tr>
<tr><td>some, every</td><td>quantified expressions</td></tr>
<tr><td>for</td><td>iteration (mapping) over a sequence</td></tr>
<tr><td>and</td><td>Boolean and</td></tr>
<tr><td>or</td><td>Boolean or</td></tr>
<tr><td>, (comma)</td><td>Sequence concatenation</td></tr>
</table>
<hr>

<p><i>The latest (November 2002) drafts of XPath 2.0 and XSLT 2.0 allow <code>a, b, c</code> as a top-level
expression. This is not yet implemented in Saxon 7.3. Saxon allows the comma operator only within
parentheses.</i></p>

<p>The various operators are described, in this order, in the sections that follow.</p>

<hr />

<a name="Filter"><h2>Filter expressions</h2></a>

<p>The notation <code>E[P]</code> is used to select items from the sequence obtained by evaluating
<code>E</code>. If the predicate <code>P</code> is numeric, the predicate selects an item if its
position (counting from 1) is equal to <code>P</code>; otherwise, the <i>effective boolean value</i>
of <code>P</code> determines whether an item is selected or not. The effective boolean value of a sequence
is false if the sequence is empty, or if it contains a single item that is one of: the boolean value
false, the zero-length string, or a numeric zero or NaN value. Otherwise, the effective boolean
value is true.</p>

<p>In XPath 2.0, <code>E</code> may be any sequence, it is not restricted to a node sequence. Within
the predicate, the expression <code>.</code> (dot) refers to the context item, that is, the item
currently being tested. The XPath 1.0 concept of context node has thus been generalized, for example
<code>.</code> can refer to a string or a number.</p>

<p>Generally the order of items in the result preserves the order of items in <code>E</code>. As a 
special case, however, if <code>E</code> is a step using a reverse axis (e.g. preceding-sibling), the
position of nodes for the purpose of evaluating the predicate is in reverse document order, but the
result of the filter expression is in forwards document order.</p>

<hr />

<a name="Path"><h2>Path expressions</h2></a>

<p>A path expression is a sequence of steps separated by the <code>/</code> or <code>//</code> operator.
For example, <code>../@desc</code> selects the <code>desc</code> attribute of the parent of the context
node.</p>

<p>In XPath 2.0, path expressions have been generalized so that any expression can be used as an operand
of <code>/</code>, (both on the left and the right), so long as its value is a sequence of nodes. For
example, it is possible to use a union expression (in parentheses) or a call to the <code>id()</code>
or <code>key()</code> functions. The right-hand operand is evaluated once for each node in the sequence
that results from evaluating the left-hand operand, with that node as the context item. In the result
of the path expression, nodes are sorted in document order, and duplicates are eliminated.</p>

<p>In practice, it only makes sense to use expressions on the right of <code>/</code> if they depend
on the context item. It is legal to write <code>$x/$y</code> provided both <code>$x</code> and
<code>$y</code> are sequences of nodes, but the result is exactly the same as writing <code>./$y</code>.</p>

<p>Note that the expressions <code>./$X</code> or <code>$X/.</code> can be used to remove duplicates
from <code>$X</code> and sort the results into document order. The same effect can be achieved by writing
<code>$X|()</code></p>

<p>The operator <code>//</code> is an abbreviation for <code>/descendant-or-self::node()/</code>.
An expression of the form <code>/E</code> is shorthand for <code>root(.)/E</code>, and the expression
<code>/</code> on its own is shorthand for <code>root(.)</code>.</p>

<hr />

<a name="cast"><h2>Cast as, Treat as</h2></a>

<p>The expression <code>cast as T (E)</code> converts the value of expression <code>E</code> to type
<code>T</code>. Since <code>T</code> must currently be a built-in schema-defined simple type, the
effect is exactly the same as using the constructor function <code>T (E)</code>.</p>

<p><i>Saxon implements most of the conversions defined in the XPath 2.0 specifications, for the data
types that it supports, but the details of how the conversions are performed may vary in detail. The
specification is still evolving in this area.</i></p>

<p>The expression <code>treat as T (E)</code> is designed for environments that perform static type
checking. Saxon doesn't do static type checking, so this expression has very little use, except to
document an assertion that the expression <code>E</code> is of a particular type. A run-time failure
will be reported if the value of <code>E</code> is not of type <code>T</code>; no attempt is made
to convert the value to this type.</p>

<hr />

<a name="except"><h2>Set difference and intersection</h2></a>

<p>These operators are new in XPath 2.0.</p>

<p>The expression <code>E1 except E2</code> selects all nodes that are in <code>E1</code> unless
they are also in <code>E2</code>. Both expressions must return sequences of nodes. The results
are returned in document order. For example, <code>@* except @note</code> returns all attributes
except the <code>note</code> attribute.</p>

<p>The expression <code>E1 intersect E2</code> selects all nodes that are in both <code>E1</code> and
 <code>E2</code>. Both expressions must return sequences of nodes. The results
are returned in document order. For example, <code>preceding::fig intersect ancestor::chapter//fig</code> 
returns all preceding <code>fig</code> elements within the current chapter.</p>

<hr />

<a name="union"><h2>Union</h2></a>

<p>The <code>|</code> operator was available in XPath 1.0; the keyword <code>union</code has been
added in XPath 2.0 as a synonym, because it is familiar to SQL users.</p>

<p>The expression <code>E1 union E2</code> selects all nodes that are in either <code>E1</code> or
 <code>E2</code> or both. Both expressions must return sequences of nodes. The results
are returned in document order. For example, <code>/book/(chapter | appendix)/sections</code> returns
all <code>section</code> elements within a <code>chapter</code> or <code>appendix</code> of the
selected <code>book</code> element.</p>

<hr />

<a name="unary"><h2>Unary minus</h2></a>

<p>The unary minus operator changes the sign of a number. For example <code>-1</code> is minus one, and
<code>-0e0</code> is the double value negative zero.</p>

<hr />

<a name="multiplication"<h2>Multiplication and division</h2></a>

<p>The operator <code>*</code> multiplies two numbers. If the operands are of different types, one
of them is promoted to the type of the other (for example, an integer is promoted to a decimal, a
decimal to a double). The result is the same type as the operands after promotion.</p>

<p>The operator <code>div</code> divides two numbers. The result is always a double.</p>

<p>The operator <code>idiv</code> performs integer division. For example, the result of
<code>10 idiv 3</code> is <code>3</code>.</p>

<p>The <code>mod</code> operator returns the modulus (or remainder) after division. See the XPath 2.0
specification for details of the way that negative numbers are handled.</p>

<p>The operators <code>*</code> and <code>div</code> may also be used to multiply or divide
a duration by a number. For example, <code>fn:dayTimeDuration('PT12H') * 4</code> returns the duration
two days.</p>

<hr />

<a name="addition"><h2>Addition and subtraction</h2></a>

<p>The operators <code>+</code> and <code>-</code> perform addition and subtraction of numbers,
in the usual way. If the operands are of different types, one of them is promoted, and the result
is the same type as the operands after promotion.</p>

<p>Note that the <code>-</code> operator may need to be preceded by a space to prevent it being
parsed as part of the preceding name.</p>

<p>XPath 2.0 also allows these operators to be used for adding durations to dates and times, but this
is not yet implemented in Saxon. However, Saxon 7.3 does allow durations to be added to (or subtracted from)
durations.</p>

<hr />

<a name="range"><h2>Range expressions</h2></a>

<p>The expression <code>E1 to E2</code> returns a sequence of integers. For example, <code>1 to 5</code>
returns the sequence <code>1, 2, 3, 4, 5</code>. This is useful in <code>for</code> expressions, for example
the first five nodes of a node sequence can be processed by writing <code>for $i in 1 to 5 return (//x)[$i]</code>.</p>

<hr />

<a name="comparisons"><h2>Comparisons</h2></a>

<p>The simplest comparison operators are <code>eq</code>, <code>ne</code>, <code>lt</code>
<code>le</code>, <code>gt</code>, <code>ge</code>. These compare two atomic values of the same type,
for example two integers, two dates, or two strings. In the case of strings, the default collation
is used (see <a href="extensions.html#saxon:collation">saxon:collation</a>). If the operands are
not atomic values, an error is raised.</p>

<p>The operators <code>=</code>, <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>,
<code>&gt;</code>, and <code>&gt;=</code> can compare arbitrary sequences. The result is true
if any pair of items from the two sequences has the specified relationship, for example
<code>$A = $B</code> is true if there is an item in <code>$A</code> that is equal to
some item in <code>$B</code>. If an argument is a node, Saxon currently uses its string
value in the comparison, not its typed value as required by the XPath 2.0 specification.</p>

<p>The operators <code>is</code> and <code>isnot</code> test whether the operands represent the same
(identical) node. For example, <code>title[1] is *[@note][1]</code> is true if the first <code>title</code>
child is the first child element that has a <code>@note</code> attribute. If either operand is an
empty sequence the result is an empty sequence (which will usually be treated as false).</p>

<p>The operators <code>&lt;&lt;</code> and <code>&gt;&gt;</code> test whether one node precedes
or follows another in document order.</p>

<hr />

<a name="instanceof"><h2>Instance of and Castable as</h2></a>

<p>The expression <code>E instance of T</code> tests whether the value of expression <code>E</code>
is an instance of type T, or of a subtype of T. For example, <code>$p instance of attribute+</code> is
true if the value of <code>$p</code> is a sequence of one or more attribute nodes. It returns false if the
sequence is empty or if it contains an item that is not an attribute node. The detailed rules for
defining types, and for matching values against a type, are given in the XPath 2.0 specification.</p>

<p>Saxon 7.3 implements only a subset of this syntax. It allows testing of a value against any built-in
simple type defined in XML Schema, except that some of the types are not yet implemented: see 
<a href="conformance.html">conformance.html</a>. The type can also be a <i>node-kind</i> such as
<code>element</code>, <code>attribute</code>, etc; or it can be one of the keywords <code>item</code>
or <code>node</code>. The type can be optionally followed by the occurrence indicator <code>*</code>, 
<code>+</code>, or <code>?</code>.</p>

<p>Saxon also allows testing of the type annotation of an element or attribute node using tests of the
form <code>element of type T</code>, <code>attribute of type T</code>. This is of limited value at this
release, however, since the only way a node can acquire a type annotation is (a) if the node is 
part of a temporary tree created within the stylesheet itself, or (b) if the node is an attribute with
a DTD-based type, for example ID.</p>

<p>The expression <code>E castable as T</code> tests whether the expression <code>cast as T (E)</code>
would succeed. It is useful, for example, for testing whether a string contains a valid date before attempting
to cast it to a date. This is because XPath and XSLT currently provide no way of trapping the error if
the cast is attempted and fails.</p>

<hr />

<a name="conditionals"><h2>Conditional Expressions</h2></a>

<p>XPath 2.0 allows a conditional expression of the form <code>if ( E1 ) then E2 else E3</code>.
For example, <code>if (@discount) then @discount else 0</code> returns the value of the <code>discount</code>
attribute if it is present, or zero otherwise.</p>

<hr />

<a name="quantified"><h2>Quantified Expressions</h2></a>

<p>The expression <code>some $x in E1 satisfies E2</code> returns true if there is an item in the
sequence <code>E1</code> for which the <i>effective boolean value</i> of <code>E2</code> is true. 
Note that <code>E2</code> must use the range variable <code>$x</code> to refer to the item being
tested; it does not become the context item. For example, <code>some $x in @* satisfies $x eq ""</code>
is true if the context item is an element that has at least one zero-length attribute value.</p>

<p>Similarly, the expression <code>every $x in E1 satisfies E2</code> returns true if every item in the
sequence given by <code>E1</code> satisfies the condition.</p>


<hr />

<a name="for"><h2>For Expressions</h2></a>

<p>The expression <code>for $x in E1 return E2</code> returns the sequence that result from evaluating
<code>E2</code> once for every item in the sequence <code>E1</code>. Note that <code>E2</code> must
use the range variable <code>$x</code> to refer to the item being
tested; it does not become the context item. For example, <code>sum(for $v in order-item return
$v/price * $v/quantity)</code> returns the total value of (price times quantity) for all the
selected <code>order-item</code> elements.</p>

<hr />

<a name="and"><h2>And expressions</h2></a>

<p>The expression <code>E1 and E2</code> returns true if the <i>effective boolean values</i> of
<code>E1</code> and <code>E2</code> are both true.</p>

<hr />

<a name="or"><h2>Or expressions</h2></a>

<p>The expression <code>E1 or E2</code> returns true if the <i>effective boolean values</i> of
either or both of <code>E1</code> and <code>E2</code> are true.</p>

<hr />

<a name="sequence"><h2>Sequence expressions</h2></a>

<p>The expression <code>E1 , E2</code> returns the sequence obtained by concatenating the sequences
<code>E1</code> and <code>E2</code>.</p>

<p>For example, <code>$x = ("London", "Paris", "Tokyo")</code> returns true if the value of <code>$x</code>
is one of the strings listed.</p>

<p><i>Saxon 7.3 does not allow this operator to appear at the top level: the comma operator may only
appear inside a parenthesized expression.</i></p>

<!--
<a name="StringExpressions"><h2>String Expressions</h2></a>

<p>There are some constructs that are specifically string expressions, but in addition any other
kind of expression can be used in a context where a string expression is required:</p>

<ul>
<li>According to the XPath 2.0 specification,
 numeric expression is converted to a string using the canonical lexical representation
for the particular numeric type as defined in XML Schema. For example, the integer 2 is displayed
as "2", but the decimal 2.0 is displayed as "2.0". In Saxon, however, for the time being
the string representation never ends with ".0", to reduce backwards compatibility problems.</li>
<li>A boolean expression is displayed as one of the strings "true" or "false".
<li>When a sequence expression is used in a string context, only the first item of the sequence
 is used: the value of this item is converted to a string. The string-value of a text node
 is the character content of the node; the string-value of an element node or document (root) node
 is the concatenation of all its descendant text nodes.</li>

 </ul>

<p>The specific string expressions are as follows:</p>

<table>

<tr><td width=40%><b>Construct</b></td><td><b>Meaning</b></td></tr>

<tr><td valign=top>string(<i>expression</i>)</td>
<td valign=top>This performs an explicit type conversion
to a string, which will always give the same result as the implicit conversion described above.
The main case where explicit conversion is useful is when assigning a value to a variable.</td></tr>

<tr><td valign=top>concat(<i>expression1</i>, <i>expression2</i> {,<i>expression3</i>}*)</td>
<td valign=top>This concatenates the
string values of the arguments. There may be any number of arguments (two or more).</td></tr>

<tr><td valign=top>substring(<i>expression1</i>, <i>expression2</i> [,<i>expression3</i>])</td>
<td valign=top>This extracts a substring of the string value of expression1. Expression2 gives
the start position (starting at 1), expression 3 gives the length: if omitted, the rest of the
string is used. For example, substring("Michael", 2, 4) is "icha".</td></tr>

<tr><td valign=top>substring-before(<i>expression1</i> ,<i>expression2</i>)</td>
<td valign=top>This returns the substring of expression1 that precedes the first occurrence of
expression2. If expression1 does not contain expression2, it returns the empty string. For
example, substring-before("c:\dir", ":\") returns "c".</td></tr>

<tr><td valign=top>substring-after(<i>expression1</i> ,<i>expression2</i>)</td>
<td valign=top>This returns the substring of expression1 that follows the first occurrence of
expression2. If expression1 does not contain expression2, it returns the empty string. For
example, substring-before("c:\dir", ":\") returns "dir".</td></tr>

<tr><td valign=top>normalize-space(<i>expression1</i>)</td>
<td valign=top>This removes leading and trailing white space, and converts all other sequences
of white space to a single space character. For example, 'normalize(" Mike &nbsp; Kay ")' returns
"Mike Kay"</td></tr>

<tr><td valign=top>translate(<i>expression1</i>, <i>expression2</i>, <i>expression3</i>)</td>
<td valign=top>This replaces any character in expression1 that also occurs in expression2 with
the corresponding character from expression3. For example, translate ("ABBA", "ABC", "123")
 returns "1221". If there is no corresponding character in expression3 (because it is shorter than
expression2), the character is removed from the string.</td></tr>

<tr><td valign=top>upper-case(<i>string</i>)</td>
<td valign=top>Converts a string to upper case, using the rules for the default Java locale.</td></tr>

<tr><td valign=top>lower-case(<i>string</i>)</td>
<td valign=top>Converts a string to lower case, using the rules for the default Java locale.</td></tr>

<tr><td valign=top>string-pad(<i>string</i>, <i>number</i>)</td>
<td valign=top>Returns n occurrences of the string, concatenated. For example, <code>string-pad("ab", 3)</code>
returns <code>"ababab"</code>.</td></tr>

<tr><td valign=top>name(<i>node</i>)</td>
<td valign=top>Returns the name of the given node, or the current
node if the argument is omitted. The name here is the "display name"; it will use the same
namespace prefix as in the original source document.</td></tr>

<tr><td valign=top>local-name(<i>node</i>)</td>
<td valign=top>Returns the local part (after the colon) of the name of the
 given node, or the current node if the argument is omitted</td></tr>

<tr><td valign=top>namespace-uri(<i>node</i>)</td>
<td valign=top>Returns the URI of the namespace of the name of the
 given node, or the current node if the argument is omitted</td></tr>

<tr><td valign=top>unparsed-entity-uri(<i>string-expression</i>)</td>
<td valign=top>Returns the URI of the unparsed entity with the given name in the
current document, if there is one; otherwise the empty string</td></tr>

<tr><td valign=top>generate-id(<i>node</i>)</td>
<td valign=top>Returns a system-generated identifier for the
 given node, or the current node if the argument is omitted. 
 The generated identifiers are always alphanumeric (except
for the document node, where the identifier is the empty string).
</ul>
</td></tr>
</table>


<hr>

<a name="NumericExpressions"><h2>Numeric Expressions</h2></a>

<p>There are some constructs that are specifically numeric expressions, but in addition any string
whose value is convertible to a number can be used as a number. A string that does not represent
any number is treated as the double value NaN (not a number).</p>

<p>A boolean is converted to a number by treating false as 0 and true as 1.</p>

<p>XPath 2.0 (and Saxon) now support four numeric types: integer, decimal, float, and double.</p>

<p>The specific numeric expressions are as follows:</p>

<table>

<tr><td width=40%><b>Construct</b></td><td><b>Meaning</b></td></tr>

<tr><td valign=top>number(<i>expression</i>)</td>
<td valign=top>This performs an explicit type conversion
to a number, which will always give the same result as the implicit conversion described above.
Explicit conversion can be useful when assigning a value to a variable. It is also useful when
creating an qualifier in a nodeset expression, since the meaning of a numeric qualifier is different
from a boolean one. At present in Saxon this always converts to a double.</td></tr>

<tr><td valign=top>count(<i>sequence</i>)</td>
<td valign=top>This returns the number of items in the sequence.</td></tr>

<tr><td valign=top>sum(<i>sequence</i>)</td>
<td valign=top>This converts the value of each item in the sequence to a number, and totals
the result.</td></tr>

<tr><td valign=top>avg(<i>sequence</i>)</td>
<td valign=top>This converts the value of each item in the sequence to a number, and returns the average of
the result.</td></tr>

<tr><td valign=top>min(<i>sequence</i>)</td>
<td valign=top>This converts the value of each item in the sequence to a number, and returns the minimum
the result.</td></tr>

<tr><td valign=top>max(<i>sequence</i>)</td>
<td valign=top>This converts the value of each item in the sequence to a number, and returns the maximum
the result.</td></tr>

<tr><td valign=top>string-length(<i>string</i>)</td>
<td valign=top>This returns the number of characters in the string value of expression.
Characters are counted using the Java length() function, which does not necessarily give the
same answer as the XPath rules, particularly when combining characters are used.</td></tr>

<tr><td valign=top><i>number</i> <i>op</i> <i>numeric-expression2</i></td>
<td valign=top>This performs an arithmetic operation on the two values. The operators
are + (plus), - (minus), * (multiply), div (divide), and mod (modulo). Note
that div currently does a floating-point division, and mod also uses floating point.
The other operators are evaluated according to the data type of their operands, for example
adding two integers gives an integer, adding an integer to a decimal gives a decimal.</td></tr>

<tr><td valign=top>- <i>number</i></td><td>changes the sign of the number.</td></tr>

<tr><td valign=top>floor(<i>number</i>)</td>
<td valign=top>This returns the largest integer that is &lt;= the argument</td></tr>

<tr><td valign=top>ceiling(<i>number</i>)</td>
<td valign=top>This returns the smallest integer that is &gt;= the argument</td></tr>

<tr><td valign=top>round(<i>number</i>)</td>
<td valign=top>This returns the closest integer to the argument. The rounding rules follow
Java conventions which are not quite the same as the XSL rules.</td></tr>

<tr><td valign=top>position()</td>
<td valign=top>This returns the position of the current item in the list of items being
processed. Positions
are numbered from one.</td></tr>

<tr><td valign=top>last()</td>
<td valign=top>This returns the number of items in the list of items being
processed.</td></tr>

</table>

<hr>

<a name="BooleanExpressions"><h2>Boolean Expressions</h2></a>

<p>Expressions of other types are converted to booleans as follows:</p>
<ul>

    <li>Numeric values: 0 is treated as false, everything else as true.</li>

    <li>String values: the zero-length string is treated as false, everything else as true.
    Note this changes in XPath 2.0 so that "0" and "false" are also treated as false.</li>

    <li>Sequences: the empty sequence is treated as false. A sequence consisting of
    a single boolean is treated as the value of that boolean. 
    A sequence containing at least one node is treated as true. Converting any other
    sequence throws an error.</li>

</ul>

</p>

<p>The specific boolean expressions are as follows:</p>

<table>

<tr><td width=40%><b>Construct</b></td><td><b>Meaning</b></td></tr>

<tr><td valign=top>boolean(<i>expression</i>)</td>
<td valign=top>This performs an explicit type conversion
to a boolean, which will always give the same result as the implicit conversion described above.
The main case where explicit conversion is useful is when assigning a value to a variable.</td></tr>

<tr><td valign=top>false(), true()</td>
<td valign=top>These function calls return false and true respectively.</td></tr>

<tr><td valign=top>A and B, A or B</td>
<td valign=top>These operators perform boolean conjunction and disjunction. Saxon currently
implements them with three-valued logic as in SQL, though this is not in sync with the
XPath Working Draft as published.</td></tr>

<tr><td valign=top>not(<i>boolean</i>)</td>
<td valign=top>This returns the logical negation of the argument.</td></tr>

<tr><td valign=top>not3(<i>boolean</i>)</td>
<td valign=top>This returns the logical negation of the argument, but adapted to use three-valued
logic as in SQL. The difference is that not(()) is true, whereas not3(()) is (). Note
that the empty sequence, (), plays the same rule as the null value in SQL.</td></tr>

<tr><td valign=top><i>expression1</i> ( "=" | "!=" )  <i>expression2</i></td>
<td valign=top>This tests whether the two values are equal (or not-equal). More strictly,
it considers both operands as sequences, and returns true if there is a value in the first
sequence that is equal (not-equal) to some value in the second sequence.
</td></tr>

<tr><td valign=top><i>expression1</i> ( "is" | "isnot" )  <i>expression2</i></td>
<td valign=top>This tests whether the two nodes are identical (or not-identical). The operands
must be single nodes. If either operand is an empty sequence, the result is an empty sequence;
if either operand is a sequence of two or more items, an error is thrown.
</td></tr>

<tr><td valign=top><i>numeric-expression1</i> <i>op</i> <i>numeric-expression2</i></td>
<td valign=top>This performs a numeric comparison of the two values. If both expressions
are sequences, the result is true if there is a pair of values from the two sequences that
satisfies the comparison. If one expression is a sequence, the result is true if there is
a value in that nodeset that satisfies the comparison with the other operand. The operators
are &lt; (less-than), &lt;= (less-or-equal), &gt; (greater-than), &gt;= (greater-or-equal).
The operators, when used in an XSL stylesheet, will need to be written using XML entities
such as "&amp;lt;". From Saxon 7.1, comparison of nodes or strings performs a lexicographic
comparison using the default collating sequence; it no longer attempts to convert the values to
numbers unless one of the values is already numeric. This means that an expression such as
<code>@price &gt; @discount</code> needs to be rewritten as <code>number(@price) &gt; number(@discount)</code></td></tr>

<tr><td valign=top>if ( <i>condition</i> ) then <i>expr1</i> else <i>expr</i></td>
<td valign=top>This returns the value of expr1 or expr2 depending on whether the condition
is true or false.
</td></tr>

<tr><td valign=top>some $<i>var</i> in <i>sequence</i> satisfies <i>condition</i></td>
<td valign=top>This returns true if there is an item in the sequence for which the condition
is true. For example, <code>some $i in //empl satisfies exists($i/@desc)</code> returns
true if some &lt;empl&gt; element in the source document has an <code>@desc</code> attribute.
Note that the item being tested in the condition does NOT become the context item: you could
nto replace the <code>$i/@desc</code> in this example with <code>@desc</code> or <code>./@desc</code></li>
</td></tr>

<tr><td valign=top>every $<i>var</i> in <i>sequence</i> satisfies <i>condition</i></td>
<td valign=top>This returns true if there is no item in the sequence for which the condition
is false. For example, <code>every $i in //empl satisfies exists($i/@desc)</code> returns
true if no &lt;empl&gt; element in the source document has no <code>@desc</code> attribute.
Note that the item being tested in the condition does NOT become the context item: you could
nto replace the <code>$i/@desc</code> in this example with <code>@desc</code> or <code>./@desc</code></li>
</td></tr>

<tr><td valign=top>exists(<i>sequence)</i></td>
<td valign=top>This returns true if the sequence contains at least one item.</td></tr>

<tr><td valign=top>empty(<i>sequence)</i></td>
<td valign=top>This returns true if the sequence is empty.</td></tr>

<tr><td valign=top>lang(<i>string-expression</i>)</td>
<td valign=top>This returns true if the xml:lang attribute on (or inherited by) the current node
is equal to the argument, or if it contains a suffix starting with "-" and ending with the argument,
ignoring case.</td></tr>

<tr><td valign=top><i>expression</i> instance of <i>type</i></td>
<td valign=top>This returns true if the value of the expression is an instance of the given type.
For example <code>(3,4,5) instance of xsd:integer*</code> returns true. The type must be a built-in simple type
defined in XML Schema (and any namespace prefix must be declared), or it may be one of the keywords <code>item</code>,
<code>node</code>, <code>element</code> (etc). It is not at present possible to refer to named complex
types defined in an XML Schema.</td></tr>

</table>

<hr>

<a name="SequenceExpressions"><h2>Sequence Expressions</h2></a>

<p>Sequence expressions can be written as follows:</p>

<table>

<tr><td width=40%><b>Construct</b></td><td><b>Meaning</b></td></tr>

<tr><td valign=top><i>expression1</i> | <i>expression2</i></td>
<td valign=top>This forms the union of the two sequences. In Saxon the two operands must currently
be sequences of nodes. The result is in document order with duplicates eliminated. The operator
"union" is a synonym of "|". </td></tr>

<tr><td valign=top><i>expression1</i> intersect <i>expression2</i></td>
<td valign=top>This forms the intersection of the two sequences. These
must currently consist entirely of nodes. The result is in document order, with
no duplicates.</td>

<tr><td valign=top><i>expression1</i> except <i>expression2</i></td>
<td valign=top>This forms the intersection of the two sequences. These
must currently consist entirely of nodes. The result is in document order, with
no duplicates. For example, <code>@* except @name</code> gives you all
the attributes of the context element, except for the <code>@name</code> attribute.</td>

<tr><td valign=top><i>sequence</i> [ <i>predicate</i> ]</i></td>
<td valign=top>This returns the set of all items in the supplied sequence that satisfy the
predicate. The predicate may be a boolean expression (which is evaluated with the particular
item as context item); or it may be a numeric expression,
which is a shorthand for the boolean expression position()=predicate. The sequence
may of course itself have one or more predicates, so a chain of filters can be set up.</td></tr>

<tr><td valign=top>for $<i>var</i> in <i>sequence</i> return <i>expression</i></td>
<td valign=top>This evaluates the given expression once for each item in the supplied
sequence, and returns a new sequence containing the concatenation of the results, in order.
For example, <code>sum(for $i in ./orderline return $i/@qty * $i/@price)</code> returns the total
value of an order by summing over the individual order lines.</td></tr>

<tr><td valign=top><i>nodeset-expression1</i> / <i>nodeset-expression2</i></td>
<td valign=top>This follows the given path for each node in nodeset-expression1
 (the "original nodes"), and returns
all the nodes reached (the "target nodes"). The two operands may be any expression
that returns a sequence of nodes. For example, at XPath 2.0 it is permitted to write
<code>document('abc.xml')/key('k', 123)</code>, or <code>book/(chapter|appendix)/section.</code>
Most commonly, the second expression will be a step that navigates from the context node
to other nodes by following axes.
Examples include:<ul>
    <li><i>name</i> - Select all the element children of the original nodes
                        with the given element name</li>
    <li><i>prefix:*</i> - Select all the element children of the original nodes
                        with the given namespace prefix</li>
   <li><i>*</i> - Select all the element children of the original nodes
                        regardless of element name</li>
    <li><i>*:local-name</i> - Select all the element children of the original nodes
                        with the given local-name, irrespective of namespace</li>
    <li><i>@name</i> - Select all the attributes of the original nodes
                        with the given attribute name</li>
    <li><i>@prefix:*</i> - Select all the attributes of the original nodes
                        with the given namespace prefix</li>
    <li><i>@*</i> - Select all the attributes of the original nodes
                        regardless of attribute name</li>
    <li>text() - Select all the text node children of the original nodes</li>
    <li>.. - Select the parents of the original nodes</li>    
    <li>node() - Select all the children of the original nodes</li>
    <li><i>axis-name</i> :: <i>node-test</i> <i>optional-predicates</i> ) - a generalised construct
        for navigating in any direction. The axis-name may be any of the following:


        <p>The optional-predicates is a sequence
        of zero-or-more predicates, each enclosed in square brackets, each being either a boolean
        expression or a numeric expression (as a shorthand for testing position()).</p></li>
    </ul>
    </td></tr>

<tr><td valign=top><i>nodeset-expression1</i> // <i>relative-path</i></td>
<td valign=top>This is a shorthand for
 nodeset-expression1/descendant-or-self::node()/relative-path<br>
 In effect "//" selects descendants, where "/" selects immediate children: but where predicates
 are used, the expansion above defines the precise meaning.</td></tr>

<tr><td valign=top><i>.</i></td>
<td valign=top>This selects the context item (which at XPath 2.0 is not necessarily a node)</td></tr>

<tr><td valign=top><i>insert(sequence, integer, sequence)</i></td>
<td valign=top>This creates a new sequence by inserting the second supplied sequence at the
given position of the first supplied sequence.</td></tr>

<tr><td valign=top><i>remove(sequence, integer)</i></td>
<td valign=top>This creates a new sequence by removing the item at the
given position of the supplied sequence.</td></tr>

<tr><td valign=top><i>index-of(sequence, item)</i></td>
<td valign=top>This returns a sequence of integers giving the positions within the supplied
sequence where the given item occurs.</td></tr>

<tr><td valign=top><i>sublist(sequence, start, length)</i></td>
<td valign=top>This returns part of the given sequence, starting at the given start position,
and of the given length.</td></tr>

<tr><td valign=top><i>/</i></td>
<td valign=top>This selects the document root node. Note that this nodeset-expression cannot be
followed by the "/" or "//" operator or by a predicate.</td></tr>

<tr><td valign=top><i> / <i>relative-path</i></td>
<td valign=top>This is a shorthand for "root()/relative-path" where root() is an imaginary
designation of the document root node.</td></tr>

<tr><td valign=top><i> // <i>relative-path</i></td>
<td valign=top>This is a shorthand for
 "root()//relative-path" where root() is an imaginary
designation of the document root node.</td></tr>

<tr><td valign=top>document(<i>expression1</i>, <i>expression2</i>?)</td>
<td valign=top>The first string expression is a URL, or a nodeset containing a set of URLs;
 the function returns the nodeset consisting of the root nodes of the documents referenced
  (which must be XML documents). The optional second argument is node-set used to provide a base URL for resolving
  relative URLs: the default is the URL of the document containing the relative URL, which
  may be either a source document or a stylesheet document. Saxon allows the first argument
  to contain a fragment identifier, e.g. "my.xml#xyz", or simply "#xyz", in which case
  "xyz" must be the value of an ID attribute of an element within the referenced document.
  The effect is to retrieve a tree rooted at this element.</td></tr>

<tr><td valign=top>id(<i>expression</i>)</td>
<td valign=top>This returns the node, if any, that has an ID attribute equal to the given
value,a nd which is in the same document as the current node.
 To use ID attributes, there must be a DTD that defines the attribute as being of
type ID, and you must use a SAX parser that notifies ID attributes to the application.
If the argument is a nodeset, the function returns the set of nodes that have an id
 attribute equal to a value held in any of the nodes in the nodeset-expression: each node
  in the nodeset expression
is converted to a string and treated as a white-space-separated list of id values.
If the argument is of any other type, its value is converted to a string and
treated as a white-space-separated list of id values.</td></tr>

<tr><td valign=top>key(<i>string-expression1</i>, <i>expression2</i>)</td>
<td valign=top>The first string expression is a key name; the function returns the set
 of nodes in the current document that have a key with this name, with the key value given
  by the second expression. If this is a nodeset, the key values are the values of the nodes
   in the nodeset; othewise, the key value is the string value of the argument.
     Note that keys must be registered using the xsl:key element.</td></tr>

</table>



<p>Some examples of NodeSet Expressions are listed below:</p>

<table BORDER="1" CELLSPACING="1" CELLPADDING="7" WIDTH="590">
  <tr>
    <td WIDTH="24%" VALIGN="TOP"><font SIZE="2"><b>Expression</b></font></td>
    <td WIDTH="76%" VALIGN="TOP"><font SIZE="2"><b>Meaning</b></font></td>
  </tr>
  <tr>
    <td WIDTH="24%" VALIGN="TOP"><font SIZE="2">XXX</font></td>
    <td WIDTH="76%" VALIGN="TOP"><font SIZE="2">Selects all immediate child elements with tag XXX</font></td>
  </tr>
  <tr>
    <td WIDTH="24%" VALIGN="TOP"><font SIZE="2">*</font></td>
    <td WIDTH="76%" VALIGN="TOP"><font SIZE="2">Selects all immediate child elements
     (but not character data within the element)</font></td>
  </tr>
  <tr>
    <td WIDTH="24%" VALIGN="TOP"><font SIZE="2">../TITLE</font></td>
    <td WIDTH="76%" VALIGN="TOP"><font SIZE="2">Selects the TITLE children of the parent element</font></td>
  </tr>
  <tr>
    <td WIDTH="24%" VALIGN="TOP"><font SIZE="2">XXX[@AAA]</font></td>
    <td WIDTH="76%" VALIGN="TOP"><font SIZE="2">Selects all XXX child elements having
    an attribute named AAA</font></td>
  </tr>
  <tr>
    <td WIDTH="24%" VALIGN="TOP"><font SIZE="2">*[last()]</font></td>
    <td WIDTH="76%" VALIGN="TOP"><font SIZE="2">Selects the last child of the current element</font></td>
  </tr>
  <tr>
    <td WIDTH="24%" VALIGN="TOP"><font SIZE="2">*/ZZZ</font></td>
    <td WIDTH="76%" VALIGN="TOP"><font SIZE="2">Selects all grandchild ZZZ elements </font></td>
  </tr>
  <tr>
    <td WIDTH="24%" VALIGN="TOP"><font SIZE="2">XXX[ZZZ]</font></td>
    <td WIDTH="76%" VALIGN="TOP"><font SIZE="2">Selects all child XXX elements that have a child ZZZ</font></td>
  </tr>
  <tr>
    <td WIDTH="24%" VALIGN="TOP"><font SIZE="2">XXX[@WIDTH and not(@WIDTH="20")]</font></td>
    <td WIDTH="76%" VALIGN="TOP"><font SIZE="2">Selects all child XXX elements that have a WIDTH attribute whose
     value is not "20"</font></td>
  </tr>
  <tr>
    <td WIDTH="24%" VALIGN="TOP"><font SIZE="2">/*</font></td>
    <td WIDTH="76%" VALIGN="TOP"><font SIZE="2">Selects the outermost element of the document</font></td>
  </tr>
  <tr>
    <td WIDTH="24%" VALIGN="TOP"><font SIZE="2">//TITLE</font></td>
    <td WIDTH="76%" VALIGN="TOP"><font SIZE="2">Selects all TITLE elements anywhere in the document</font></td>
  </tr>
  <tr>
    <td WIDTH="24%" VALIGN="TOP"><font SIZE="2">ancestor::SECTION</font></td>
    <td WIDTH="76%" VALIGN="TOP"><font SIZE="2">Selects the innermost containing SECTION element</font></td>
  </tr>  
  <tr>
    <td WIDTH="24%" VALIGN="TOP"><font SIZE="2">ancestor::SECTION/@TITLE</font></td>
    <td WIDTH="76%" VALIGN="TOP"><font SIZE="2">Selects the TITLE attribute of the innermost containing SECTION element</font></td>
  </tr>
  <tr>
    <td WIDTH="24%" VALIGN="TOP"><font SIZE="2">./@*</font></td>
    <td WIDTH="76%" VALIGN="TOP"><font SIZE="2">Selects all attributes of the current element</font></td>
  </tr> 

</table>

<hr>

<a name="TypeConversion"><h2>Type Conversion Expressions</h2></a>

<p>Saxon implements the two XPath expressions:</p>

<ul>
<li><code>cast as <i>type</i> ( <i>expression</i> )</code></li>
<li><code>treat as <i>type</i> ( <i>expression</i> )</code></li>
</ul>

<p><code class="bold">cast as</code> performs a conversion of the supplied value to the specified type, for
example it can be used to convert a date to a string.</p>

<p><code class="bold">treat as</code> is a way of asserting that the value is already of the required type;
if it is not, an error is reported. For example, <code>treat as xsd:integer (my:func())</code>
is a way of telling the system that <code>my:func</code> is expected to return an integer.</p>

<p>Saxon also implements the <code>instance of</code> operator which tests whether a value
is of a specified type.</p>

-->
<hr>
<p align="center"><a HREF="mailto:michael.h.kay@ntlworld.com">Michael H. Kay</a> <br>
12 November 2002</p>
</body>
</html>
